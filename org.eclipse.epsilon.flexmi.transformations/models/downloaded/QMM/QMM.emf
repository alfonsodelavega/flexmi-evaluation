@namespace(uri="/QMM/model/QMM.ecore", prefix="qmm")
package qmm;

import "http://www.eclipse.org/emf/2003/XMLType";

datatype AttributeDataType : java.lang.String;

class AttributeFamily extends Attribute, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class AttributeNameMapping extends CAEXBasicObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int roleAttribute_upperBound = 1;
int nr_nonTransitive_roleAttribute = 0;
if(this.roleAttribute != null){
		for(qmm.OrGroup og : this.roleAttribute) if(!og.isTransitive()) nr_nonTransitive_roleAttribute++;
}
if(nr_nonTransitive_roleAttribute > roleAttribute_upperBound && roleAttribute_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_roleAttribute + \" non-transitive roleAttribute. Only \" + roleAttribute_upperBound + \" are allowed.\",new Object[] { this }));

final int systemUnitAttribute_upperBound = 1;
int nr_nonTransitive_systemUnitAttribute = 0;
if(this.systemUnitAttribute != null){
		for(qmm.OrGroup og : this.systemUnitAttribute) if(!og.isTransitive()) nr_nonTransitive_systemUnitAttribute++;
}
if(nr_nonTransitive_systemUnitAttribute > systemUnitAttribute_upperBound && systemUnitAttribute_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_systemUnitAttribute + \" non-transitive systemUnitAttribute. Only \" + systemUnitAttribute_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val Attribute_OrGroup[*] roleAttribute;
	val Attribute_OrGroup[*] systemUnitAttribute;
	val AttributeNameMapping_roleAttributeName_AttrEClass roleAttributeName_AttrEClass;
	val AttributeNameMapping_systemUnitAttributeName_AttrEClass systemUnitAttributeName_AttrEClass;
}

class Attribute extends CAEXObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int refSemantic_upperBound = -1;
int nr_nonTransitive_refSemantic = 0;
if(this.refSemantic != null){
		for(qmm.OrGroup og : this.refSemantic) if(!og.isTransitive()) nr_nonTransitive_refSemantic++;
}
if(nr_nonTransitive_refSemantic > refSemantic_upperBound && refSemantic_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_refSemantic + \" non-transitive refSemantic. Only \" + refSemantic_upperBound + \" are allowed.\",new Object[] { this }));

final int constraint_upperBound = -1;
int nr_nonTransitive_constraint = 0;
if(this.constraint != null){
		for(qmm.OrGroup og : this.constraint) if(!og.isTransitive()) nr_nonTransitive_constraint++;
}
if(nr_nonTransitive_constraint > constraint_upperBound && constraint_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_constraint + \" non-transitive constraint. Only \" + constraint_upperBound + \" are allowed.\",new Object[] { this }));

final int attribute_upperBound = -1;
int nr_nonTransitive_attribute = 0;
if(this.attribute != null){
		for(qmm.OrGroup og : this.attribute) if(!og.isTransitive()) nr_nonTransitive_attribute++;
}
if(nr_nonTransitive_attribute > attribute_upperBound && attribute_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_attribute + \" non-transitive attribute. Only \" + attribute_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val RefSemantic_OrGroup[*] refSemantic;
	!resolve val AttributeValueRequirement_OrGroup[*] constraint;
	!resolve val Attribute_OrGroup[*] attribute;
	val Attribute_defaultValue_AttrEClass defaultValue_AttrEClass;
	val Attribute_value_AttrEClass value_AttrEClass;
	val Attribute_attributeDataType_AttrEClass attributeDataType_AttrEClass;
	val Attribute_refAttributeType_AttrEClass refAttributeType_AttrEClass;
	val Attribute_unit_AttrEClass unit_AttrEClass;
}

class AttributeLib extends CAEXObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int attributeType_upperBound = -1;
int nr_nonTransitive_attributeType = 0;
if(this.attributeType != null){
		for(qmm.OrGroup og : this.attributeType) if(!og.isTransitive()) nr_nonTransitive_attributeType++;
}
if(nr_nonTransitive_attributeType > attributeType_upperBound && attributeType_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_attributeType + \" non-transitive attributeType. Only \" + attributeType_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val Attribute_OrGroup[*] attributeType;
}

class AttributeValueRequirement extends CAEXBasicObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int ordinalScaledType_upperBound = 1;
int nr_nonTransitive_ordinalScaledType = 0;
if(this.ordinalScaledType != null){
		for(qmm.OrGroup og : this.ordinalScaledType) if(!og.isTransitive()) nr_nonTransitive_ordinalScaledType++;
}
if(nr_nonTransitive_ordinalScaledType > ordinalScaledType_upperBound && ordinalScaledType_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_ordinalScaledType + \" non-transitive ordinalScaledType. Only \" + ordinalScaledType_upperBound + \" are allowed.\",new Object[] { this }));

final int nominalScaledType_upperBound = 1;
int nr_nonTransitive_nominalScaledType = 0;
if(this.nominalScaledType != null){
		for(qmm.OrGroup og : this.nominalScaledType) if(!og.isTransitive()) nr_nonTransitive_nominalScaledType++;
}
if(nr_nonTransitive_nominalScaledType > nominalScaledType_upperBound && nominalScaledType_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_nominalScaledType + \" non-transitive nominalScaledType. Only \" + nominalScaledType_upperBound + \" are allowed.\",new Object[] { this }));

final int unknownType_upperBound = 1;
int nr_nonTransitive_unknownType = 0;
if(this.unknownType != null){
		for(qmm.OrGroup og : this.unknownType) if(!og.isTransitive()) nr_nonTransitive_unknownType++;
}
if(nr_nonTransitive_unknownType > unknownType_upperBound && unknownType_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_unknownType + \" non-transitive unknownType. Only \" + unknownType_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val OrdinalScaledType_OrGroup[*] ordinalScaledType;
	!resolve val NominalScaledType_OrGroup[*] nominalScaledType;
	!resolve val UnknownType_OrGroup[*] unknownType;
	val AttributeValueRequirement_name_AttrEClass name_AttrEClass;
}

class CAEXBasicObject extends RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int description_upperBound = 1;
int nr_nonTransitive_description = 0;
if(this.description != null){
		for(qmm.OrGroup og : this.description) if(!og.isTransitive()) nr_nonTransitive_description++;
}
if(nr_nonTransitive_description > description_upperBound && description_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_description + \" non-transitive description. Only \" + description_upperBound + \" are allowed.\",new Object[] { this }));

final int version_upperBound = 1;
int nr_nonTransitive_version = 0;
if(this.version != null){
		for(qmm.OrGroup og : this.version) if(!og.isTransitive()) nr_nonTransitive_version++;
}
if(nr_nonTransitive_version > version_upperBound && version_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_version + \" non-transitive version. Only \" + version_upperBound + \" are allowed.\",new Object[] { this }));

final int revision_upperBound = -1;
int nr_nonTransitive_revision = 0;
if(this.revision != null){
		for(qmm.OrGroup og : this.revision) if(!og.isTransitive()) nr_nonTransitive_revision++;
}
if(nr_nonTransitive_revision > revision_upperBound && revision_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_revision + \" non-transitive revision. Only \" + revision_upperBound + \" are allowed.\",new Object[] { this }));

final int copyright_upperBound = 1;
int nr_nonTransitive_copyright = 0;
if(this.copyright != null){
		for(qmm.OrGroup og : this.copyright) if(!og.isTransitive()) nr_nonTransitive_copyright++;
}
if(nr_nonTransitive_copyright > copyright_upperBound && copyright_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_copyright + \" non-transitive copyright. Only \" + copyright_upperBound + \" are allowed.\",new Object[] { this }));

final int additionalInformation_upperBound = 1;
int nr_nonTransitive_additionalInformation = 0;
if(this.additionalInformation != null){
		for(qmm.OrGroup og : this.additionalInformation) if(!og.isTransitive()) nr_nonTransitive_additionalInformation++;
}
if(nr_nonTransitive_additionalInformation > additionalInformation_upperBound && additionalInformation_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_additionalInformation + \" non-transitive additionalInformation. Only \" + additionalInformation_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val Description_OrGroup[*] description;
	val Version_OrGroup[*] version;
	val Revision_OrGroup[*] revision;
	val Copyright_OrGroup[*] copyright;
	val AdditionalInformation_OrGroup[*] additionalInformation;
	val CAEXBasicObject_changeMode_AttrEClass changeMode_AttrEClass;
}

class CAEXFile extends CAEXBasicObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int sourceDocumentInformation_upperBound = -1;
int nr_nonTransitive_sourceDocumentInformation = 0;
if(this.sourceDocumentInformation != null){
		for(qmm.OrGroup og : this.sourceDocumentInformation) if(!og.isTransitive()) nr_nonTransitive_sourceDocumentInformation++;
}
if(nr_nonTransitive_sourceDocumentInformation > sourceDocumentInformation_upperBound && sourceDocumentInformation_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_sourceDocumentInformation + \" non-transitive sourceDocumentInformation. Only \" + sourceDocumentInformation_upperBound + \" are allowed.\",new Object[] { this }));

final int externalReference_upperBound = -1;
int nr_nonTransitive_externalReference = 0;
if(this.externalReference != null){
		for(qmm.OrGroup og : this.externalReference) if(!og.isTransitive()) nr_nonTransitive_externalReference++;
}
if(nr_nonTransitive_externalReference > externalReference_upperBound && externalReference_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_externalReference + \" non-transitive externalReference. Only \" + externalReference_upperBound + \" are allowed.\",new Object[] { this }));

final int instanceHierarchy_upperBound = -1;
int nr_nonTransitive_instanceHierarchy = 0;
if(this.instanceHierarchy != null){
		for(qmm.OrGroup og : this.instanceHierarchy) if(!og.isTransitive()) nr_nonTransitive_instanceHierarchy++;
}
if(nr_nonTransitive_instanceHierarchy > instanceHierarchy_upperBound && instanceHierarchy_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_instanceHierarchy + \" non-transitive instanceHierarchy. Only \" + instanceHierarchy_upperBound + \" are allowed.\",new Object[] { this }));

final int interfaceClassLib_upperBound = -1;
int nr_nonTransitive_interfaceClassLib = 0;
if(this.interfaceClassLib != null){
		for(qmm.OrGroup og : this.interfaceClassLib) if(!og.isTransitive()) nr_nonTransitive_interfaceClassLib++;
}
if(nr_nonTransitive_interfaceClassLib > interfaceClassLib_upperBound && interfaceClassLib_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_interfaceClassLib + \" non-transitive interfaceClassLib. Only \" + interfaceClassLib_upperBound + \" are allowed.\",new Object[] { this }));

final int roleClassLib_upperBound = -1;
int nr_nonTransitive_roleClassLib = 0;
if(this.roleClassLib != null){
		for(qmm.OrGroup og : this.roleClassLib) if(!og.isTransitive()) nr_nonTransitive_roleClassLib++;
}
if(nr_nonTransitive_roleClassLib > roleClassLib_upperBound && roleClassLib_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_roleClassLib + \" non-transitive roleClassLib. Only \" + roleClassLib_upperBound + \" are allowed.\",new Object[] { this }));

final int systemUnitClassLib_upperBound = -1;
int nr_nonTransitive_systemUnitClassLib = 0;
if(this.systemUnitClassLib != null){
		for(qmm.OrGroup og : this.systemUnitClassLib) if(!og.isTransitive()) nr_nonTransitive_systemUnitClassLib++;
}
if(nr_nonTransitive_systemUnitClassLib > systemUnitClassLib_upperBound && systemUnitClassLib_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_systemUnitClassLib + \" non-transitive systemUnitClassLib. Only \" + systemUnitClassLib_upperBound + \" are allowed.\",new Object[] { this }));

final int attributeTypeLib_upperBound = -1;
int nr_nonTransitive_attributeTypeLib = 0;
if(this.attributeTypeLib != null){
		for(qmm.OrGroup og : this.attributeTypeLib) if(!og.isTransitive()) nr_nonTransitive_attributeTypeLib++;
}
if(nr_nonTransitive_attributeTypeLib > attributeTypeLib_upperBound && attributeTypeLib_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_attributeTypeLib + \" non-transitive attributeTypeLib. Only \" + attributeTypeLib_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val SourceDocumentInformation_OrGroup[*] sourceDocumentInformation;
	!resolve val ExternalReferenceType_OrGroup[*] externalReference;
	!resolve val InstanceHierarchy_OrGroup[*] instanceHierarchy;
	!resolve val InterfaceClassLib_OrGroup[*] interfaceClassLib;
	!resolve val RoleClassLib_OrGroup[*] roleClassLib;
	!resolve val SystemUnitClassLib_OrGroup[*] systemUnitClassLib;
	!resolve val AttributeLib_OrGroup[*] attributeTypeLib;
	val CAEXFile_superiorStandardVersion_AttrEClass[*] superiorStandardVersion_AttrEClass;
	val CAEXFile_fileName_AttrEClass fileName_AttrEClass;
	val CAEXFile_schemaVersion_AttrEClass schemaVersion_AttrEClass;
}

class CAEXObject extends CAEXBasicObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val CAEXObject_iD_AttrEClass iD_AttrEClass;
	val CAEXObject_name_AttrEClass name_AttrEClass;
}

enum ChangeMode {
	state = 0;
	create = 1;
	delete = 2;
	change = 3;
}

datatype ChangeModeObject : org.eclipse.emf.common.util.Enumerator;

class DocumentRoot extends RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	transient !resolve val ecore.EStringToStringMapEntry[*] xMLNSPrefixMap;
	transient !resolve val ecore.EStringToStringMapEntry[*] xSISchemaLocation;
	volatile transient derived !resolve val CAEXFile_OrGroup[*] cAEXFile;
	val DocumentRoot_mixed_AttrEClass[*] mixed_AttrEClass;
}

class ExternalInterface extends InterfaceClass, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int externalInterface_upperBound = -1;
int nr_nonTransitive_externalInterface = 0;
if(this.externalInterface != null){
		for(qmm.OrGroup og : this.externalInterface) if(!og.isTransitive()) nr_nonTransitive_externalInterface++;
}
if(nr_nonTransitive_externalInterface > externalInterface_upperBound && externalInterface_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_externalInterface + \" non-transitive externalInterface. Only \" + externalInterface_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val InterfaceClass_OrGroup[*] externalInterface;
}

class ExternalReferenceType extends CAEXBasicObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val ExternalReferenceType_alias_AttrEClass alias_AttrEClass;
	val ExternalReferenceType_path_AttrEClass path_AttrEClass;
}

class InstanceHierarchy extends CAEXObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int internalElement_upperBound = -1;
int nr_nonTransitive_internalElement = 0;
if(this.internalElement != null){
		for(qmm.OrGroup og : this.internalElement) if(!og.isTransitive()) nr_nonTransitive_internalElement++;
}
if(nr_nonTransitive_internalElement > internalElement_upperBound && internalElement_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_internalElement + \" non-transitive internalElement. Only \" + internalElement_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val InternalElement_OrGroup[*] internalElement;
}

class InterfaceClassLib extends CAEXObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int interfaceClass_upperBound = -1;
int nr_nonTransitive_interfaceClass = 0;
if(this.interfaceClass != null){
		for(qmm.OrGroup og : this.interfaceClass) if(!og.isTransitive()) nr_nonTransitive_interfaceClass++;
}
if(nr_nonTransitive_interfaceClass > interfaceClass_upperBound && interfaceClass_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_interfaceClass + \" non-transitive interfaceClass. Only \" + interfaceClass_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val InterfaceClass_OrGroup[*] interfaceClass;
}

class InterfaceClass extends CAEXObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int attribute_upperBound = -1;
int nr_nonTransitive_attribute = 0;
if(this.attribute != null){
		for(qmm.OrGroup og : this.attribute) if(!og.isTransitive()) nr_nonTransitive_attribute++;
}
if(nr_nonTransitive_attribute > attribute_upperBound && attribute_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_attribute + \" non-transitive attribute. Only \" + attribute_upperBound + \" are allowed.\",new Object[] { this }));

final int baseClass_upperBound = 1;
int nr_nonTransitive_baseClass = 0;
if(this.baseClass != null){
		for(qmm.OrGroup og : this.baseClass) if(!og.isTransitive()) nr_nonTransitive_baseClass++;
}
if(nr_nonTransitive_baseClass > baseClass_upperBound && baseClass_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_baseClass + \" non-transitive baseClass. Only \" + baseClass_upperBound + \" are allowed.\",new Object[] { this }));

final int interfaceClass_upperBound = -1;
int nr_nonTransitive_interfaceClass = 0;
if(this.interfaceClass != null){
		for(qmm.OrGroup og : this.interfaceClass) if(!og.isTransitive()) nr_nonTransitive_interfaceClass++;
}
if(nr_nonTransitive_interfaceClass > interfaceClass_upperBound && interfaceClass_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_interfaceClass + \" non-transitive interfaceClass. Only \" + interfaceClass_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val Attribute_OrGroup[*] attribute;
	val InterfaceClass_OrGroup[*] baseClass;
	val InterfaceClass_OrGroup[*] interfaceClass;
	val InterfaceClass_refBaseClassPath_AttrEClass refBaseClassPath_AttrEClass;
}

class InterfaceFamily extends InterfaceClass, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class InterfaceIDMapping extends CAEXBasicObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int roleInterface_upperBound = 1;
int nr_nonTransitive_roleInterface = 0;
if(this.roleInterface != null){
		for(qmm.OrGroup og : this.roleInterface) if(!og.isTransitive()) nr_nonTransitive_roleInterface++;
}
if(nr_nonTransitive_roleInterface > roleInterface_upperBound && roleInterface_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_roleInterface + \" non-transitive roleInterface. Only \" + roleInterface_upperBound + \" are allowed.\",new Object[] { this }));

final int systemUnitInterface_upperBound = 1;
int nr_nonTransitive_systemUnitInterface = 0;
if(this.systemUnitInterface != null){
		for(qmm.OrGroup og : this.systemUnitInterface) if(!og.isTransitive()) nr_nonTransitive_systemUnitInterface++;
}
if(nr_nonTransitive_systemUnitInterface > systemUnitInterface_upperBound && systemUnitInterface_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_systemUnitInterface + \" non-transitive systemUnitInterface. Only \" + systemUnitInterface_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val ExternalInterface_OrGroup[*] roleInterface;
	val ExternalInterface_OrGroup[*] systemUnitInterface;
	val InterfaceIDMapping_roleInterfaceID_AttrEClass roleInterfaceID_AttrEClass;
	val InterfaceIDMapping_systemUnitInterfaceID_AttrEClass systemUnitInterfaceID_AttrEClass;
}

class InternalElement extends SystemUnitClass, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int roleRequirements_upperBound = -1;
int nr_nonTransitive_roleRequirements = 0;
if(this.roleRequirements != null){
		for(qmm.OrGroup og : this.roleRequirements) if(!og.isTransitive()) nr_nonTransitive_roleRequirements++;
}
if(nr_nonTransitive_roleRequirements > roleRequirements_upperBound && roleRequirements_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_roleRequirements + \" non-transitive roleRequirements. Only \" + roleRequirements_upperBound + \" are allowed.\",new Object[] { this }));

final int baseSystemUnit_upperBound = 1;
int nr_nonTransitive_baseSystemUnit = 0;
if(this.baseSystemUnit != null){
		for(qmm.OrGroup og : this.baseSystemUnit) if(!og.isTransitive()) nr_nonTransitive_baseSystemUnit++;
}
if(nr_nonTransitive_baseSystemUnit > baseSystemUnit_upperBound && baseSystemUnit_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_baseSystemUnit + \" non-transitive baseSystemUnit. Only \" + baseSystemUnit_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val RoleRequirements_OrGroup[*] roleRequirements;
	val SystemUnitClass_OrGroup[*] baseSystemUnit;
	val InternalElement_refBaseSystemUnitPath_AttrEClass refBaseSystemUnitPath_AttrEClass;
}

class InternalLink extends CAEXObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int partnerSideA_upperBound = 1;
int nr_nonTransitive_partnerSideA = 0;
if(this.partnerSideA != null){
		for(qmm.OrGroup og : this.partnerSideA) if(!og.isTransitive()) nr_nonTransitive_partnerSideA++;
}
if(nr_nonTransitive_partnerSideA > partnerSideA_upperBound && partnerSideA_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_partnerSideA + \" non-transitive partnerSideA. Only \" + partnerSideA_upperBound + \" are allowed.\",new Object[] { this }));

final int partnerSideB_upperBound = 1;
int nr_nonTransitive_partnerSideB = 0;
if(this.partnerSideB != null){
		for(qmm.OrGroup og : this.partnerSideB) if(!og.isTransitive()) nr_nonTransitive_partnerSideB++;
}
if(nr_nonTransitive_partnerSideB > partnerSideB_upperBound && partnerSideB_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_partnerSideB + \" non-transitive partnerSideB. Only \" + partnerSideB_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val ExternalInterface_OrGroup[*] partnerSideA;
	val ExternalInterface_OrGroup[*] partnerSideB;
	val InternalLink_refPartnerSideA_AttrEClass refPartnerSideA_AttrEClass;
	val InternalLink_refPartnerSideB_AttrEClass refPartnerSideB_AttrEClass;
}

class Mapping extends CAEXBasicObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int attributeNameMapping_upperBound = -1;
int nr_nonTransitive_attributeNameMapping = 0;
if(this.attributeNameMapping != null){
		for(qmm.OrGroup og : this.attributeNameMapping) if(!og.isTransitive()) nr_nonTransitive_attributeNameMapping++;
}
if(nr_nonTransitive_attributeNameMapping > attributeNameMapping_upperBound && attributeNameMapping_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_attributeNameMapping + \" non-transitive attributeNameMapping. Only \" + attributeNameMapping_upperBound + \" are allowed.\",new Object[] { this }));

final int interfaceIDMapping_upperBound = -1;
int nr_nonTransitive_interfaceIDMapping = 0;
if(this.interfaceIDMapping != null){
		for(qmm.OrGroup og : this.interfaceIDMapping) if(!og.isTransitive()) nr_nonTransitive_interfaceIDMapping++;
}
if(nr_nonTransitive_interfaceIDMapping > interfaceIDMapping_upperBound && interfaceIDMapping_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_interfaceIDMapping + \" non-transitive interfaceIDMapping. Only \" + interfaceIDMapping_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val AttributeNameMapping_OrGroup[*] attributeNameMapping;
	!resolve val InterfaceIDMapping_OrGroup[*] interfaceIDMapping;
}

class NominalScaledType extends RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val NominalScaledType_requiredValue_AttrEClass[*] requiredValue_AttrEClass;
}

class OrdinalScaledType extends RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val OrdinalScaledType_requiredMaxValue_AttrEClass requiredMaxValue_AttrEClass;
	val OrdinalScaledType_requiredValue_AttrEClass requiredValue_AttrEClass;
	val OrdinalScaledType_requiredMinValue_AttrEClass requiredMinValue_AttrEClass;
}

class RefSemantic extends CAEXBasicObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val RefSemantic_correspondingAttributePath_AttrEClass correspondingAttributePath_AttrEClass;
}

class RoleClassLib extends CAEXObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int roleClass_upperBound = -1;
int nr_nonTransitive_roleClass = 0;
if(this.roleClass != null){
		for(qmm.OrGroup og : this.roleClass) if(!og.isTransitive()) nr_nonTransitive_roleClass++;
}
if(nr_nonTransitive_roleClass > roleClass_upperBound && roleClass_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_roleClass + \" non-transitive roleClass. Only \" + roleClass_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val RoleClass_OrGroup[*] roleClass;
}

class RoleClass extends CAEXObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int attribute_upperBound = -1;
int nr_nonTransitive_attribute = 0;
if(this.attribute != null){
		for(qmm.OrGroup og : this.attribute) if(!og.isTransitive()) nr_nonTransitive_attribute++;
}
if(nr_nonTransitive_attribute > attribute_upperBound && attribute_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_attribute + \" non-transitive attribute. Only \" + attribute_upperBound + \" are allowed.\",new Object[] { this }));

final int externalInterface_upperBound = -1;
int nr_nonTransitive_externalInterface = 0;
if(this.externalInterface != null){
		for(qmm.OrGroup og : this.externalInterface) if(!og.isTransitive()) nr_nonTransitive_externalInterface++;
}
if(nr_nonTransitive_externalInterface > externalInterface_upperBound && externalInterface_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_externalInterface + \" non-transitive externalInterface. Only \" + externalInterface_upperBound + \" are allowed.\",new Object[] { this }));

final int baseClass_upperBound = 1;
int nr_nonTransitive_baseClass = 0;
if(this.baseClass != null){
		for(qmm.OrGroup og : this.baseClass) if(!og.isTransitive()) nr_nonTransitive_baseClass++;
}
if(nr_nonTransitive_baseClass > baseClass_upperBound && baseClass_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_baseClass + \" non-transitive baseClass. Only \" + baseClass_upperBound + \" are allowed.\",new Object[] { this }));

final int roleClass_upperBound = -1;
int nr_nonTransitive_roleClass = 0;
if(this.roleClass != null){
		for(qmm.OrGroup og : this.roleClass) if(!og.isTransitive()) nr_nonTransitive_roleClass++;
}
if(nr_nonTransitive_roleClass > roleClass_upperBound && roleClass_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_roleClass + \" non-transitive roleClass. Only \" + roleClass_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val Attribute_OrGroup[*] attribute;
	!resolve val ExternalInterface_OrGroup[*] externalInterface;
	val RoleClass_OrGroup[*] baseClass;
	!resolve val RoleClass_OrGroup[*] roleClass;
	val RoleClass_refBaseClassPath_AttrEClass refBaseClassPath_AttrEClass;
}

class RoleFamily extends RoleClass, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class RoleRequirements extends CAEXBasicObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int attribute_upperBound = -1;
int nr_nonTransitive_attribute = 0;
if(this.attribute != null){
		for(qmm.OrGroup og : this.attribute) if(!og.isTransitive()) nr_nonTransitive_attribute++;
}
if(nr_nonTransitive_attribute > attribute_upperBound && attribute_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_attribute + \" non-transitive attribute. Only \" + attribute_upperBound + \" are allowed.\",new Object[] { this }));

final int externalInterface_upperBound = -1;
int nr_nonTransitive_externalInterface = 0;
if(this.externalInterface != null){
		for(qmm.OrGroup og : this.externalInterface) if(!og.isTransitive()) nr_nonTransitive_externalInterface++;
}
if(nr_nonTransitive_externalInterface > externalInterface_upperBound && externalInterface_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_externalInterface + \" non-transitive externalInterface. Only \" + externalInterface_upperBound + \" are allowed.\",new Object[] { this }));

final int mappingObject_upperBound = 1;
int nr_nonTransitive_mappingObject = 0;
if(this.mappingObject != null){
		for(qmm.OrGroup og : this.mappingObject) if(!og.isTransitive()) nr_nonTransitive_mappingObject++;
}
if(nr_nonTransitive_mappingObject > mappingObject_upperBound && mappingObject_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_mappingObject + \" non-transitive mappingObject. Only \" + mappingObject_upperBound + \" are allowed.\",new Object[] { this }));

final int roleClass_upperBound = 1;
int nr_nonTransitive_roleClass = 0;
if(this.roleClass != null){
		for(qmm.OrGroup og : this.roleClass) if(!og.isTransitive()) nr_nonTransitive_roleClass++;
}
if(nr_nonTransitive_roleClass > roleClass_upperBound && roleClass_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_roleClass + \" non-transitive roleClass. Only \" + roleClass_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val Attribute_OrGroup[*] attribute;
	!resolve val InterfaceClass_OrGroup[*] externalInterface;
	!resolve val Mapping_OrGroup[*] mappingObject;
	val RoleClass_OrGroup[*] roleClass;
}

class SourceDocumentInformation extends RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val SourceDocumentInformation_lastWritingDateTime_AttrEClass lastWritingDateTime_AttrEClass;
	val SourceDocumentInformation_originID_AttrEClass originID_AttrEClass;
	val SourceDocumentInformation_originName_AttrEClass originName_AttrEClass;
	val SourceDocumentInformation_originProjectID_AttrEClass originProjectID_AttrEClass;
	val SourceDocumentInformation_originProjectTitle_AttrEClass originProjectTitle_AttrEClass;
	val SourceDocumentInformation_originRelease_AttrEClass originRelease_AttrEClass;
	val SourceDocumentInformation_originVendor_AttrEClass originVendor_AttrEClass;
	val SourceDocumentInformation_originVendorURL_AttrEClass originVendorURL_AttrEClass;
	val SourceDocumentInformation_originVersion_AttrEClass originVersion_AttrEClass;
}

class SupportedRoleClass extends CAEXBasicObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int mappingObject_upperBound = 1;
int nr_nonTransitive_mappingObject = 0;
if(this.mappingObject != null){
		for(qmm.OrGroup og : this.mappingObject) if(!og.isTransitive()) nr_nonTransitive_mappingObject++;
}
if(nr_nonTransitive_mappingObject > mappingObject_upperBound && mappingObject_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_mappingObject + \" non-transitive mappingObject. Only \" + mappingObject_upperBound + \" are allowed.\",new Object[] { this }));

final int roleClass_upperBound = 1;
int nr_nonTransitive_roleClass = 0;
if(this.roleClass != null){
		for(qmm.OrGroup og : this.roleClass) if(!og.isTransitive()) nr_nonTransitive_roleClass++;
}
if(nr_nonTransitive_roleClass > roleClass_upperBound && roleClass_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_roleClass + \" non-transitive roleClass. Only \" + roleClass_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val Mapping_OrGroup[*] mappingObject;
	val RoleClass_OrGroup[*] roleClass;
	val SupportedRoleClass_refRoleClassPath_AttrEClass refRoleClassPath_AttrEClass;
}

class SystemUnitClassLib extends CAEXObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int systemUnitClass_upperBound = -1;
int nr_nonTransitive_systemUnitClass = 0;
if(this.systemUnitClass != null){
		for(qmm.OrGroup og : this.systemUnitClass) if(!og.isTransitive()) nr_nonTransitive_systemUnitClass++;
}
if(nr_nonTransitive_systemUnitClass > systemUnitClass_upperBound && systemUnitClass_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_systemUnitClass + \" non-transitive systemUnitClass. Only \" + systemUnitClass_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val SystemUnitClass_OrGroup[*] systemUnitClass;
}

class SystemUnitClass extends CAEXObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int attribute_upperBound = -1;
int nr_nonTransitive_attribute = 0;
if(this.attribute != null){
		for(qmm.OrGroup og : this.attribute) if(!og.isTransitive()) nr_nonTransitive_attribute++;
}
if(nr_nonTransitive_attribute > attribute_upperBound && attribute_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_attribute + \" non-transitive attribute. Only \" + attribute_upperBound + \" are allowed.\",new Object[] { this }));

final int externalInterface_upperBound = -1;
int nr_nonTransitive_externalInterface = 0;
if(this.externalInterface != null){
		for(qmm.OrGroup og : this.externalInterface) if(!og.isTransitive()) nr_nonTransitive_externalInterface++;
}
if(nr_nonTransitive_externalInterface > externalInterface_upperBound && externalInterface_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_externalInterface + \" non-transitive externalInterface. Only \" + externalInterface_upperBound + \" are allowed.\",new Object[] { this }));

final int internalElement_upperBound = -1;
int nr_nonTransitive_internalElement = 0;
if(this.internalElement != null){
		for(qmm.OrGroup og : this.internalElement) if(!og.isTransitive()) nr_nonTransitive_internalElement++;
}
if(nr_nonTransitive_internalElement > internalElement_upperBound && internalElement_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_internalElement + \" non-transitive internalElement. Only \" + internalElement_upperBound + \" are allowed.\",new Object[] { this }));

final int supportedRoleClass_upperBound = -1;
int nr_nonTransitive_supportedRoleClass = 0;
if(this.supportedRoleClass != null){
		for(qmm.OrGroup og : this.supportedRoleClass) if(!og.isTransitive()) nr_nonTransitive_supportedRoleClass++;
}
if(nr_nonTransitive_supportedRoleClass > supportedRoleClass_upperBound && supportedRoleClass_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_supportedRoleClass + \" non-transitive supportedRoleClass. Only \" + supportedRoleClass_upperBound + \" are allowed.\",new Object[] { this }));

final int internalLink_upperBound = -1;
int nr_nonTransitive_internalLink = 0;
if(this.internalLink != null){
		for(qmm.OrGroup og : this.internalLink) if(!og.isTransitive()) nr_nonTransitive_internalLink++;
}
if(nr_nonTransitive_internalLink > internalLink_upperBound && internalLink_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_internalLink + \" non-transitive internalLink. Only \" + internalLink_upperBound + \" are allowed.\",new Object[] { this }));

final int baseClass_upperBound = 1;
int nr_nonTransitive_baseClass = 0;
if(this.baseClass != null){
		for(qmm.OrGroup og : this.baseClass) if(!og.isTransitive()) nr_nonTransitive_baseClass++;
}
if(nr_nonTransitive_baseClass > baseClass_upperBound && baseClass_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_baseClass + \" non-transitive baseClass. Only \" + baseClass_upperBound + \" are allowed.\",new Object[] { this }));

final int systemUnitClass_upperBound = -1;
int nr_nonTransitive_systemUnitClass = 0;
if(this.systemUnitClass != null){
		for(qmm.OrGroup og : this.systemUnitClass) if(!og.isTransitive()) nr_nonTransitive_systemUnitClass++;
}
if(nr_nonTransitive_systemUnitClass > systemUnitClass_upperBound && systemUnitClass_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_systemUnitClass + \" non-transitive systemUnitClass. Only \" + systemUnitClass_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	!resolve val Attribute_OrGroup[*] attribute;
	!resolve val InterfaceClass_OrGroup[*] externalInterface;
	!resolve val InternalElement_OrGroup[*] internalElement;
	!resolve val SupportedRoleClass_OrGroup[*] supportedRoleClass;
	!resolve val InternalLink_OrGroup[*] internalLink;
	val SystemUnitClass_OrGroup[*] baseClass;
	!resolve val SystemUnitClass_OrGroup[*] systemUnitClass;
	val SystemUnitClass_refBaseClassPath_AttrEClass refBaseClassPath_AttrEClass;
}

class SystemUnitFamily extends SystemUnitClass, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class UnknownType extends RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val UnknownType_requirements_AttrEClass requirements_AttrEClass;
}

class Copyright extends RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val Copyright_value_AttrEClass value_AttrEClass;
	val Copyright_changeMode_AttrEClass changeMode_AttrEClass;
}

class Description extends RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val Description_value_AttrEClass value_AttrEClass;
	val Description_changeMode_AttrEClass changeMode_AttrEClass;
}

class Revision extends CAEXBasicObject, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val Revision_revisionDate_AttrEClass revisionDate_AttrEClass;
	val Revision_oldVersion_AttrEClass oldVersion_AttrEClass;
	val Revision_newVersion_AttrEClass newVersion_AttrEClass;
	val Revision_authorName_AttrEClass authorName_AttrEClass;
	val Revision_comment_AttrEClass comment_AttrEClass;
}

class Version extends RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val Version_value_AttrEClass value_AttrEClass;
	val Version_changeMode_AttrEClass changeMode_AttrEClass;
}

class AdditionalInformation extends GenericElement, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

abstract class Element extends RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val Element_name_AttrEClass name_AttrEClass;
	val Element_value_AttrEClass value_AttrEClass;
}

@ExtendedMetaData(kind="empty")
class GenericElement extends Element, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

final int nestedElements_upperBound = -1;
int nr_nonTransitive_nestedElements = 0;
if(this.nestedElements != null){
		for(qmm.OrGroup og : this.nestedElements) if(!og.isTransitive()) nr_nonTransitive_nestedElements++;
}
if(nr_nonTransitive_nestedElements > nestedElements_upperBound && nestedElements_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_nestedElements + \" non-transitive nestedElements. Only \" + nestedElements_upperBound + \" are allowed.\",new Object[] { this }));

final int attributes_upperBound = -1;
int nr_nonTransitive_attributes = 0;
if(this.attributes != null){
		for(qmm.OrGroup og : this.attributes) if(!og.isTransitive()) nr_nonTransitive_attributes++;
}
if(nr_nonTransitive_attributes > attributes_upperBound && attributes_upperBound > -1) diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"EClass contains \" + nr_nonTransitive_attributes + \" non-transitive attributes. Only \" + attributes_upperBound + \" are allowed.\",new Object[] { this }));

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);

	@ExtendedMetaData(kind="empty")
	val GenericElement_OrGroup[*] nestedElements;

	@ExtendedMetaData(kind="empty")
	val GenericAttribute_OrGroup[*] attributes;
	val GenericElement_elementFeatureMap_AttrEClass[*] elementFeatureMap_AttrEClass;
	val GenericElement_attributeFeatureMap_AttrEClass[*] attributeFeatureMap_AttrEClass;
}

@ExtendedMetaData(kind="empty")
class GenericAttribute extends Element, RootClass {

	@GenModel(body="if(diagnostic!=null){
    if(this.evaluationOperator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

abstract class NamedElement {
	id attr String[1] name;
}

abstract class Countable {
}

abstract class NegatableElement {
	attr boolean[1] negated = false;
}

abstract class OrGroup extends NamedElement, Countable, NegatableElement {

	@GenModel(body="EClass containerEClass = this.eContainingFeature().getEContainingClass();org.eclipse.emf.ecore.EClassifier eType = this.eClass().getEStructuralFeature(\"containment\").getEType();if(eType != null && eType instanceof EClass){	EClass typeEClass = (EClass)eType;	if(!containerEClass.isSuperTypeOf(typeEClass) && this.transitive){		String errorMessage = \"Feature \" + this.name + \" can't be transitive! It is defined by the type \" + containerEClass.getName() + \", but is itself not an instance of (a subtype of) this type.\";		diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OR_GROUP__VALIDATE, errorMessage,new Object[] { this }));	}}return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	attr boolean[1] transitive = false;
}

abstract class TypedElement {

	@GenModel(body="EClass typeEClass = QmmPackage.eINSTANCE.getType();
    EClass type = null;
    for(EClass possibleTypeSubClass : this.eClass().getEAllSuperTypes()){
    	if(typeEClass.isSuperTypeOf(possibleTypeSubClass) && !typeEClass.equals(possibleTypeSubClass)){
    		type = possibleTypeSubClass;
    	}
    }
    return type;")
	op EJavaObject[1] getType();
}

abstract class RootClass {

	@GenModel(body="EClass booleanType = QmmPackage.eINSTANCE.getBoolean_Type();
EClass functionalOperatorType = QmmPackage.eINSTANCE.getFunctionalOperator();
EClass bitOperatorType = QmmPackage.eINSTANCE.getBitOperator();
qmm.Operator operator = (qmm.Operator)o;
EList diagnosticList = new org.eclipse.emf.common.util.BasicEList();

if(functionalOperatorType.isSuperTypeOf(operator.eClass())){
	qmm.FunctionalOperator lastOperator = (qmm.FunctionalOperator)((qmm.FunctionalOperator)operator).getLastOperator();
    	EClass lastOperatorType = (EClass)lastOperator.getType();
    	if(!booleanType.isSuperTypeOf(lastOperatorType)){
			String errorMessage = \"Operator \" + lastOperator.eClass().getName() + \" of attribute \" + this.eClass().getName() + \" is of type \" + lastOperatorType.getName() + \", but must be (a subtype) of type \" + booleanType.getName() + \".\";
    		diagnosticList.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));
    	}
}else if(bitOperatorType.isSuperTypeOf(operator.eClass())){
    for(qmm.Operator op : (EList<qmm.Operator>)operator.eGet(operator.eClass().getEStructuralFeature(\"connects\"))){
    	diagnosticList.addAll(validateCheckExpression(op));
    }
}
return diagnosticList;")
	op EEList[1] validateCheckExpression(EJavaObject o);

	@GenModel(body="
	EList<qmm.Operator> operators = (EList<qmm.Operator>)o;
	EList diagnosticList = new org.eclipse.emf.common.util.BasicEList();
	if(operators != null){
		for(qmm.Operator operator:operators){
			diagnosticList.addAll(validateCheckExpression(operator));
		}
   }
	return diagnosticList;")
	op EEList[1] validateAllCheckExpressions(EJavaObject o);
	val EvaluationOperator[*] EvaluationOperator;
}

abstract class Query {
}

class FindQuery extends Query {
	val RootClass[+] where;
}

abstract class Calculateable {
}

abstract class CalculateableElement extends Calculateable {
}

abstract class AttributeEClass extends NamedElement, NegatableElement, Countable {
}

abstract class RegularAttributeEClass extends AttributeEClass {

	@GenModel(body="EClass booleanType = QmmPackage.eINSTANCE.getBoolean_Type();
EClass functionalOperatorType = QmmPackage.eINSTANCE.getFunctionalOperator();
EClass bitOperatorType = QmmPackage.eINSTANCE.getBitOperator();
qmm.Operator operator = (qmm.Operator)o;
EList diagnosticList = new org.eclipse.emf.common.util.BasicEList();

if(functionalOperatorType.isSuperTypeOf(operator.eClass())){
	qmm.FunctionalOperator lastOperator = (qmm.FunctionalOperator)((qmm.FunctionalOperator)operator).getLastOperator();
    	EClass lastOperatorType = (EClass)lastOperator.getType();
    	if(!booleanType.isSuperTypeOf(lastOperatorType)){
			String errorMessage = \"Operator \" + lastOperator.eClass().getName() + \" of attribute \" + this.eClass().getName() + \" is of type \" + lastOperatorType.getName() + \", but must be (a subtype) of type \" + booleanType.getName() + \".\";
    		diagnosticList.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));
    	}
}else if(bitOperatorType.isSuperTypeOf(operator.eClass())){
    for(qmm.Operator op : (EList<qmm.Operator>)operator.eGet(operator.eClass().getEStructuralFeature(\"connects\"))){
    	diagnosticList.addAll(validateCheckExpression(op));
    }
}
return diagnosticList;")
	op EEList[1] validateCheckExpression(EJavaObject o);
}

abstract class EnumerationAttributeEClass extends AttributeEClass {
}

abstract class Type {
}

abstract class FunctionalType extends Type {
}

abstract class Argument extends TypedElement {
}

abstract class ReferenceArgument extends Argument {
}

class Countable_ReferenceArgument extends ReferenceArgument {

	@GenModel(body="qmm.RootClass containingRootClass = null;
qmm.RootClass referencesRootClass = null;
qmm.Countable containingCountable = null;

if(this.eContainer() != null && this.reference != null){
		org.eclipse.emf.ecore.EObject eContainer = this.eContainer();
		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){
			if(eContainer instanceof qmm.Countable){
				containingCountable = (qmm.Countable)eContainer;
			}
			eContainer = eContainer.eContainer();
		}
		containingRootClass = (qmm.RootClass)eContainer;

		eContainer = this.reference.eContainer();
		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){
			eContainer = eContainer.eContainer();
		}

		referencesRootClass = (qmm.RootClass)eContainer;

		if(containingCountable != null && containingCountable == reference){  //self-reference in expression !
			String errorMessage = \"Self-reference in expression of \" + containingCountable + \" detected. Self-references are not allowed!\";
			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));
		}

		if(containingRootClass != referencesRootClass){
			String errorMessage = \"The referenced element \" + this.reference + \" is contained by a different parent-element than the expression's parent-element. Cross-references are not supported.\";
			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));
		}

		if(this.reference instanceof qmm.NegatableElement && ((qmm.NegatableElement)this.reference).isNegated())diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"Reference to a negated element in \" + this + \" has been detected. References to negated elements are not allowed.\",new Object[] { this }));
}

return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	ref Countable[1] reference;
}

abstract class Calculateable_Argument extends ReferenceArgument, FunctionalArgument {
}

abstract class CalculateableElement_ReferenceArgument extends Calculateable_Argument {
}

abstract class FunctionalArgument extends Argument {
}

abstract class EvaluationOperation_Argument extends Calculateable_Argument {
}

abstract class PrimitiveArgument extends FunctionalArgument {
}

abstract class Parameter extends TypedElement {
}

class CountableReferenceParameter extends Parameter {
	val Countable_ReferenceArgument[1] argument;
}

abstract class CalculateableParameter extends Parameter {
	val Calculateable_Argument[1] argument;
}

abstract class FunctionalParameter extends Parameter {
	val FunctionalArgument[1] argument;
}

abstract class Integer_Calculateable extends Calculateable {
}

abstract class Integer_CalculateableElement extends Integer_Calculateable, CalculateableElement {
}

abstract class Operator {
}

abstract class ExpressionOperator extends Operator {
}

abstract class EnumerationOperator extends Operator {
}

abstract class BitOperator extends ExpressionOperator, NegatableElement {
}

abstract class FunctionalOperator extends ExpressionOperator, TypedElement {

	@GenModel(body="qmm.FunctionalOperator operator = this;
while(operator.eGet(operator.eClass().getEStructuralFeature(\"operator\")) != null){
    operator = (qmm.FunctionalOperator) operator.eGet(operator.eClass().getEStructuralFeature(\"operator\"));
}
return operator;")
	op EJavaObject[1] getLastOperator();
}

abstract class ClassOperator extends EvaluationFunctionalOperator {
}

abstract class EvaluationOperator extends Operator {
}

abstract class EvaluationFunctionalOperator extends EvaluationOperator, FunctionalOperator {
}

abstract class AggregationOperator extends EvaluationFunctionalOperator, Integer_Calculateable {
}

abstract class EvaluationBitOperator extends EvaluationOperator, BitOperator {
	val EvaluationOperator[2..*] connects;
}

class And_EvaluationBitOperator extends EvaluationBitOperator {

	@GenModel(body="return \"&&\";")
	op String[1] getLiteral();
}

class Or_EvaluationBitOperator extends EvaluationBitOperator {

	@GenModel(body="return \"||\";")
	op String[1] getLiteral();
}

abstract class CountingAggregationOperator extends AggregationOperator {

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(countable);
return parameterList;")
	op EEList[1] getAllParameters();
	val CountableReferenceParameter[1] countable;
}

abstract class CalculatingAggregationOperator extends AggregationOperator {
}

abstract class String_Calculateable extends Calculateable {
}

abstract class String_CalculateableElement extends String_Calculateable, CalculateableElement {
}

abstract class String_AttributeEClass extends RegularAttributeEClass, String_CalculateableElement {

	@GenModel(body="if(diagnostic!=null){
    if(this.operator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateCheckExpression(this.operator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val String_ExpressionOperator operator;
}

abstract class String_Operator extends Operator {
}

@information(type="String")
abstract class String_Type extends Type, CharSequence_Type {
}

abstract class String_FunctionalType extends String_Type, FunctionalType {
	val String_FunctionalOperator operator;
}

class String_CalculateableParameter extends String_Type, CalculateableParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class String_FunctionalParameter extends String_Type, FunctionalParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

abstract class String_Argument extends FunctionalArgument, String_FunctionalType {
}

class String_PrimitiveArgument extends String_Argument, PrimitiveArgument {
	attr type.String[1] value;
}

@information(functionalType="String")
abstract class String_EvaluationOperation_Argument extends EvaluationOperation_Argument, String_Argument {
}

@information(functionalType="String")
class String_CalculateableElementReferenceArgument extends CalculateableElement_ReferenceArgument, String_FunctionalType {

	@GenModel(body="qmm.RootClass containingRootClass = null;
qmm.RootClass referencesRootClass = null;
qmm.AttributeEClass containingAttributeEClass = null;
qmm.AttributeEClass referencesAttributeEClass = null;
if(this.eContainer() != null && this.reference != null){
		org.eclipse.emf.ecore.EObject eContainer = this.eContainer();

		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){
			if(eContainer instanceof qmm.AttributeEClass){
				containingAttributeEClass = (qmm.AttributeEClass)eContainer;
			}
			eContainer = eContainer.eContainer();
		}
		containingRootClass = (qmm.RootClass)eContainer;

		eContainer = this.reference.eContainer();
		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){
			eContainer = eContainer.eContainer();
		}

		referencesRootClass = (qmm.RootClass)eContainer;
		if(this.reference instanceof qmm.AttributeEClass) referencesAttributeEClass = (qmm.AttributeEClass)this.reference;

		if(containingAttributeEClass != null && referencesAttributeEClass != null && containingAttributeEClass == referencesAttributeEClass){  //self-reference in expression !
			String errorMessage = \"Self-reference in expression of attribute \" + containingAttributeEClass.getName() + \" detected. Self-references are not allowed!\";
			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));
		}

		if(containingRootClass != referencesRootClass){
			String errorMessage = \"The referenced element \" + this.reference + \" is contained by a different parent-element than the expression's parent-element. Cross-references are not supported.\";
			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));
		}

		if(this.reference instanceof qmm.NegatableElement && ((qmm.NegatableElement)this.reference).isNegated())diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"Reference to a negated element in \" + this + \" has been detected. References to negated elements are not allowed.\",new Object[] { this }));

}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	ref String_CalculateableElement[1] reference;
}

@information(type="String")
abstract class String_ExpressionOperator extends ExpressionOperator, String_Operator {
}

@information(type="String")
abstract class String_BitOperator extends String_ExpressionOperator, BitOperator {
	val String_ExpressionOperator[2..*] connects;
}

@information(type="String")
class String_And_BitOperator extends String_BitOperator {

	@GenModel(body="return \"&&\";")
	op String[1] getLiteral();
}

@information(type="String")
class String_Or_BitOperator extends String_BitOperator {

	@GenModel(body="return \"||\";")
	op String[1] getLiteral();
}

@information(type="String")
abstract class String_Original_FunctionalOperator extends String_FunctionalOperator {
}

class AttributeNameMapping_roleAttributeName_AttrEClass extends String_AttributeEClass {
}

class AttributeNameMapping_systemUnitAttributeName_AttrEClass extends String_AttributeEClass {
}

class Attribute_defaultValue_AttrEClass extends String_AttributeEClass {
}

class Attribute_value_AttrEClass extends String_AttributeEClass {
}

abstract class AttributeDataType_Calculateable extends Calculateable {
}

abstract class AttributeDataType_CalculateableElement extends AttributeDataType_Calculateable, CalculateableElement {
}

abstract class AttributeDataType_AttributeEClass extends RegularAttributeEClass, AttributeDataType_CalculateableElement {

	@GenModel(body="if(diagnostic!=null){
    if(this.operator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateCheckExpression(this.operator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val AttributeDataType_ExpressionOperator operator;
}

abstract class AttributeDataType_Operator extends Operator {
}

@information(type="AttributeDataType")
abstract class AttributeDataType_Type extends Type {
}

abstract class AttributeDataType_FunctionalType extends AttributeDataType_Type, FunctionalType {
	val AttributeDataType_FunctionalOperator operator;
}

class AttributeDataType_CalculateableParameter extends AttributeDataType_Type, CalculateableParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class AttributeDataType_FunctionalParameter extends AttributeDataType_Type, FunctionalParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

abstract class AttributeDataType_Argument extends FunctionalArgument, AttributeDataType_FunctionalType {
}

class AttributeDataType_PrimitiveArgument extends AttributeDataType_Argument, PrimitiveArgument {
	attr AttributeDataType[1] value;
}

@information(functionalType="AttributeDataType")
abstract class AttributeDataType_EvaluationOperation_Argument extends EvaluationOperation_Argument, AttributeDataType_Argument {
}

@information(functionalType="AttributeDataType")
class AttributeDataType_CalculateableElementReferenceArgument extends CalculateableElement_ReferenceArgument, AttributeDataType_FunctionalType {

	@GenModel(body="qmm.RootClass containingRootClass = null;
qmm.RootClass referencesRootClass = null;
qmm.AttributeEClass containingAttributeEClass = null;
qmm.AttributeEClass referencesAttributeEClass = null;
if(this.eContainer() != null && this.reference != null){
		org.eclipse.emf.ecore.EObject eContainer = this.eContainer();

		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){
			if(eContainer instanceof qmm.AttributeEClass){
				containingAttributeEClass = (qmm.AttributeEClass)eContainer;
			}
			eContainer = eContainer.eContainer();
		}
		containingRootClass = (qmm.RootClass)eContainer;

		eContainer = this.reference.eContainer();
		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){
			eContainer = eContainer.eContainer();
		}

		referencesRootClass = (qmm.RootClass)eContainer;
		if(this.reference instanceof qmm.AttributeEClass) referencesAttributeEClass = (qmm.AttributeEClass)this.reference;

		if(containingAttributeEClass != null && referencesAttributeEClass != null && containingAttributeEClass == referencesAttributeEClass){  //self-reference in expression !
			String errorMessage = \"Self-reference in expression of attribute \" + containingAttributeEClass.getName() + \" detected. Self-references are not allowed!\";
			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));
		}

		if(containingRootClass != referencesRootClass){
			String errorMessage = \"The referenced element \" + this.reference + \" is contained by a different parent-element than the expression's parent-element. Cross-references are not supported.\";
			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));
		}

		if(this.reference instanceof qmm.NegatableElement && ((qmm.NegatableElement)this.reference).isNegated())diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"Reference to a negated element in \" + this + \" has been detected. References to negated elements are not allowed.\",new Object[] { this }));

}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	ref AttributeDataType_CalculateableElement[1] reference;
}

@information(type="AttributeDataType")
abstract class AttributeDataType_ExpressionOperator extends ExpressionOperator, AttributeDataType_Operator {
}

@information(type="AttributeDataType")
abstract class AttributeDataType_BitOperator extends AttributeDataType_ExpressionOperator, BitOperator {
	val AttributeDataType_ExpressionOperator[2..*] connects;
}

@information(type="AttributeDataType")
class AttributeDataType_And_BitOperator extends AttributeDataType_BitOperator {

	@GenModel(body="return \"&&\";")
	op String[1] getLiteral();
}

@information(type="AttributeDataType")
class AttributeDataType_Or_BitOperator extends AttributeDataType_BitOperator {

	@GenModel(body="return \"||\";")
	op String[1] getLiteral();
}

@information(type="AttributeDataType")
abstract class AttributeDataType_FunctionalOperator extends AttributeDataType_ExpressionOperator, FunctionalOperator {
}

class Attribute_attributeDataType_AttrEClass extends AttributeDataType_AttributeEClass {
}

class Attribute_refAttributeType_AttrEClass extends String_AttributeEClass {
}

class Attribute_unit_AttrEClass extends String_AttributeEClass {
}

class AttributeValueRequirement_name_AttrEClass extends String_AttributeEClass {
}

abstract class ChangeMode_Calculateable extends Calculateable {
}

abstract class ChangeMode_CalculateableElement extends ChangeMode_Calculateable, CalculateableElement {
}

abstract class ChangeMode_Operator extends Operator {
}

class ChangeMode_EnumerationOperator extends EnumerationOperator, ChangeMode_Operator {
	attr ChangeMode[1] argument;
	val ChangeMode_EnumerationOperator or;
}

abstract class ChangeMode_AttributeEClass extends EnumerationAttributeEClass {
	val ChangeMode_EnumerationOperator operator;
}

class CAEXBasicObject_changeMode_AttrEClass extends ChangeMode_AttributeEClass {
}

class CAEXFile_superiorStandardVersion_AttrEClass extends String_AttributeEClass {
}

class CAEXFile_fileName_AttrEClass extends String_AttributeEClass {
}

class CAEXFile_schemaVersion_AttrEClass extends String_AttributeEClass {
}

class CAEXObject_iD_AttrEClass extends String_AttributeEClass {
}

class CAEXObject_name_AttrEClass extends String_AttributeEClass {
}

abstract class EFeatureMapEntry_Calculateable extends Calculateable {
}

abstract class EFeatureMapEntry_CalculateableElement extends EFeatureMapEntry_Calculateable, CalculateableElement {
}

abstract class EFeatureMapEntry_AttributeEClass extends RegularAttributeEClass, EFeatureMapEntry_CalculateableElement {

	@GenModel(body="if(diagnostic!=null){
    if(this.operator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateCheckExpression(this.operator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val EFeatureMapEntry_ExpressionOperator operator;
}

abstract class EFeatureMapEntry_Operator extends Operator {
}

@information(type="EFeatureMapEntry")
abstract class EFeatureMapEntry_Type extends Type {
}

abstract class EFeatureMapEntry_FunctionalType extends EFeatureMapEntry_Type, FunctionalType {
	val EFeatureMapEntry_FunctionalOperator operator;
}

class EFeatureMapEntry_CalculateableParameter extends EFeatureMapEntry_Type, CalculateableParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class EFeatureMapEntry_FunctionalParameter extends EFeatureMapEntry_Type, FunctionalParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

abstract class EFeatureMapEntry_Argument extends FunctionalArgument, EFeatureMapEntry_FunctionalType {
}

class EFeatureMapEntry_PrimitiveArgument extends EFeatureMapEntry_Argument, PrimitiveArgument {
	attr ecore.EFeatureMapEntry[1] value;
}

@information(functionalType="EFeatureMapEntry")
abstract class EFeatureMapEntry_EvaluationOperation_Argument extends EvaluationOperation_Argument, EFeatureMapEntry_Argument {
}

@information(functionalType="EFeatureMapEntry")
class EFeatureMapEntry_CalculateableElementReferenceArgument extends CalculateableElement_ReferenceArgument, EFeatureMapEntry_FunctionalType {

	@GenModel(body="qmm.RootClass containingRootClass = null;
qmm.RootClass referencesRootClass = null;
qmm.AttributeEClass containingAttributeEClass = null;
qmm.AttributeEClass referencesAttributeEClass = null;
if(this.eContainer() != null && this.reference != null){
		org.eclipse.emf.ecore.EObject eContainer = this.eContainer();

		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){
			if(eContainer instanceof qmm.AttributeEClass){
				containingAttributeEClass = (qmm.AttributeEClass)eContainer;
			}
			eContainer = eContainer.eContainer();
		}
		containingRootClass = (qmm.RootClass)eContainer;

		eContainer = this.reference.eContainer();
		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){
			eContainer = eContainer.eContainer();
		}

		referencesRootClass = (qmm.RootClass)eContainer;
		if(this.reference instanceof qmm.AttributeEClass) referencesAttributeEClass = (qmm.AttributeEClass)this.reference;

		if(containingAttributeEClass != null && referencesAttributeEClass != null && containingAttributeEClass == referencesAttributeEClass){  //self-reference in expression !
			String errorMessage = \"Self-reference in expression of attribute \" + containingAttributeEClass.getName() + \" detected. Self-references are not allowed!\";
			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));
		}

		if(containingRootClass != referencesRootClass){
			String errorMessage = \"The referenced element \" + this.reference + \" is contained by a different parent-element than the expression's parent-element. Cross-references are not supported.\";
			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));
		}

		if(this.reference instanceof qmm.NegatableElement && ((qmm.NegatableElement)this.reference).isNegated())diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"Reference to a negated element in \" + this + \" has been detected. References to negated elements are not allowed.\",new Object[] { this }));

}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	ref EFeatureMapEntry_CalculateableElement[1] reference;
}

@information(type="EFeatureMapEntry")
abstract class EFeatureMapEntry_ExpressionOperator extends ExpressionOperator, EFeatureMapEntry_Operator {
}

@information(type="EFeatureMapEntry")
abstract class EFeatureMapEntry_BitOperator extends EFeatureMapEntry_ExpressionOperator, BitOperator {
	val EFeatureMapEntry_ExpressionOperator[2..*] connects;
}

@information(type="EFeatureMapEntry")
class EFeatureMapEntry_And_BitOperator extends EFeatureMapEntry_BitOperator {

	@GenModel(body="return \"&&\";")
	op String[1] getLiteral();
}

@information(type="EFeatureMapEntry")
class EFeatureMapEntry_Or_BitOperator extends EFeatureMapEntry_BitOperator {

	@GenModel(body="return \"||\";")
	op String[1] getLiteral();
}

@information(type="EFeatureMapEntry")
abstract class EFeatureMapEntry_FunctionalOperator extends EFeatureMapEntry_ExpressionOperator, FunctionalOperator {
}

class DocumentRoot_mixed_AttrEClass extends EFeatureMapEntry_AttributeEClass {
}

class ExternalReferenceType_alias_AttrEClass extends String_AttributeEClass {
}

class ExternalReferenceType_path_AttrEClass extends String_AttributeEClass {
}

class InterfaceClass_refBaseClassPath_AttrEClass extends String_AttributeEClass {
}

class InterfaceIDMapping_roleInterfaceID_AttrEClass extends String_AttributeEClass {
}

class InterfaceIDMapping_systemUnitInterfaceID_AttrEClass extends String_AttributeEClass {
}

class InternalElement_refBaseSystemUnitPath_AttrEClass extends String_AttributeEClass {
}

class InternalLink_refPartnerSideA_AttrEClass extends String_AttributeEClass {
}

class InternalLink_refPartnerSideB_AttrEClass extends String_AttributeEClass {
}

class NominalScaledType_requiredValue_AttrEClass extends String_AttributeEClass {
}

class OrdinalScaledType_requiredMaxValue_AttrEClass extends String_AttributeEClass {
}

class OrdinalScaledType_requiredValue_AttrEClass extends String_AttributeEClass {
}

class OrdinalScaledType_requiredMinValue_AttrEClass extends String_AttributeEClass {
}

class RefSemantic_correspondingAttributePath_AttrEClass extends String_AttributeEClass {
}

class RoleClass_refBaseClassPath_AttrEClass extends String_AttributeEClass {
}

abstract class DateTime_Calculateable extends Calculateable {
}

abstract class DateTime_CalculateableElement extends DateTime_Calculateable, CalculateableElement {
}

abstract class DateTime_AttributeEClass extends RegularAttributeEClass, DateTime_CalculateableElement {

	@GenModel(body="if(diagnostic!=null){
    if(this.operator != null){
    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateCheckExpression(this.operator);
    	for(int i=0; i<diagnosticList.size(); i++){
    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));
    	}
    }
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	val DateTime_ExpressionOperator operator;
}

abstract class DateTime_Operator extends Operator {
}

@information(type="DateTime")
abstract class DateTime_Type extends Type {
}

abstract class DateTime_FunctionalType extends DateTime_Type, FunctionalType {
	val DateTime_FunctionalOperator operator;
}

class DateTime_CalculateableParameter extends DateTime_Type, CalculateableParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class DateTime_FunctionalParameter extends DateTime_Type, FunctionalParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

abstract class DateTime_Argument extends FunctionalArgument, DateTime_FunctionalType {
}

class DateTime_PrimitiveArgument extends DateTime_Argument, PrimitiveArgument {
	attr type.DateTime[1] value;
}

@information(functionalType="DateTime")
abstract class DateTime_EvaluationOperation_Argument extends EvaluationOperation_Argument, DateTime_Argument {
}

@information(functionalType="DateTime")
class DateTime_CalculateableElementReferenceArgument extends CalculateableElement_ReferenceArgument, DateTime_FunctionalType {

	@GenModel(body="qmm.RootClass containingRootClass = null;
qmm.RootClass referencesRootClass = null;
qmm.AttributeEClass containingAttributeEClass = null;
qmm.AttributeEClass referencesAttributeEClass = null;
if(this.eContainer() != null && this.reference != null){
		org.eclipse.emf.ecore.EObject eContainer = this.eContainer();

		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){
			if(eContainer instanceof qmm.AttributeEClass){
				containingAttributeEClass = (qmm.AttributeEClass)eContainer;
			}
			eContainer = eContainer.eContainer();
		}
		containingRootClass = (qmm.RootClass)eContainer;

		eContainer = this.reference.eContainer();
		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){
			eContainer = eContainer.eContainer();
		}

		referencesRootClass = (qmm.RootClass)eContainer;
		if(this.reference instanceof qmm.AttributeEClass) referencesAttributeEClass = (qmm.AttributeEClass)this.reference;

		if(containingAttributeEClass != null && referencesAttributeEClass != null && containingAttributeEClass == referencesAttributeEClass){  //self-reference in expression !
			String errorMessage = \"Self-reference in expression of attribute \" + containingAttributeEClass.getName() + \" detected. Self-references are not allowed!\";
			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));
		}

		if(containingRootClass != referencesRootClass){
			String errorMessage = \"The referenced element \" + this.reference + \" is contained by a different parent-element than the expression's parent-element. Cross-references are not supported.\";
			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));
		}

		if(this.reference instanceof qmm.NegatableElement && ((qmm.NegatableElement)this.reference).isNegated())diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"Reference to a negated element in \" + this + \" has been detected. References to negated elements are not allowed.\",new Object[] { this }));

}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
	ref DateTime_CalculateableElement[1] reference;
}

@information(type="DateTime")
abstract class DateTime_ExpressionOperator extends ExpressionOperator, DateTime_Operator {
}

@information(type="DateTime")
abstract class DateTime_BitOperator extends DateTime_ExpressionOperator, BitOperator {
	val DateTime_ExpressionOperator[2..*] connects;
}

@information(type="DateTime")
class DateTime_And_BitOperator extends DateTime_BitOperator {

	@GenModel(body="return \"&&\";")
	op String[1] getLiteral();
}

@information(type="DateTime")
class DateTime_Or_BitOperator extends DateTime_BitOperator {

	@GenModel(body="return \"||\";")
	op String[1] getLiteral();
}

@information(type="DateTime")
abstract class DateTime_FunctionalOperator extends DateTime_ExpressionOperator, FunctionalOperator {
}

class SourceDocumentInformation_lastWritingDateTime_AttrEClass extends DateTime_AttributeEClass {
}

class SourceDocumentInformation_originID_AttrEClass extends String_AttributeEClass {
}

class SourceDocumentInformation_originName_AttrEClass extends String_AttributeEClass {
}

class SourceDocumentInformation_originProjectID_AttrEClass extends String_AttributeEClass {
}

class SourceDocumentInformation_originProjectTitle_AttrEClass extends String_AttributeEClass {
}

class SourceDocumentInformation_originRelease_AttrEClass extends String_AttributeEClass {
}

class SourceDocumentInformation_originVendor_AttrEClass extends String_AttributeEClass {
}

class SourceDocumentInformation_originVendorURL_AttrEClass extends String_AttributeEClass {
}

class SourceDocumentInformation_originVersion_AttrEClass extends String_AttributeEClass {
}

class SupportedRoleClass_refRoleClassPath_AttrEClass extends String_AttributeEClass {
}

class SystemUnitClass_refBaseClassPath_AttrEClass extends String_AttributeEClass {
}

class UnknownType_requirements_AttrEClass extends String_AttributeEClass {
}

class Copyright_value_AttrEClass extends String_AttributeEClass {
}

class Copyright_changeMode_AttrEClass extends ChangeMode_AttributeEClass {
}

class Description_value_AttrEClass extends String_AttributeEClass {
}

class Description_changeMode_AttrEClass extends ChangeMode_AttributeEClass {
}

class Revision_revisionDate_AttrEClass extends DateTime_AttributeEClass {
}

class Revision_oldVersion_AttrEClass extends String_AttributeEClass {
}

class Revision_newVersion_AttrEClass extends String_AttributeEClass {
}

class Revision_authorName_AttrEClass extends String_AttributeEClass {
}

class Revision_comment_AttrEClass extends String_AttributeEClass {
}

class Version_value_AttrEClass extends String_AttributeEClass {
}

class Version_changeMode_AttrEClass extends ChangeMode_AttributeEClass {
}

class Element_name_AttrEClass extends String_AttributeEClass {
}

class Element_value_AttrEClass extends String_AttributeEClass {
}

class GenericElement_elementFeatureMap_AttrEClass extends EFeatureMapEntry_AttributeEClass {
}

class GenericElement_attributeFeatureMap_AttrEClass extends EFeatureMapEntry_AttributeEClass {
}

class Attribute_OrGroup extends OrGroup {
	val Attribute[*] containment;
}

class RefSemantic_OrGroup extends OrGroup {
	val RefSemantic[*] containment;
}

class AttributeValueRequirement_OrGroup extends OrGroup {
	val AttributeValueRequirement[*] containment;
}

class OrdinalScaledType_OrGroup extends OrGroup {
	val OrdinalScaledType[*] containment;
}

class NominalScaledType_OrGroup extends OrGroup {
	val NominalScaledType[*] containment;
}

class UnknownType_OrGroup extends OrGroup {
	val UnknownType[*] containment;
}

class Description_OrGroup extends OrGroup {
	val Description[*] containment;
}

class Version_OrGroup extends OrGroup {
	val Version[*] containment;
}

class Revision_OrGroup extends OrGroup {
	val Revision[*] containment;
}

class Copyright_OrGroup extends OrGroup {
	val Copyright[*] containment;
}

class AdditionalInformation_OrGroup extends OrGroup {
	val AdditionalInformation[*] containment;
}

class SourceDocumentInformation_OrGroup extends OrGroup {
	val SourceDocumentInformation[*] containment;
}

class ExternalReferenceType_OrGroup extends OrGroup {
	val ExternalReferenceType[*] containment;
}

class InstanceHierarchy_OrGroup extends OrGroup {
	val InstanceHierarchy[*] containment;
}

class InterfaceClassLib_OrGroup extends OrGroup {
	val InterfaceClassLib[*] containment;
}

class RoleClassLib_OrGroup extends OrGroup {
	val RoleClassLib[*] containment;
}

class SystemUnitClassLib_OrGroup extends OrGroup {
	val SystemUnitClassLib[*] containment;
}

class AttributeLib_OrGroup extends OrGroup {
	val AttributeLib[*] containment;
}

class CAEXFile_OrGroup extends OrGroup {
	val CAEXFile[*] containment;
}

class InterfaceClass_OrGroup extends OrGroup {
	val InterfaceClass[*] containment;
}

class InternalElement_OrGroup extends OrGroup {
	val InternalElement[*] containment;
}

class ExternalInterface_OrGroup extends OrGroup {
	val ExternalInterface[*] containment;
}

class RoleRequirements_OrGroup extends OrGroup {
	val RoleRequirements[*] containment;
}

class SystemUnitClass_OrGroup extends OrGroup {
	val SystemUnitClass[*] containment;
}

class AttributeNameMapping_OrGroup extends OrGroup {
	val AttributeNameMapping[*] containment;
}

class InterfaceIDMapping_OrGroup extends OrGroup {
	val InterfaceIDMapping[*] containment;
}

class RoleClass_OrGroup extends OrGroup {
	val RoleClass[*] containment;
}

class Mapping_OrGroup extends OrGroup {
	val Mapping[*] containment;
}

class SupportedRoleClass_OrGroup extends OrGroup {
	val SupportedRoleClass[*] containment;
}

class InternalLink_OrGroup extends OrGroup {
	val InternalLink[*] containment;
}

class GenericElement_OrGroup extends OrGroup {
	val GenericElement[*] containment;
}

class GenericAttribute_OrGroup extends OrGroup {
	val GenericAttribute[*] containment;
}

abstract class Object_Operator extends Operator {
}

@information(type="Object")
abstract class Object_Type extends Type {
}

abstract class Object_FunctionalType extends Object_Type, FunctionalType {
	val Object_FunctionalOperator operator;
}

class Object_CalculateableParameter extends Object_Type, CalculateableParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class Object_FunctionalParameter extends Object_Type, FunctionalParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

abstract class Object_Calculateable extends Calculateable {
}

abstract class Object_CalculateableElement extends Object_Calculateable, CalculateableElement {
}

datatype Object : java.lang.Object;

abstract class Object_Argument extends FunctionalArgument, Object_FunctionalType {
}

class Object_PrimitiveArgument extends Object_Argument, PrimitiveArgument {
	attr Object[1] value;
}

@information(functionalType="Object")
abstract class Object_EvaluationOperation_Argument extends EvaluationOperation_Argument, Object_Argument {
}

@information(type="Object")
abstract class Object_ExpressionOperator extends ExpressionOperator, Object_Operator {
}

@information(type="Object")
abstract class Object_BitOperator extends Object_ExpressionOperator, BitOperator {
	val Object_ExpressionOperator[2..*] connects;
}

@information(type="Object")
class Object_And_BitOperator extends Object_BitOperator {

	@GenModel(body="return \"&&\";")
	op String[1] getLiteral();
}

@information(type="Object")
class Object_Or_BitOperator extends Object_BitOperator {

	@GenModel(body="return \"||\";")
	op String[1] getLiteral();
}

@information(type="Object")
abstract class Object_FunctionalOperator extends Object_ExpressionOperator, FunctionalOperator {
}

abstract class Boolean_Operator extends Operator {
}

@information(type="Boolean")
abstract class Boolean_Type extends Type, Object_Type {
}

abstract class Boolean_FunctionalType extends Boolean_Type, FunctionalType, NegatableElement {
	val Boolean_FunctionalOperator operator;
}

class Boolean_CalculateableParameter extends Boolean_Type, CalculateableParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class Boolean_FunctionalParameter extends Boolean_Type, FunctionalParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

abstract class Boolean_Calculateable extends Calculateable {
}

abstract class Boolean_CalculateableElement extends Boolean_Calculateable, CalculateableElement {
}

datatype Boolean : java.lang.Boolean;

abstract class Boolean_Argument extends FunctionalArgument, Boolean_FunctionalType {
}

class Boolean_PrimitiveArgument extends Boolean_Argument, PrimitiveArgument {
	attr Boolean[1] value;
}

@information(functionalType="Boolean")
abstract class Boolean_EvaluationOperation_Argument extends EvaluationOperation_Argument, Boolean_Argument {
}

@information(type="Boolean")
abstract class Boolean_ExpressionOperator extends ExpressionOperator, Boolean_Operator {
}

@information(type="Boolean")
abstract class Boolean_BitOperator extends Boolean_ExpressionOperator, BitOperator {
	val Boolean_ExpressionOperator[2..*] connects;
}

@information(type="Boolean")
class Boolean_And_BitOperator extends Boolean_BitOperator {

	@GenModel(body="return \"&&\";")
	op String[1] getLiteral();
}

@information(type="Boolean")
class Boolean_Or_BitOperator extends Boolean_BitOperator {

	@GenModel(body="return \"||\";")
	op String[1] getLiteral();
}

@information(type="Boolean")
abstract class Boolean_Original_FunctionalOperator extends Boolean_FunctionalOperator {
}

@information(name="equals", literal=".equals", functionalOperatorType="Object", functionalType="Boolean_FunctionalType")
class equals_FunctionalOperator extends Object_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".equals\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(obj);
return parameterList;")
	op EEList[1] getAllParameters();
	val Object_FunctionalParameter[1] obj;
}

@information(name="toString", literal=".toString", functionalOperatorType="Object", functionalType="String_FunctionalType")
class toString_FunctionalOperator extends Object_FunctionalOperator, String_FunctionalType {

	@GenModel(body="return \".toString\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
return parameterList;")
	op EEList[1] getAllParameters();
}

abstract class CharSequence_Operator extends Operator {
}

@information(type="CharSequence")
abstract class CharSequence_Type extends Type, Object_Type {
}

abstract class CharSequence_FunctionalType extends CharSequence_Type, FunctionalType {
	val CharSequence_FunctionalOperator operator;
}

class CharSequence_CalculateableParameter extends CharSequence_Type, CalculateableParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class CharSequence_FunctionalParameter extends CharSequence_Type, FunctionalParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

abstract class CharSequence_Calculateable extends Calculateable {
}

abstract class CharSequence_CalculateableElement extends CharSequence_Calculateable, CalculateableElement {
}

datatype CharSequence : java.lang.CharSequence;

abstract class CharSequence_Argument extends FunctionalArgument, CharSequence_FunctionalType {
}

class CharSequence_PrimitiveArgument extends CharSequence_Argument, PrimitiveArgument {
	attr CharSequence[1] value;
}

@information(functionalType="CharSequence")
abstract class CharSequence_EvaluationOperation_Argument extends EvaluationOperation_Argument, CharSequence_Argument {
}

@information(type="CharSequence")
abstract class CharSequence_ExpressionOperator extends ExpressionOperator, CharSequence_Operator {
}

@information(type="CharSequence")
abstract class CharSequence_BitOperator extends CharSequence_ExpressionOperator, BitOperator {
	val CharSequence_ExpressionOperator[2..*] connects;
}

@information(type="CharSequence")
class CharSequence_And_BitOperator extends CharSequence_BitOperator {

	@GenModel(body="return \"&&\";")
	op String[1] getLiteral();
}

@information(type="CharSequence")
class CharSequence_Or_BitOperator extends CharSequence_BitOperator {

	@GenModel(body="return \"||\";")
	op String[1] getLiteral();
}

@information(type="CharSequence")
abstract class CharSequence_Original_FunctionalOperator extends CharSequence_FunctionalOperator {
}

abstract class Integer_Operator extends Operator {
}

@information(type="Integer")
abstract class Integer_Type extends Type, Number_Type {
}

abstract class Integer_FunctionalType extends Integer_Type, FunctionalType {
	val Integer_FunctionalOperator operator;
}

class Integer_CalculateableParameter extends Integer_Type, CalculateableParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class Integer_FunctionalParameter extends Integer_Type, FunctionalParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

datatype Integer : java.lang.Integer;

abstract class Integer_Argument extends FunctionalArgument, Integer_FunctionalType {
}

class Integer_PrimitiveArgument extends Integer_Argument, PrimitiveArgument {
	attr Integer[1] value;
}

@information(functionalType="Integer")
abstract class Integer_EvaluationOperation_Argument extends EvaluationOperation_Argument, Integer_Argument {
}

@information(type="Integer")
abstract class Integer_ExpressionOperator extends ExpressionOperator, Integer_Operator {
}

@information(type="Integer")
abstract class Integer_BitOperator extends Integer_ExpressionOperator, BitOperator {
	val Integer_ExpressionOperator[2..*] connects;
}

@information(type="Integer")
class Integer_And_BitOperator extends Integer_BitOperator {

	@GenModel(body="return \"&&\";")
	op String[1] getLiteral();
}

@information(type="Integer")
class Integer_Or_BitOperator extends Integer_BitOperator {

	@GenModel(body="return \"||\";")
	op String[1] getLiteral();
}

@information(type="Integer")
abstract class Integer_Original_FunctionalOperator extends Integer_FunctionalOperator {
}

@information(name="length", literal=".length", functionalOperatorType="CharSequence", functionalType="Integer_FunctionalType")
class length_FunctionalOperator extends CharSequence_Original_FunctionalOperator, Integer_FunctionalType {

	@GenModel(body="return \".length\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
return parameterList;")
	op EEList[1] getAllParameters();
}

abstract class Character_Operator extends Operator {
}

@information(type="Character")
abstract class Character_Type extends Type, Object_Type {
}

abstract class Character_FunctionalType extends Character_Type, FunctionalType {
	val Character_FunctionalOperator operator;
}

class Character_CalculateableParameter extends Character_Type, CalculateableParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class Character_FunctionalParameter extends Character_Type, FunctionalParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

abstract class Character_Calculateable extends Calculateable {
}

abstract class Character_CalculateableElement extends Character_Calculateable, CalculateableElement {
}

datatype Character : java.lang.Character;

abstract class Character_Argument extends FunctionalArgument, Character_FunctionalType {
}

class Character_PrimitiveArgument extends Character_Argument, PrimitiveArgument {
	attr Character[1] value;
}

@information(functionalType="Character")
abstract class Character_EvaluationOperation_Argument extends EvaluationOperation_Argument, Character_Argument {
}

@information(type="Character")
abstract class Character_ExpressionOperator extends ExpressionOperator, Character_Operator {
}

@information(type="Character")
abstract class Character_BitOperator extends Character_ExpressionOperator, BitOperator {
	val Character_ExpressionOperator[2..*] connects;
}

@information(type="Character")
class Character_And_BitOperator extends Character_BitOperator {

	@GenModel(body="return \"&&\";")
	op String[1] getLiteral();
}

@information(type="Character")
class Character_Or_BitOperator extends Character_BitOperator {

	@GenModel(body="return \"||\";")
	op String[1] getLiteral();
}

@information(type="Character")
abstract class Character_Original_FunctionalOperator extends Character_FunctionalOperator {
}

@information(name="charAt", literal=".charAt", functionalOperatorType="Character", functionalType="Character_FunctionalType")
class charAt_FunctionalOperator extends Character_Original_FunctionalOperator, Character_FunctionalType {

	@GenModel(body="return \".charAt\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Integer_FunctionalParameter[1] i;
}

@information(name="contains", literal=".contains", functionalOperatorType="String", functionalType="Boolean_FunctionalType")
class contains_FunctionalOperator extends String_Original_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".contains\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(charSequence);
return parameterList;")
	op EEList[1] getAllParameters();
	val CharSequence_FunctionalParameter[1] charSequence;
}

@information(name="substring", literal=".substring", functionalOperatorType="String", functionalType="String_FunctionalType")
class substring_FunctionalOperator extends String_Original_FunctionalOperator, String_FunctionalType {

	@GenModel(body="return \".substring\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(startIndex);
parameterList.add(endIndex);
return parameterList;")
	op EEList[1] getAllParameters();
	val Integer_FunctionalParameter[1] startIndex;
	val Integer_FunctionalParameter[1] endIndex;
}

@information(name="concat", literal=".concat", functionalOperatorType="String", functionalType="String_FunctionalType")
class concat_FunctionalOperator extends String_Original_FunctionalOperator, String_FunctionalType {

	@GenModel(body="return \".concat\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(str);
return parameterList;")
	op EEList[1] getAllParameters();
	val String_FunctionalParameter[1] str;
}

@information(name="endsWith", literal=".endsWith", functionalOperatorType="String", functionalType="Boolean_FunctionalType")
class endsWith_FunctionalOperator extends String_Original_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".endsWith\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(suffix);
return parameterList;")
	op EEList[1] getAllParameters();
	val String_FunctionalParameter[1] suffix;
}

@information(name="equalsIgnoreCase", literal=".equalsIgnoreCase", functionalOperatorType="String", functionalType="Boolean_FunctionalType")
class equalsIgnoreCase_FunctionalOperator extends String_Original_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".equalsIgnoreCase\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(anotherString);
return parameterList;")
	op EEList[1] getAllParameters();
	val String_FunctionalParameter[1] anotherString;
}

@information(name="indexOfString", literal=".indexOf", functionalOperatorType="String", functionalType="Integer_FunctionalType")
class indexOfString_FunctionalOperator extends String_Original_FunctionalOperator, Integer_FunctionalType {

	@GenModel(body="return \".indexOf\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(str);
return parameterList;")
	op EEList[1] getAllParameters();
	val String_FunctionalParameter[1] str;
}

@information(name="isEmpty", literal=".isEmpty", functionalOperatorType="String", functionalType="Boolean_FunctionalType")
class isEmpty_FunctionalOperator extends String_Original_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".isEmpty\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
return parameterList;")
	op EEList[1] getAllParameters();
}

abstract class Number_Operator extends Operator {
}

@information(type="Number")
abstract class Number_Type extends Type, Object_Type {
}

abstract class Number_FunctionalType extends Number_Type, FunctionalType {
	val Number_FunctionalOperator operator;
}

class Number_CalculateableParameter extends Number_Type, CalculateableParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class Number_FunctionalParameter extends Number_Type, FunctionalParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

abstract class Number_Calculateable extends Calculateable {
}

abstract class Number_CalculateableElement extends Number_Calculateable, CalculateableElement {
}

datatype Number : java.lang.Number;

abstract class Number_Argument extends FunctionalArgument, Number_FunctionalType {
}

class Number_PrimitiveArgument extends Number_Argument, PrimitiveArgument {
	attr Number[1] value;
}

@information(functionalType="Number")
abstract class Number_EvaluationOperation_Argument extends EvaluationOperation_Argument, Number_Argument {
}

@information(type="Number")
abstract class Number_ExpressionOperator extends ExpressionOperator, Number_Operator {
}

@information(type="Number")
abstract class Number_BitOperator extends Number_ExpressionOperator, BitOperator {
	val Number_ExpressionOperator[2..*] connects;
}

@information(type="Number")
class Number_And_BitOperator extends Number_BitOperator {

	@GenModel(body="return \"&&\";")
	op String[1] getLiteral();
}

@information(type="Number")
class Number_Or_BitOperator extends Number_BitOperator {

	@GenModel(body="return \"||\";")
	op String[1] getLiteral();
}

@information(type="Number")
abstract class Number_Original_FunctionalOperator extends Number_FunctionalOperator {
}

@information(name="greaterThan", literal=">", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class greaterThan_FunctionalOperator extends Number_Original_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \">\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="greaterEquals", literal=">=", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class greaterEquals_FunctionalOperator extends Number_Original_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \">=\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="smallerThan", literal="<", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class smallerThan_FunctionalOperator extends Number_Original_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \"<\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="smallerEquals", literal="<=", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class smallerEquals_FunctionalOperator extends Number_Original_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \"<=\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="parseBoolean", literal=".parseBoolean", functionalOperatorType="Boolean", functionalType="Boolean_FunctionalType")
class parseBoolean_FunctionalOperator extends Boolean_Original_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".parseBoolean\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(s);
return parameterList;")
	op EEList[1] getAllParameters();
	val String_FunctionalParameter[1] s;
}

@information(name="compareTo", literal=".compareTo", functionalOperatorType="Boolean", functionalType="Integer_FunctionalType")
class compareTo_FunctionalOperator extends Boolean_Original_FunctionalOperator, Integer_FunctionalType {

	@GenModel(body="return \".compareTo\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(b);
return parameterList;")
	op EEList[1] getAllParameters();
	val Boolean_FunctionalParameter[1] b;
}

@information(name="equals", literal=".equals", functionalOperatorType="Object", functionalType="Boolean_FunctionalType")
class Object_Number_equals_FunctionalOperator extends InheritedFrom_Object_to_Number_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".equals\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(obj);
return parameterList;")
	op EEList[1] getAllParameters();
	val Object_FunctionalParameter[1] obj;
}

@information(name="toString", literal=".toString", functionalOperatorType="Object", functionalType="String_FunctionalType")
class Object_Number_toString_FunctionalOperator extends InheritedFrom_Object_to_Number_FunctionalOperator, String_FunctionalType {

	@GenModel(body="return \".toString\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
return parameterList;")
	op EEList[1] getAllParameters();
}

abstract class Number_FunctionalOperator extends Operator, ExpressionOperator, Number_Operator, Number_ExpressionOperator, TypedElement, FunctionalOperator {
}

@information(type="Object")
abstract class InheritedFrom_Object_to_Number_FunctionalOperator extends Number_FunctionalOperator {
}

@information(name="greaterThan", literal=">", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Integer_greaterThan_FunctionalOperator extends InheritedFrom_Number_to_Integer_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \">\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="greaterEquals", literal=">=", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Integer_greaterEquals_FunctionalOperator extends InheritedFrom_Number_to_Integer_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \">=\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="smallerThan", literal="<", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Integer_smallerThan_FunctionalOperator extends InheritedFrom_Number_to_Integer_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \"<\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="smallerEquals", literal="<=", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Integer_smallerEquals_FunctionalOperator extends InheritedFrom_Number_to_Integer_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \"<=\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="equals", literal=".equals", functionalOperatorType="Object", functionalType="Boolean_FunctionalType")
class Number_Integer_Object_Number_equals_FunctionalOperator extends InheritedFrom_Number_to_Integer_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".equals\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(obj);
return parameterList;")
	op EEList[1] getAllParameters();
	val Object_FunctionalParameter[1] obj;
}

@information(name="toString", literal=".toString", functionalOperatorType="Object", functionalType="String_FunctionalType")
class Number_Integer_Object_Number_toString_FunctionalOperator extends InheritedFrom_Number_to_Integer_FunctionalOperator, String_FunctionalType {

	@GenModel(body="return \".toString\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
return parameterList;")
	op EEList[1] getAllParameters();
}

abstract class Integer_FunctionalOperator extends Operator, ExpressionOperator, Integer_Operator, Integer_ExpressionOperator, TypedElement, FunctionalOperator {
}

@information(type="Number")
abstract class InheritedFrom_Number_to_Integer_FunctionalOperator extends Integer_FunctionalOperator {
}

abstract class Long_Calculateable extends Calculateable {
}

abstract class Long_CalculateableElement extends Long_Calculateable, CalculateableElement {
}

abstract class Long_Operator extends Operator {
}

@information(type="Long")
abstract class Long_Type extends Type, Number_Type {
}

abstract class Long_FunctionalType extends Long_Type, FunctionalType {
	val Long_FunctionalOperator operator;
}

class Long_CalculateableParameter extends Long_Type, CalculateableParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class Long_FunctionalParameter extends Long_Type, FunctionalParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

datatype Long : java.lang.Long;

abstract class Long_Argument extends FunctionalArgument, Long_FunctionalType {
}

class Long_PrimitiveArgument extends Long_Argument, PrimitiveArgument {
	attr Long[1] value;
}

@information(functionalType="Long")
abstract class Long_EvaluationOperation_Argument extends EvaluationOperation_Argument, Long_Argument {
}

@information(type="Long")
abstract class Long_ExpressionOperator extends ExpressionOperator, Long_Operator {
}

@information(type="Long")
abstract class Long_BitOperator extends Long_ExpressionOperator, BitOperator {
	val Long_ExpressionOperator[2..*] connects;
}

@information(type="Long")
class Long_And_BitOperator extends Long_BitOperator {

	@GenModel(body="return \"&&\";")
	op String[1] getLiteral();
}

@information(type="Long")
class Long_Or_BitOperator extends Long_BitOperator {

	@GenModel(body="return \"||\";")
	op String[1] getLiteral();
}

@information(type="Long")
abstract class Long_Original_FunctionalOperator extends Long_FunctionalOperator {
}

@information(name="greaterThan", literal=">", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Long_greaterThan_FunctionalOperator extends InheritedFrom_Number_to_Long_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \">\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="greaterEquals", literal=">=", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Long_greaterEquals_FunctionalOperator extends InheritedFrom_Number_to_Long_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \">=\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="smallerThan", literal="<", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Long_smallerThan_FunctionalOperator extends InheritedFrom_Number_to_Long_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \"<\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="smallerEquals", literal="<=", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Long_smallerEquals_FunctionalOperator extends InheritedFrom_Number_to_Long_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \"<=\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="equals", literal=".equals", functionalOperatorType="Object", functionalType="Boolean_FunctionalType")
class Number_Long_Object_Number_equals_FunctionalOperator extends InheritedFrom_Number_to_Long_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".equals\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(obj);
return parameterList;")
	op EEList[1] getAllParameters();
	val Object_FunctionalParameter[1] obj;
}

@information(name="toString", literal=".toString", functionalOperatorType="Object", functionalType="String_FunctionalType")
class Number_Long_Object_Number_toString_FunctionalOperator extends InheritedFrom_Number_to_Long_FunctionalOperator, String_FunctionalType {

	@GenModel(body="return \".toString\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
return parameterList;")
	op EEList[1] getAllParameters();
}

abstract class Long_FunctionalOperator extends Operator, ExpressionOperator, Long_Operator, Long_ExpressionOperator, TypedElement, FunctionalOperator {
}

@information(type="Number")
abstract class InheritedFrom_Number_to_Long_FunctionalOperator extends Long_FunctionalOperator {
}

abstract class Double_Calculateable extends Calculateable {
}

abstract class Double_CalculateableElement extends Double_Calculateable, CalculateableElement {
}

abstract class Double_Operator extends Operator {
}

@information(type="Double")
abstract class Double_Type extends Type, Number_Type {
}

abstract class Double_FunctionalType extends Double_Type, FunctionalType {
	val Double_FunctionalOperator operator;
}

class Double_CalculateableParameter extends Double_Type, CalculateableParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class Double_FunctionalParameter extends Double_Type, FunctionalParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

datatype Double : java.lang.Double;

abstract class Double_Argument extends FunctionalArgument, Double_FunctionalType {
}

class Double_PrimitiveArgument extends Double_Argument, PrimitiveArgument {
	attr Double[1] value;
}

@information(functionalType="Double")
abstract class Double_EvaluationOperation_Argument extends EvaluationOperation_Argument, Double_Argument {
}

@information(type="Double")
abstract class Double_ExpressionOperator extends ExpressionOperator, Double_Operator {
}

@information(type="Double")
abstract class Double_BitOperator extends Double_ExpressionOperator, BitOperator {
	val Double_ExpressionOperator[2..*] connects;
}

@information(type="Double")
class Double_And_BitOperator extends Double_BitOperator {

	@GenModel(body="return \"&&\";")
	op String[1] getLiteral();
}

@information(type="Double")
class Double_Or_BitOperator extends Double_BitOperator {

	@GenModel(body="return \"||\";")
	op String[1] getLiteral();
}

@information(type="Double")
abstract class Double_Original_FunctionalOperator extends Double_FunctionalOperator {
}

@information(name="greaterThan", literal=">", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Double_greaterThan_FunctionalOperator extends InheritedFrom_Number_to_Double_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \">\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="greaterEquals", literal=">=", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Double_greaterEquals_FunctionalOperator extends InheritedFrom_Number_to_Double_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \">=\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="smallerThan", literal="<", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Double_smallerThan_FunctionalOperator extends InheritedFrom_Number_to_Double_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \"<\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="smallerEquals", literal="<=", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Double_smallerEquals_FunctionalOperator extends InheritedFrom_Number_to_Double_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \"<=\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="equals", literal=".equals", functionalOperatorType="Object", functionalType="Boolean_FunctionalType")
class Number_Double_Object_Number_equals_FunctionalOperator extends InheritedFrom_Number_to_Double_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".equals\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(obj);
return parameterList;")
	op EEList[1] getAllParameters();
	val Object_FunctionalParameter[1] obj;
}

@information(name="toString", literal=".toString", functionalOperatorType="Object", functionalType="String_FunctionalType")
class Number_Double_Object_Number_toString_FunctionalOperator extends InheritedFrom_Number_to_Double_FunctionalOperator, String_FunctionalType {

	@GenModel(body="return \".toString\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
return parameterList;")
	op EEList[1] getAllParameters();
}

abstract class Double_FunctionalOperator extends Operator, ExpressionOperator, Double_Operator, Double_ExpressionOperator, TypedElement, FunctionalOperator {
}

@information(type="Number")
abstract class InheritedFrom_Number_to_Double_FunctionalOperator extends Double_FunctionalOperator {
}

abstract class Float_Calculateable extends Calculateable {
}

abstract class Float_CalculateableElement extends Float_Calculateable, CalculateableElement {
}

abstract class Float_Operator extends Operator {
}

@information(type="Float")
abstract class Float_Type extends Type, Number_Type {
}

abstract class Float_FunctionalType extends Float_Type, FunctionalType {
	val Float_FunctionalOperator operator;
}

class Float_CalculateableParameter extends Float_Type, CalculateableParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

class Float_FunctionalParameter extends Float_Type, FunctionalParameter {

	@GenModel(body="if (diagnostic != null) {
	String errorMessage = \"\";
	EClass thisType = (EClass) this.getType();
	if(this.argument!=null){
		if (this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\")) != null) {
			qmm.FunctionalOperator lastFunctionalOperator = (qmm.FunctionalOperator) ((qmm.FunctionalOperator) this.argument.eGet(this.argument.eClass().getEStructuralFeature(\"operator\"))).getLastOperator();
			EClass lastFunctionalOperatorType = (EClass)lastFunctionalOperator.getType();
			if (!thisType.isSuperTypeOf(lastFunctionalOperatorType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + lastFunctionalOperatorType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		} else {
			EClass argumentType = (EClass) this.argument.getType();
			if (!thisType.isSuperTypeOf(argumentType)) {
				errorMessage = \"Parameter \" + this.toString() + \": Argument of type \" + argumentType.getName() + \" is not compatible with parametertype \" + thisType.getName() + \".\";
				diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage, new Object[] { this }));
			}
		}
 	}
}
return true;")
	op boolean[1] validate(ecore.EDiagnosticChain diagnostic, ecore.EMap context);
}

datatype Float : java.lang.Float;

abstract class Float_Argument extends FunctionalArgument, Float_FunctionalType {
}

class Float_PrimitiveArgument extends Float_Argument, PrimitiveArgument {
	attr Float[1] value;
}

@information(functionalType="Float")
abstract class Float_EvaluationOperation_Argument extends EvaluationOperation_Argument, Float_Argument {
}

@information(type="Float")
abstract class Float_ExpressionOperator extends ExpressionOperator, Float_Operator {
}

@information(type="Float")
abstract class Float_BitOperator extends Float_ExpressionOperator, BitOperator {
	val Float_ExpressionOperator[2..*] connects;
}

@information(type="Float")
class Float_And_BitOperator extends Float_BitOperator {

	@GenModel(body="return \"&&\";")
	op String[1] getLiteral();
}

@information(type="Float")
class Float_Or_BitOperator extends Float_BitOperator {

	@GenModel(body="return \"||\";")
	op String[1] getLiteral();
}

@information(type="Float")
abstract class Float_Original_FunctionalOperator extends Float_FunctionalOperator {
}

@information(name="greaterThan", literal=">", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Float_greaterThan_FunctionalOperator extends InheritedFrom_Number_to_Float_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \">\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="greaterEquals", literal=">=", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Float_greaterEquals_FunctionalOperator extends InheritedFrom_Number_to_Float_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \">=\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="smallerThan", literal="<", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Float_smallerThan_FunctionalOperator extends InheritedFrom_Number_to_Float_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \"<\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="smallerEquals", literal="<=", functionalOperatorType="Number", functionalType="Boolean_FunctionalType")
class Number_Float_smallerEquals_FunctionalOperator extends InheritedFrom_Number_to_Float_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \"<=\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(i);
return parameterList;")
	op EEList[1] getAllParameters();
	val Number_FunctionalParameter[1] i;
}

@information(name="equals", literal=".equals", functionalOperatorType="Object", functionalType="Boolean_FunctionalType")
class Number_Float_Object_Number_equals_FunctionalOperator extends InheritedFrom_Number_to_Float_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".equals\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(obj);
return parameterList;")
	op EEList[1] getAllParameters();
	val Object_FunctionalParameter[1] obj;
}

@information(name="toString", literal=".toString", functionalOperatorType="Object", functionalType="String_FunctionalType")
class Number_Float_Object_Number_toString_FunctionalOperator extends InheritedFrom_Number_to_Float_FunctionalOperator, String_FunctionalType {

	@GenModel(body="return \".toString\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
return parameterList;")
	op EEList[1] getAllParameters();
}

abstract class Float_FunctionalOperator extends Operator, ExpressionOperator, Float_Operator, Float_ExpressionOperator, TypedElement, FunctionalOperator {
}

@information(type="Number")
abstract class InheritedFrom_Number_to_Float_FunctionalOperator extends Float_FunctionalOperator {
}

@information(name="equals", literal=".equals", functionalOperatorType="Object", functionalType="Boolean_FunctionalType")
class Object_CharSequence_equals_FunctionalOperator extends InheritedFrom_Object_to_CharSequence_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".equals\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(obj);
return parameterList;")
	op EEList[1] getAllParameters();
	val Object_FunctionalParameter[1] obj;
}

@information(name="toString", literal=".toString", functionalOperatorType="Object", functionalType="String_FunctionalType")
class Object_CharSequence_toString_FunctionalOperator extends InheritedFrom_Object_to_CharSequence_FunctionalOperator, String_FunctionalType {

	@GenModel(body="return \".toString\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
return parameterList;")
	op EEList[1] getAllParameters();
}

abstract class CharSequence_FunctionalOperator extends Operator, ExpressionOperator, CharSequence_Operator, CharSequence_ExpressionOperator, TypedElement, FunctionalOperator {
}

@information(type="Object")
abstract class InheritedFrom_Object_to_CharSequence_FunctionalOperator extends CharSequence_FunctionalOperator {
}

@information(name="equals", literal=".equals", functionalOperatorType="Object", functionalType="Boolean_FunctionalType")
class Object_Character_equals_FunctionalOperator extends InheritedFrom_Object_to_Character_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".equals\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(obj);
return parameterList;")
	op EEList[1] getAllParameters();
	val Object_FunctionalParameter[1] obj;
}

@information(name="toString", literal=".toString", functionalOperatorType="Object", functionalType="String_FunctionalType")
class Object_Character_toString_FunctionalOperator extends InheritedFrom_Object_to_Character_FunctionalOperator, String_FunctionalType {

	@GenModel(body="return \".toString\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
return parameterList;")
	op EEList[1] getAllParameters();
}

abstract class Character_FunctionalOperator extends Operator, ExpressionOperator, Character_Operator, Character_ExpressionOperator, TypedElement, FunctionalOperator {
}

@information(type="Object")
abstract class InheritedFrom_Object_to_Character_FunctionalOperator extends Character_FunctionalOperator {
}

@information(name="equals", literal=".equals", functionalOperatorType="Object", functionalType="Boolean_FunctionalType")
class Object_Boolean_equals_FunctionalOperator extends InheritedFrom_Object_to_Boolean_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".equals\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(obj);
return parameterList;")
	op EEList[1] getAllParameters();
	val Object_FunctionalParameter[1] obj;
}

@information(name="toString", literal=".toString", functionalOperatorType="Object", functionalType="String_FunctionalType")
class Object_Boolean_toString_FunctionalOperator extends InheritedFrom_Object_to_Boolean_FunctionalOperator, String_FunctionalType {

	@GenModel(body="return \".toString\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
return parameterList;")
	op EEList[1] getAllParameters();
}

abstract class Boolean_FunctionalOperator extends Operator, ExpressionOperator, Boolean_Operator, Boolean_ExpressionOperator, TypedElement, FunctionalOperator {
}

@information(type="Object")
abstract class InheritedFrom_Object_to_Boolean_FunctionalOperator extends Boolean_FunctionalOperator {
}

@information(name="length", literal=".length", functionalOperatorType="CharSequence", functionalType="Integer_FunctionalType")
class CharSequence_String_length_FunctionalOperator extends InheritedFrom_CharSequence_to_String_FunctionalOperator, Integer_FunctionalType {

	@GenModel(body="return \".length\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
return parameterList;")
	op EEList[1] getAllParameters();
}

@information(name="equals", literal=".equals", functionalOperatorType="Object", functionalType="Boolean_FunctionalType")
class CharSequence_String_Object_CharSequence_equals_FunctionalOperator extends InheritedFrom_CharSequence_to_String_FunctionalOperator, Boolean_FunctionalType {

	@GenModel(body="return \".equals\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(obj);
return parameterList;")
	op EEList[1] getAllParameters();
	val Object_FunctionalParameter[1] obj;
}

@information(name="toString", literal=".toString", functionalOperatorType="Object", functionalType="String_FunctionalType")
class CharSequence_String_Object_CharSequence_toString_FunctionalOperator extends InheritedFrom_CharSequence_to_String_FunctionalOperator, String_FunctionalType {

	@GenModel(body="return \".toString\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
return parameterList;")
	op EEList[1] getAllParameters();
}

abstract class String_FunctionalOperator extends Operator, ExpressionOperator, String_Operator, String_ExpressionOperator, TypedElement, FunctionalOperator {
}

@information(type="CharSequence")
abstract class InheritedFrom_CharSequence_to_String_FunctionalOperator extends String_FunctionalOperator {
}

@information(functionalType="Integer", literal="count")
class Count_AggregationOperator extends CountingAggregationOperator, Integer_EvaluationOperation_Argument {

	@GenModel(body="return \"count\";")
	op String[1] getLiteral();
}

@information(functionalType="Integer", literal="sum")
class Sum_AggregationOperator extends CalculatingAggregationOperator, Integer_EvaluationOperation_Argument {

	@GenModel(body="return \"sum\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(calculateable);
return parameterList;")
	op EEList[1] getAllParameters();
	val Integer_CalculateableParameter[1] calculateable;
}

@information(functionalType="Integer", literal="min")
class Min_AggregationOperator extends CalculatingAggregationOperator, Integer_EvaluationOperation_Argument {

	@GenModel(body="return \"min\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(calculateable);
return parameterList;")
	op EEList[1] getAllParameters();
	val Integer_CalculateableParameter[1] calculateable;
}

@information(functionalType="Integer", literal="max")
class Max_AggregationOperator extends CalculatingAggregationOperator, Integer_EvaluationOperation_Argument {

	@GenModel(body="return \"max\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(calculateable);
return parameterList;")
	op EEList[1] getAllParameters();
	val Integer_CalculateableParameter[1] calculateable;
}

@information(functonalType="Integer", literal="Integer.parseInt")
class IntegerParseInt_ClassOperator extends ClassOperator, Integer_EvaluationOperation_Argument {

	@GenModel(body="return \"Integer.parseInt\";")
	op String[1] getLiteral();

	@GenModel(body="EList parameterList = new org.eclipse.emf.common.util.BasicEList();
parameterList.add(calculateable);
return parameterList;")
	op EEList[1] getAllParameters();
	val String_FunctionalParameter[1] calculateable;
}

