@namespace(uri="http://alma/1.0", prefix="alma")
package alma;

@namespace(uri="http://alma.control/1.0", prefix="alma.control")
package control {
	@namespace(uri="http://alma/Control/datamodel/1.0", prefix="alma.Control.datamodel")
	package datamodel {
		@namespace(uri="http://alma/Control/datamodel/meta/1.0", prefix="alma.Control.datamodel.meta")
		package meta {
			@namespace(uri="http://alma/Control/datamodel/meta/amb/1.0", prefix="alma.Control.datamodel.meta.amb")
			package amb {
				class Archive extends base.ArchiveProperty {

					@GenModel(body="return row[tables.getColNum(sheet, \"Assembly\")];")
					op String Assembly();

					@GenModel(body="String s = IntervalFull();
       if (s.startsWith(\"te/\"))
           return true;
return false;")
					op boolean IsIntervalTE();

					@GenModel(body="if(IsIntervalTE())
	return IntervalFull().substring(3);
return IntervalFull();")
					op String Interval();

					@GenModel(body="this.row = row;
this.tables = tables;
super.setArchiveProperty(row, tables);")
					op void setArchiveAmb(base.EStringArray row, base.Table tables);
				}

				class Control extends base.ControlPoint {

					@GenModel(body="return row[tables.getColNum(sheet, \"Data\")];")
					op String Data();

					@GenModel(body="return row[tables.getColNum(sheet, \"Value\")];")
					op String Value();

					@GenModel(body="return row[tables.getColNum(sheet, \"Returns\")];")
					op String Returns();

					@GenModel(body="return row[tables.getColNum(sheet, \"Parameter\")];")
					op String Parameter();

					@GenModel(body="return mac.Assembly();")
					op String Assembly();

					@GenModel(body="return mac.RCA();")
					op String RCA();

					@GenModel(body="return mac.RawDataType();")
					op String RawDataType();

					@GenModel(body="return mac.TeRelated();")
					op boolean TeRelated();

					@GenModel(body="return mac.WorldDataType();")
					op String WorldDataType();

					@GenModel(body="return mac.Scale();")
					op String Scale();

					@GenModel(body="return mac.Offset();")
					op String Offset();

					@GenModel(body="return mac.RawDataToCPPType();")
					op String RawDataToCPPType();

					@GenModel(body="return mac.WorldDataToCPPType();")
					op String WorldDataToCPPType();

					@GenModel(body="return mac.WorldDataToCORBAType();")
					op String WorldDataToCORBAType();

					@GenModel(body="return mac.WorldDataToIDLSeqType();")
					op String WorldDataToIDLSeqType();

					@GenModel(body="return mac.WorldDataToIDLType();")
					op String WorldDataToIDLType();

					@GenModel(body="return mac.WorldDataToCORBASeqType();")
					op String WorldDataToCORBASeqType();

					@GenModel(body="return mac.WorldDataToCORBADevIOType();")
					op String WorldDataToCORBADevIOType();

					@GenModel(body="return mac.WorldDataToJavaType();")
					op String WorldDataToJavaType();

					@GenModel(body="return mac.WorldDataToDatabaseType();")
					op String WorldDataToDatabaseType();

					@GenModel(body="return mac.WorldDataToBACIType();")
					op String WorldDataToBACIType();

					@GenModel(body="return mac.IsRawDataArray();")
					op boolean IsRawDataArray();

					@GenModel(body="return mac.IsWorldDataArray();")
					op boolean IsWorldDataArray();

					@GenModel(body="return utils.normalizeNumber(WorldDataType(),super.MinRange());")
					op String MinRange();

					@GenModel(body="return utils.normalizeNumber(WorldDataType(),super.MaxRange());")
					op String MaxRange();

					@GenModel(body="return (String)tables.getWorldToIDL().get(Returns());")
					op String idlReturns();

					@GenModel(body="return (String)tables.getWorldToCORBA().get(Returns());")
					op String corbaReturns();

					@GenModel(body="String s = idlSignature();
return s;")
					op String idlDeclaration();

					@GenModel(body="		String s = \"SET_\" + CPName();
		if (!Parameter().equals(\"default\")) {
			if (Parameter().equals(\"void\"))
				s += \"()\";
			else
				s += \"(\" + idlParameters() + \")\";
			if (External()) {
				s +=  \" raises(ControlExceptions::CAMBErrorEx, ControlExceptions::INACTErrorEx)\";
			}
			return s;
			// This gets the non-default case out of the way.
		}
		// This is the \"default\" case.
		boolean isTeRelated = TeRelated();
		boolean isExternal = External();
		boolean isArray = IsWorldDataArray();
		if (isExternal) {
			if (isArray) {
				s += \"(in \" + WorldDataToIDLSeqType() + \" world\";
			} else {
				s += \"(in \" + WorldDataToIDLType() + \" world\";
			}
		}
		if (isTeRelated) {
			s += \", in ACS::Time requestTime)\";
		} else {
			s += \")\";
		}
		if (isExternal) {
			s += \" raises(ControlExceptions::CAMBErrorEx, ControlExceptions::INACTErrorEx)\";
		}
		return s;")
					op String idlSignature();

					@GenModel(body="				String s = Parameter();
				int pos = 0;
				int n = s.indexOf(' ');
				if (n == -1)
					throw new RuntimeException(\"Invalid syntax in Parameter field: (\" + s + \")\");
				String word = s.substring(pos,n);
				String out = \"\";
				boolean isArray = IsWorldDataArray();
				if (isArray) {
					out += \"in \" + (String)tables.getWorldToIDLSeq().get(word) + \" \";
				}
				else
					out = \"in \" + (String)tables.getWorldToIDL().get(word) + \" \";
				pos = n + 1;
				while (true) {
					n = s.indexOf(',',pos);
					if (n == -1)
						break;
					word = s.substring(pos,n);
					out += word + \", \";
					pos = n + 1;
					while (true) {
						if (s.charAt(pos) == ' ')
							pos++;
						else
							break;
					}
					n = s.indexOf(' ',pos);
					if (n == -1)
						throw new RuntimeException(\"Invalid syntax in Parameter field: (\" + s + \")\");
					word = s.substring(pos,n);
					if (isArray) {
						String type = (String)tables.getWorldToIDL().get(word);
						type = type.replace(\"unsigned long\", \"uLong\");
						out += \"in \" + type;
					}
					else
						out = \"in \" + (String)tables.getWorldToIDL().get(word) + \" \";
					pos = n + 1;
				}
				word = s.substring(pos);
				out += word;
				return out;")
					op String idlParameters();

					@GenModel(body="String s = \"\";
        if (!Parameter().equals(\"default\")) {
            if (Parameter().equals(\"void\"))
                s += \"()\";
            else
                s += \"(\" + corbaParameters() + \")\";
            return s;
            // This gets the non-default case out of the way.
        }
        // This is the \"default\" case.
        boolean isTeRelated = TeRelated();
        boolean isArray = IsWorldDataArray();
        if(isArray == true)
        {
            s += \"(const \" + WorldDataToCORBASeqType() + \"& world\";
        }
        else
        {
            String type = WorldDataToCORBAType();
            if(type.equalsIgnoreCase(\"CORBA::String\") == true)
            {
                type = \"const \" + type + \"_var&\";
            }

            s += \"(\" + type + \" world\";
        }
        if (isTeRelated)
        {
            s += \", const acstime::Epoch& requestTime)\";
        }
        else
        {
            s += \")\";
        }
        return s;")
					op String corbaDeclaration();

					@GenModel(body="				String s = Parameter();
				int pos = 0;
				int n = s.indexOf(' ');
				if (n == -1)
					throw new RuntimeException(\"Invalid syntax in Parameter field: (\" + s + \")\");
				String word = s.substring(pos,n);
				String out = (String)tables.getWorldToCORBA().get(word) + \" \";
				pos = n + 1;
				while (true) {
					n = s.indexOf(',',pos);
					if (n == -1)
						break;
					word = s.substring(pos,n);
					out += word + \", \";
					pos = n + 1;
					while (true) {
						if (s.charAt(pos) == ' ')
							pos++;
						else
							break;
					}
					n = s.indexOf(' ',pos);
					if (n == -1)
						throw new RuntimeException(\"Invalid syntax in Parameter field: (\" + s + \")\");
					word = s.substring(pos,n);
					out += (String)tables.getWorldToCORBA().get(word);
					pos = n + 1;
				}
				word = s.substring(pos);
				out += word;
				return out;")
					op String corbaParameters();

					@GenModel(body="return (String)tables.getWorldToCPP().get(Returns());")
					op String cppReturns();

					@GenModel(body="        String s = \"\";
        if (!Parameter().equals(\"default\")) {
            if (Parameter().equals(\"void\"))
                s += \"()\";
            else
                s += \"(\" + cppParameters() + \")\";
            return s;
            // This gets the non-default case out of the way.
        }
        // This is the \"default\" case.
        boolean isTeRelated = TeRelated();
        boolean isArray = IsWorldDataArray();
        if (isArray) {
            s += \"(const std::vector< \" + WorldDataToCPPType() + \" >& world\";
        } else {
            s += \"(const \" + WorldDataToCPPType() + \" world\";
        }
        if (isTeRelated) {
            s += \", const acstime::Epoch& requestTime)\";
        } else {
            s += \")\";
        }
        return s;")
					op String cppDeclaration();

					@GenModel(body="	String s = Parameter();
				int pos = 0;
				int n = s.indexOf(' ');
				if (n == -1)
					throw new RuntimeException(\"Invalid syntax in Parameter field: (\" + s + \")\");
				String word = s.substring(pos,n);
				String out = (String)tables.getWorldToCPP().get(word) + \" \";
				pos = n + 1;
				while (true) {
					n = s.indexOf(',',pos);
					if (n == -1)
						break;
					word = s.substring(pos,n);
					out += word + \", \";
					pos = n + 1;
					while (true) {
						if (s.charAt(pos) == ' ')
							pos++;
						else
							break;
					}				
					n = s.indexOf(' ',pos);
					if (n == -1)
						throw new RuntimeException(\"Invalid syntax in Parameter field: (\" + s + \")\");
					word = s.substring(pos,n);
					out += (String)tables.getWorldToCPP().get(word) + \" \";
					pos = n + 1;
				}
				word = s.substring(pos);
				out += word;
				return out;")
					op String cppParameters();

					@GenModel(body="        if (!Parameter().equals(\"default\")) {
            if (Parameter().equals(\"void\"))
                return \"\";
            else
                return argWords();
            // This gets the non-default case out of the way.
        }
        // This is the \"default\" case.
        String s = \"world\";
        boolean isTeRelated = TeRelated();
        if (isTeRelated) {
            s += \", requestTime\";
        }
        return s;")
					op String argList();

					@GenModel(body="		String s = Parameter();
		int pos = 0;
		int n = s.indexOf(' ');
		if (n == -1)
			throw new RuntimeException(\"Invalid syntax in Parameter field: (\" + s + \")\");
		String word = s.substring(pos,n);
		String out = \"\";
		pos = n + 1;
		while (true) {
			n = s.indexOf(',',pos);
			if (n == -1)
				break;
			word = s.substring(pos,n);
			out += word + \", \";
			pos = n + 1;
			while (true) {
				if (s.charAt(pos) == ' ')
					pos++;
				else
					break;
			}
			n = s.indexOf(' ',pos);
			if (n == -1)
				throw new RuntimeException(\"Invalid syntax in Parameter field: (\" + s + \")\");
			word = s.substring(pos,n);
			pos = n + 1;
		}
		word = s.substring(pos);
		out += word;
		return out;")
					op String argWords();

					@GenModel(body="return mac.IsConversion();")
					op boolean IsConversion();

					@GenModel(body="return mac.IsSpecialConversion();")
					op boolean IsSpecialConversion();

					@GenModel(body="return mac.NumberItemsRawData();")
					op String NumberItemsRawData();

					@GenModel(body="return mac.TotalBytesRawData();")
					op String TotalBytesRawData();

					@GenModel(body="return mac.NumberRawDataTypeBytes();")
					op String NumberRawDataTypeBytes();

					@GenModel(body="return mac.NumberItemsWorldData();")
					op String NumberItemsWorldData();

					@GenModel(body="return mac.RCACell();")
					op String RCACell();

					@GenModel(body="return mac.TeRelatedCell();")
					op String TeRelatedCell();

					@GenModel(body="return mac.IsDependentGroupBit();")
					op boolean IsDependentGroupBit();

					@GenModel(body="return mac.IsDependentBit();")
					op boolean IsDependentBit();

					@GenModel(body="return mac.IsDependentElement();")
					op boolean IsDependentElement();

					@GenModel(body="return mac.IsByteSwapped();")
					op boolean IsByteSwapped();

					@GenModel(body="return mac.IsDependentBitElement();")
					op boolean IsDependentBitElement();

					@GenModel(body="return mac.IsDependentArrayElement();")
					op boolean IsDependentArrayElement();

					@GenModel(body="return mac.GetDimension();")
					op String GetDimension();

					@GenModel(body="return mac.IsSingleBit();")
					op boolean IsSingleBit();

					@GenModel(body="return mac.GetBit();")
					op String GetBit();

					@GenModel(body="return mac.GetMask();")
					op String GetMask();

					@GenModel(body="return mac.GetFirstBit();")
					op String GetFirstBit();

					@GenModel(body="return mac.GetLastBit();")
					op String GetLastBit();

					@GenModel(body="return mac.GetGroupMask();")
					op String GetGroupMask();

					@GenModel(body="return mac.GetGroupEnd();")
					op String GetGroupEnd();

					@GenModel(body="return mac.GetGroupStart();")
					op String GetGroupStart();

					@GenModel(body="return mac.RawSubArrayEndIndex();")
					op String RawSubArrayEndIndex();

					@GenModel(body="return mac.RawSubArrayStartIndex();")
					op String RawSubArrayStartIndex();

					@GenModel(body="return mac.IsRawSubArray();")
					op boolean IsRawSubArray();

					@GenModel(body="return mac.WorldDataToDatabaseTypeUpper1();")
					op String WorlDataToDatabaseTypeUpper1();

					@GenModel(body="return mac.WorldDataTypeUpper1();")
					op String WorldDataTypeUpper1();

					@GenModel(body="this.row = row;
this.parent = parent;
super.setControlPoint(row, parent);
mac = new MandCImpl();
mac.setMandCAmb(tables, utils);
mac.setMandCAmb(row, sheet, this);")
					op void setControlAmb(base.EStringArray row, EObject parent);
					ref MandC mac;
				}

				class DeviceModel extends base.DeviceModel {

					@GenModel(body="return monitorDBOnly;")
					op boolean IsMonitorDBOnly();

					@GenModel(body="return generateAlt;")
					op boolean IsGenerateAlt();

					@GenModel(body="return ((Main)main).Parent();")
					op String Parent();

					@GenModel(body="return ((Main)main).Cardinality();")
					op String Cardinality();

					@GenModel(body="return ((Main)main).NodeAddress();")
					op String NodeAddress();

					@GenModel(body="return ((Main)main).Channel();")
					op String Channel();

					@GenModel(body="return ((Main)main).BaseAddress();")
					op String BaseAddress();

					@GenModel(body="return ((Main)main).GenericMonitorPoints();")
					op boolean GenericMonitorPoints();

					@GenModel(body="return \"true\";")
					op String CreateModel();

					@GenModel(body="String dir = generatedDir + \"/\" + Assembly();
				utils.RemoveLinesFromFile(dir + \"/doc\", Assembly() + \".html\", 1);
				utils.RemoveLinesFromFile(dir + \"/idl\", Assembly() + \"Add.sql\", 1);
				utils.RemoveLinesFromFile(dir + \"/include\", Assembly() + \"HWSimBase.h\", 1);
				utils.RemoveLinesFromFile(dir + \"/src\", Assembly() + \"HWSimBase.cpp\", 1);
				utils.RemoveLinesFromFile(dir + \"/include\", Assembly() + \"CompSimBase.h\", 1);
				utils.RemoveLinesFromFile(dir + \"/src\", Assembly() + \"CompSimBase.cpp\", 1);
				utils.RemoveLinesFromFile(dir + \"/idl\", Assembly() + \"CompSimBase.idl\", 1);
				utils.RemoveLinesFromFile(dir + \"/test\", \"Test\" + Assembly() + \"HWSimImpl.cpp\", 1);
				utils.RemoveLinesFromFile(dir + \"/test\", \"Test\" + Assembly() + \"AmbDeviceInt.cpp\", 1);
					if (!IsMonitorDBOnly()) {
						if (IsGenerateAlt()) {
							utils.RemoveLinesFromFile(dir + \"/../ALT/\", Assembly() + \".makefile\", 1);
							utils.RemoveLinesFromFile(dir + \"/../ALT/\", Assembly() + \"Impl.idl\", 1);
							utils.RemoveLinesFromFile(dir + \"/../ALT/\", Assembly() + \"Impl.h\", 1);
							utils.RemoveLinesFromFile(dir + \"/../ALT/\", Assembly() + \"Impl.cpp\", 1);
						}
						super.TheEnd();
					} else 
						System.out.println(\"Code generation for \" + deviceName + \" done.\");
					return \"\";")
					op String TheEnd();

					@GenModel(body="		String s = NodeAddress();
		if (s.equals(\"parm\"))
			return \"0\";
		return HexToDec(s);")
					op String NodeAddressInDecimal();

					@GenModel(body="		int n = -1;
		try {
			n = Integer.parseInt(s.substring(2),16);
		} catch (NumberFormatException err) {
			throw new RuntimeException(\"Invalid number (\" + s + \")\");
		}
		return Integer.toString(n);")
					op String HexToDec(String s);
					val Main[*] mainAmb;
					val Control[*] cPoints;
					val Archive[*] aPoints;
					val Monitor[*] mPoints;
					val base.Note note;
				}

				class GenericMonitorPoints {

					@GenModel(body="Util util = BaseFactory.eINSTANCE.createUtil();
				dirLocation = util.getInstallDir();
				if (!(new java.io.File(dirLocation + \"/idl/GENERIC_spreadsheet.xml\").exists())){
					System.out.println(\"Spreadsheet GENERIC_spreadsheet not found. Exiting....\");
					System.exit(1);
				}
		
				BaseFactory baseFac = BaseFactory.eINSTANCE;
				SpreadsheetParser parserSpreadsheet = baseFac.createSpreadsheetParser();
		
				String xml = parserSpreadsheet.getSpreadsheet(dirLocation + \"/idl\", \"GENERIC_spreadsheet.xml\");
				String xmlFile = dirLocation + \"/idl/GENERIC_spreadsheet.xml\";
				String xsdFile = dirLocation + \"/config/schemas/amb/Workbook.xsd\";
				SpreadsheetParser p = baseFac.createSpreadsheetParser();
				p.setSpreadsheetParser(xml);
				String [][][] spreadsheet = p.getWorksheets();
				SpreadsheetValidator v = baseFac.createSpreadsheetValidator();
				if (!v.validate(xmlFile,xsdFile)) {
					String s = \"Spreadsheet GENERIC_spreadsheet.xml is not a valid spreadsheet.\";
					throw new RuntimeException(s);
				}
		
				System.out.println(\"Spreadsheet GENERIC has been validated.\");
		
				return spreadsheet;")
					op base.EStringArray3 getParsedGenericSpreadsheet();

					@GenModel(body=" // Create the SP class
        setDeviceName(spreadsheet[0][2][0]);
        String [][][] genericSpreadsheet = getParsedGenericSpreadsheet();
        // Now we iterate through spreadsheet adding monitor, control and archive generic points.
        
        // I coded this way to make the things clear
        int[] Rows = null;
        int[] Columns = null;
        int[] GenericRows = null;
        
        Rows = new int[4];
        Columns = new int[4];
        GenericRows = new int[4];
        
        String deviceName=spreadsheet[0][2][0];
        
        int mainRows = spreadsheet[0].length;
        int monitorRows = spreadsheet[1].length;
        int controlRows = spreadsheet[2].length;
        int archiveRows = spreadsheet[3].length;
        
        int mainColumns = spreadsheet[0][1].length;
        int monitorColumns = spreadsheet[1][1].length;
        int controlColumns = spreadsheet[2][1].length;
        int archiveColumns = spreadsheet[3][1].length;
        
        int genericMonitorRows = genericSpreadsheet[1].length;
        int genericControlRows = genericSpreadsheet[2].length;
        int genericArchiveRows = genericSpreadsheet[3].length;
        
        // Well, first the newSpreadsheet is created. Arrays are static structures....
        newSpreadsheet = new String[4][][];
        newSpreadsheet[0] = new String[mainRows][mainColumns];
        newSpreadsheet[1] = new String[monitorRows+genericMonitorRows-2][monitorColumns];
        newSpreadsheet[2] = new String[controlRows+genericControlRows-2][controlColumns];
        newSpreadsheet[3] = new String[archiveRows+genericArchiveRows-2][archiveColumns];
        
	// Hardware Device
        newSpreadsheet[0][0] = new String[1];
        newSpreadsheet[0][0][0] = spreadsheet[0][0][0];
	// Monitor Point
        newSpreadsheet[1][0] = new String[1];
        newSpreadsheet[1][0][0] = spreadsheet[1][0][0];
	// Control Point
        newSpreadsheet[2][0] = new String[1];
        newSpreadsheet[2][0][0] = spreadsheet[2][0][0];
	// Archive Property
        newSpreadsheet[3][0] = new String[1];
        newSpreadsheet[3][0][0] = spreadsheet[3][0][0];
        
        Rows[0] = mainRows; // Yes here I ignore Notes on Main spreadsheet
        Rows[1] = monitorRows;
        Rows[2] = controlRows;
        Rows[3] = archiveRows;
        
        Columns[0] = mainColumns;
        Columns[1] = monitorColumns;
        Columns[2] = controlColumns;
        Columns[3] = archiveColumns;
        
        // Then I copy elements from spreadsheet to newSpreadsheet
        for (int i = 0; i < Rows.length; i++ ) {
            for (int j = 1; j < Rows[i]; j++) {
                for (int k = 0; k < Columns[i]; k++) {
                    if (spreadsheet[i][j][k].equals(\"Notes\")){
                        newSpreadsheet[i][j] = new String[2];
                        newSpreadsheet[i][j][k] = spreadsheet[i][j][k];
                        newSpreadsheet[i][j][k+1] = spreadsheet[i][j][k+1];
                        break; 
                    }
                    newSpreadsheet[i][j][k] = spreadsheet[i][j][k];
                }

            }
        }        
        
        // Here we start the copy process from generic spreadsheet
        GenericRows[0] = 0;
        GenericRows[1] = genericMonitorRows;
        GenericRows[2] = genericControlRows;
        GenericRows[3] = genericArchiveRows;

        for (int i = 1; i < Rows.length ; i++ ) {
            for (int j = Rows[i];j < (Rows[i] + GenericRows[i] - 2); j++) {
                for (int k = 0; k < Columns[i]; k++) {
                    if ( (genericSpreadsheet[i][j-Rows[i]+2][k]).equals(\"GENERIC\")){
                        newSpreadsheet[i][j][k] = deviceName;
                    } else {
                        newSpreadsheet[i][j][k] = genericSpreadsheet[i][j-Rows[i]+2][k];
                    }
                }
            }
        }
        return newSpreadsheet;")
					op base.EStringArray3 getDeviceWorksheetWithGenericPointsAdded(base.EStringArray3 spreadsheet);
					attr base.EStringArray3 newSpreadsheet;
					attr String deviceName;
					attr String dirLocation;
				}

				class Main extends base.MainBase {

					@GenModel(body="return row[tables.getColNum(sheet, \"Parent\")];")
					op String Parent();

					@GenModel(body="return row[tables.getColNum(sheet, \"Cardinality\")];")
					op String Cardinality();

					@GenModel(body="return row[tables.getColNum(sheet, \"Node Address\")];")
					op String NodeAddress();

					@GenModel(body="return row[tables.getColNum(sheet, \"Channel\")];")
					op String Channel();

					@GenModel(body="return row[tables.getColNum(sheet, \"Base Address\")];")
					op String BaseAddress();

					@GenModel(body="return row[tables.getColNum(sheet, \"Generic Monitor Points\")].equals(\"yes\");")
					op boolean GenericMonitorPoints();

					@GenModel(body="this.row = row;
super.setMainBase(row);")
					op void setMainAmb(base.EStringArray row);
				}

				class MandC {

					@GenModel(body="return row[tables.getColNum(sheet, \"Assembly\")];")
					op String Assembly();

					@GenModel(body="return row[tables.getColNum(sheet, \"RCA\")];")
					op String RCA();

					@GenModel(body="return row[tables.getColNum(sheet, \"RCA\")];")
					op String RCACell();

					@GenModel(body="String s = row[tables.getColNum(sheet, \"Raw Data Type\")];
				if(!mcp.IsDependent())
					return IsRawDataArray() ? s.substring(0, s.indexOf(\"[\")) : s;
					if(mcp instanceof Monitor)
						return ((Monitor) mcp.getParent()).RawDataType();
					if(mcp instanceof Control)
						return ((Control) mcp.getParent()).RawDataType();
					return \"ERROR\";")
					op String RawDataType();

					@GenModel(body="return row[tables.getColNum(sheet, \"Raw Data Type\")];")
					op String RawDataTypeCell();

					@GenModel(body="return false;")
					op boolean TeRelated();

					@GenModel(body="return row[tables.getColNum(sheet, \"TE Related\")];")
					op String TeRelatedCell();

					@GenModel(body="String s = row[tables.getColNum(sheet, \"World Data Type\")];
return IsWorldDataArray() ? s.substring(0, s.indexOf(\"[\")) : s;")
					op String WorldDataType();

					@GenModel(body="return row[tables.getColNum(sheet, \"World Data Type\")];")
					op String WorldDataTypeCell();

					@GenModel(body="String s = ScaleCell();
if((s.equals(\"none\") == true) || (s.equals(\"extended\") == true) || (s.equals(tables.getCelsiusToKelvin()) == true))
						s = \"1.0\";
						return s;")
					op String Scale();

					@GenModel(body="return utils.normalizeNumber(WorldDataType(), row[tables.getColNum(sheet, \"Scale\")]);")
					op String ScaleCell();

					@GenModel(body="		String s = ScaleCell();
		if(s.equals(tables.getCelsiusToKelvin()))
			return \"273.15\";
		String o = OffsetCell();
		if((o.equals(\"0\") == true) || (o.equals(\"none\") == true)	|| (o.equals(\"extended\") == true))
			o = \"0.0\";
		return o;")
					op String Offset();

					@GenModel(body="return utils.normalizeNumber(WorldDataType(), row[tables.getColNum(sheet, \"Offset\")]);")
					op String OffsetCell();

					@GenModel(body="return (String)tables.getRawToCPP().get(RawDataType());")
					op String RawDataToCPPType();

					@GenModel(body="return (String)tables.getWorldToCPP().get(WorldDataType());")
					op String WorldDataToCPPType();

					@GenModel(body="return (String)tables.getWorldToCORBA().get(WorldDataType());")
					op String WorldDataToCORBAType();

					@GenModel(body="return (String)tables.getWorldToIDLSeq().get(WorldDataType());")
					op String WorldDataToIDLSeqType();

					@GenModel(body="return (String)tables.getWorldToIDL().get(WorldDataType());")
					op String WorldDataToIDLType();

					@GenModel(body="return (String)tables.getWorldToCORBASeq().get(WorldDataType());")
					op String WorldDataToCORBASeqType();

					@GenModel(body="return (String)tables.getWorldToCORBADevIO().get(WorldDataType());")
					op String WorldDataToCORBADevIOType();

					@GenModel(body="return (String)tables.getWorldToJava().get(WorldDataType());")
					op String WorldDataToJavaType();

					@GenModel(body="return (String)tables.getWorldToDatabase().get(WorldDataType());")
					op String WorldDataToDatabaseType();

					@GenModel(body="return (String)tables.getWorldToBACI().get(WorldDataType());")
					op String WorldDataToBACIType();

					@GenModel(body="		if(ScaleCell().equals(\"none\") && OffsetCell().equals(\"none\"))
		{
			return false;
		}
		else if(ScaleCell().equals(\"1.0\") && OffsetCell().equals(\"0.0\"))
		{
			return false;
		}
		else if(ScaleCell().equals(\"1.0\") && OffsetCell().equals(\"none\"))
		{
			return false;
		}
		else if(ScaleCell().equals(\"none\") && OffsetCell().equals(\"0.0\"))
		{
			return false;
		}

		return true;")
					op boolean IsConversion();

					@GenModel(body="return ScaleCell().equals(\"extended\");")
					op boolean IsSpecialConversion();

					@GenModel(body="String s = row[tables.getColNum(sheet, \"World Data Type\")];
return s.endsWith(\"]\") ? true : false;")
					op boolean IsWorldDataArray();

					@GenModel(body="		String s = row[tables.getColNum(sheet, \"Raw Data Type\")];
							if(!mcp.IsDependent())
							return s.endsWith(\"]\") ? true : false;
							if(s.startsWith(\"&lt;\") && s.substring(1).indexOf(\"&lt;\") != -1)
							return true;
						return false;")
					op boolean IsRawDataArray();

					@GenModel(body="String s = row[tables.getColNum(sheet, \"Raw Data Type\")];
return utils.NumberOfItems(s);")
					op String NumberItemsRawData();

					@GenModel(body="		String s = row[tables.getColNum(sheet, \"Raw Data Type\")];
		return utils.RawDataTypeTotalBytes(s);")
					op String TotalBytesRawData();

					@GenModel(body="return utils.NumberRawDataTypeBytes(RawDataType());")
					op String NumberRawDataTypeBytes();

					@GenModel(body="	String s = row[tables.getColNum(sheet, \"World Data Type\")];
				return utils.NumberOfItems(s);")
					op String NumberItemsWorldData();

					@GenModel(body="		if(!mcp.IsDependent())
			return false;
		if(IsDependentBit() && RawDataTypeCell().indexOf(\"-\") != -1)
			return true;
		return false;")
					op boolean IsDependentGroupBit();

					@GenModel(body="		if(!mcp.IsDependent())
			return false;
		if(RawDataTypeCell().startsWith(\"&lt;\"))
			return true;
		return false;")
					op boolean IsDependentBit();

					@GenModel(body="		if(!mcp.IsDependent())
			return false;
		if(RawDataTypeCell().startsWith(\"[\"))
			return true;
		return false;")
					op boolean IsDependentElement();

					@GenModel(body="return ((String)tables.getRawToByteSwapped().get(RawDataType())).equals(true);")
					op boolean IsByteSwapped();

					@GenModel(body="		if(!mcp.IsDependent())
			return false;
		if(RawDataTypeCell().startsWith(\"&lt;\"))
			return true;
		return false;")
					op boolean IsDependentBitElement();

					@GenModel(body="		if(!mcp.IsDependent())
			return false;
		if(RawDataTypeCell().startsWith(\"[\"))
			return true;
		return false;")
					op boolean IsDependentArrayElement();

					@GenModel(body="		String s = RawDataTypeCell();
		if(IsDependentArrayElement())
		{
			int n = s.indexOf(\"]\");
			return s.substring(1, n);
		}
		if(!IsRawDataArray())
			return \"0\";
		if(IsDependentBitElement())
		{
			int n = s.indexOf(\"&gt;\");
			return s.substring(4, n);
		}
		return \"0\";")
					op String GetDimension();

					@GenModel(body="		String s = RawDataTypeCell();
		if(!s.startsWith(\"&lt;\"))// &lt;0&gt;
			return false;
		if(!s.endsWith(\"&gt;\"))
			return false;
		if(s.indexOf(\"-\") == -1)
			return true;
		return false;")
					op boolean IsSingleBit();

					@GenModel(body="		String s = RawDataTypeCell();
		int n = s.indexOf(\"&gt;\");
		return s.substring(4, n);")
					op String GetBit();

					@GenModel(body="		String s = RawDataTypeCell();
		if(!s.startsWith(\"&lt;\") || !s.endsWith(\"&gt;\"))
			return \"\";
		if(IsSingleBit())
			return GetBit();
		int n = s.indexOf(\"-\");
		if(n == -1)
			return \"\";
		return s.substring(4, n);")
					op String GetFirstBit();

					@GenModel(body="		String s = RawDataTypeCell();
		if(!s.startsWith(\"&lt;\") || !s.endsWith(\"&gt;\"))
			return \"\";
		if(IsSingleBit())
			return GetBit();
		int n = s.indexOf(\"-\");
		if(n == -1)
			return \"\";
		return s.substring(n + 1, s.length() - 4);")
					op String GetLastBit();

					@GenModel(body="		String s = RawDataTypeCell();
		if(IsRawDataArray())
		{
			s = s.substring(4);
			int n = s.indexOf(\"&lt;\");
			int m = s.substring(n + 4).indexOf(\"&gt;\");
			if(n == -1 || m == -1)
				return \"\";
			s = s.substring(n + 4, m + n + 4);
		}
		else
		{
			s = s.substring(4, s.length() - 4);
		}
		// \"s\" is of type \"i-j\"
		int n = s.indexOf(\"-\");
		if(n == -1)
			return \"\";
		return s.substring(0, n);")
					op String GetGroupStart();

					@GenModel(body="		String s = RawDataTypeCell();
		int n = s.indexOf(\"-\");
		if(n == -1)
			return \"\";
		return s.substring(n + 1, s.length() - 4);")
					op String GetGroupEnd();

					@GenModel(body="		String firstBit = GetGroupStart();
		String lastBit = GetGroupEnd();
		int n = Integer.parseInt(firstBit);
		int m = Integer.parseInt(lastBit);
		int intMaskSize = m - n;
		int intMask = 0;
		for(int i = 0; i <= intMaskSize; i++)
		{
			intMask += Math.pow(2, i);
		}
		String mask = \"0x\".concat(Integer.toHexString(intMask).toUpperCase());
		return mask;")
					op String GetGroupMask();

					@GenModel(body="		String s = RawDataTypeCell();
		if((s.indexOf(\"[\") != -1) && (s.indexOf(\"-\") != -1)
				&& (s.indexOf(\"]\") != -1))
			return true;
		return false;")
					op boolean IsRawSubArray();

					@GenModel(body="		String s = RawDataTypeCell();
		return String.valueOf(findRawSubArrayIndex(s, true));")
					op String RawSubArrayStartIndex();

					@GenModel(body="		String s = RawDataTypeCell();
		return String.valueOf(findRawSubArrayIndex(s, false));")
					op String RawSubArrayEndIndex();

					@GenModel(body="		int end = s.indexOf(\"]\");
		if(end == -1)
			throw new RuntimeException(
					\"In Raw Datatype column of monitor spreadsheet, subarray notation does not contain \\"]\\" (\"
					+ s + \")\");
		int start = s.indexOf(\"[\") + 1;
		if(start < 1)
			throw new RuntimeException(
					\"In Raw Datatype column of monitor spreadsheet, subarray notation does not start with \\"[\\" (\"
					+ s + \")\");

		String subString = s.substring(start, end);
		String interpretStrings[] = subString.split(\"-\");
		if(interpretStrings.length != 2)
			throw new RuntimeException(
					\"In Raw Datatype column of monitor spreadsheet, subarray notation does contain a range (\"
					+ s + \")\");
		int index = -1;
		try {
			if(startOrEnd == true)
				index = Integer.parseInt(interpretStrings[0]);
			else
				index = Integer.parseInt(interpretStrings[1]);
		}
		catch(NumberFormatException err) {
			throw new RuntimeException(
					\"In Raw Datatype column of monitor spreadsheet, subarray notation does not contain an integer as index (\"
					+ s
					+ \", \"
					+ interpretStrings[0]
					                   + interpretStrings[1] + \")\");
		}
		return index;")
					op int findRawSubArrayIndex(String s, boolean startOrEnd);

					@GenModel(body="		String s = WorldDataToDatabaseType();
		return Character.toUpperCase(s.charAt(0)) + s.substring(1);")
					op String WorldDataToDatabaseTypeUpper1();

					@GenModel(body="		String s = WorldDataType();
		return Character.toUpperCase(s.charAt(0)) + s.substring(1);")
					op String WorldDataTypeUpper1();

					@GenModel(body="this.tables = tables;
this.utils = utils;")
					op void setMandCAmb(base.Table tables, base.Util utils);

					@GenModel(body="this.row = row;
this.sheet = sheet;
this.mcp = mcp;")
					op void setMandCAmb(base.EStringArray row, int sheet, base.MandCBase mcp);
					attr base.EStringArray row;
					attr int sheet;
					attr base.EStringArray mask;
					ref base.MandCBase mcp;
					ref base.Table tables;
					ref base.Util utils;
				}

				class Monitor extends base.MonitorPoint {

					@GenModel(body="return row[tables.getColNum(sheet, \"Can Be Invalid\")];")
					op String CanBeInvalid();

					@GenModel(body="return CanBeInvalid().equals(\"yes-feStatus\");")
					op boolean IsFEStatus();

					@GenModel(body="return mac.Assembly();")
					op String Assembly();

					@GenModel(body="return mac.RCA();")
					op String RCA();

					@GenModel(body="return mac.RawDataType();")
					op String RawDataType();

					@GenModel(body="return mac.TeRelated();")
					op boolean TeRelated();

					@GenModel(body="return mac.WorldDataType();")
					op String WorldDataType();

					@GenModel(body="return mac.Scale();")
					op String Scale();

					@GenModel(body="return mac.Offset();")
					op String Offset();

					@GenModel(body="return mac.RawDataToCPPType();")
					op String RawDataToCPPType();

					@GenModel(body="return mac.WorldDataToCPPType();")
					op String WorldDataToCPPType();

					@GenModel(body="return mac.WorldDataToCORBAType();")
					op String WorldDataToCORBAType();

					@GenModel(body="return mac.WorldDataToIDLSeqType();")
					op String WorldDataToIDLSeqType();

					@GenModel(body="return mac.WorldDataToIDLType();")
					op String WorldDataToIDLType();

					@GenModel(body="return mac.WorldDataToCORBASeqType();")
					op String WorldDataToCORBASeqType();

					@GenModel(body="return mac.WorldDataToCORBADevIOType();")
					op String WorldDataToCORBADevIOType();

					@GenModel(body="return mac.WorldDataToJavaType();")
					op String WorldDataToJavaType();

					@GenModel(body="return mac.WorldDataToDatabaseType();")
					op String WorldDataToDatabaseType();

					@GenModel(body="return mac.WorldDataToBACIType();")
					op String WorldDataToBACIType();

					@GenModel(body="return mac.IsRawDataArray();")
					op boolean IsRawDataArray();

					@GenModel(body="return mac.IsWorldDataArray();")
					op boolean IsWorldDataArray();

					@GenModel(body="return mac.IsConversion();")
					op boolean IsConversion();

					@GenModel(body="return mac.IsSpecialConversion();")
					op boolean IsSpecialConversion();

					@GenModel(body="return mac.NumberItemsRawData();")
					op String NumberItemsRawData();

					@GenModel(body="return mac.TotalBytesRawData();")
					op String TotalBytesRawData();

					@GenModel(body="return mac.NumberRawDataTypeBytes();")
					op String NumberRawDataTypeBytes();

					@GenModel(body="return mac.RCACell();")
					op String RCACell();

					@GenModel(body="return mac.NumberItemsWorldData();")
					op String NumberItemsWorldData();

					@GenModel(body="return mac.TeRelatedCell();")
					op String TeRelatedCell();

					@GenModel(body="return mac.IsDependentGroupBit();")
					op boolean IsDependentGroupBit();

					@GenModel(body="return mac.IsDependentBit();")
					op boolean IsDependentBit();

					@GenModel(body="return mac.IsDependentElement();")
					op boolean IsDependentElement();

					@GenModel(body="return mac.IsByteSwapped();")
					op boolean IsByteSwapped();

					@GenModel(body="return mac.IsDependentBitElement();")
					op boolean IsDependentBitElement();

					@GenModel(body="return mac.IsDependentArrayElement();")
					op boolean IsDependentArrayElement();

					@GenModel(body="return mac.GetDimension();")
					op String GetDimension();

					@GenModel(body="return mac.IsSingleBit();")
					op boolean IsSingleBit();

					@GenModel(body="return mac.GetBit();")
					op String GetBit();

					@GenModel(body="return mac.GetMask();")
					op String GetMask();

					@GenModel(body="return mac.GetFirstBit();")
					op String GetFirstBit();

					@GenModel(body="return mac.GetLastBit();")
					op String GetLastBit();

					@GenModel(body="return mac.GetGroupMask();")
					op String GetGroupMask();

					@GenModel(body="return mac.GetGroupEnd();")
					op String GetGroupEnd();

					@GenModel(body="return mac.GetGroupStart();")
					op String GetGroupStart();

					@GenModel(body="return mac.RawSubArrayEndIndex();")
					op String RawSubArrayEndIndex();

					@GenModel(body="return mac.RawSubArrayStartIndex();")
					op String RawSubArrayStartIndex();

					@GenModel(body="return mac.IsRawSubArray();")
					op boolean IsRawSubArray();

					@GenModel(body="return mac.WorldDataToDatabaseTypeUpper1();")
					op String WorldDataToDatabaseTypeUpper1();

					@GenModel(body="return mac.WorldDataTypeUpper1();")
					op String WorldDataTypeUpper1();

					@GenModel(body="return utils.normalizeNumber(WorldDataType(), super.MinRange());")
					op String MinRange();

					@GenModel(body="return utils.normalizeNumber(WorldDataType(), super.MaxRange());")
					op String MaxRange();

					@GenModel(body="return utils.normalizeNumber(WorldDataType(), super.Default());")
					op String Default();

					@GenModel(body="boolean ret = true;
				if(this.IsDependent()) 
					ret = false;
				if (this.getDependents().getContents().isEmpty())
					ret = false;		
				for (Iterator iter = this.getDependents().getContents().iterator(); iter.hasNext(); ) {
					Monitor var = (Monitor) iter.next();
					if(var.WorldDataType().compareTo(\"boolean\") != 0){
						ret = false;
					}		
				}
				if(ret)System.out.println(\"IsPattern(): \"+ret+\"\");
				return ret;")
					op boolean IsPattern();

					@GenModel(body="boolean ret = false;
				if(IsDependent()){
					Monitor parent = (Monitor)this.getParent();
					if(parent.IsPattern())
						ret = true;
				}
				return ret;")
					op boolean IsPartOfPattern();

					@GenModel(body="	boolean ret = true;
				String firsttype = null;
				if(hasDependents()){
					for (Iterator<EObject> iter = this.getDependents().getContents().iterator(); iter.hasNext(); ) {
						Monitor var = (Monitor) iter.next();
						if( firsttype == null){
							firsttype = new String(var.WorldDataType());
							continue;
						}if(var.WorldDataType().equals(firsttype)) 
							ret = false;
					}
				}else{
					ret = false;
				}
				return ret;")
					op boolean IsHomogeneous();

					@GenModel(body="	boolean ret = false;
				if(IsDependent()){
					Monitor parent = ((Monitor)this.getParent());
					if(parent.IsHomogeneous())
						ret = true;
				}
				return ret;	")
					op boolean IsPartOfHomogeneous();

					@GenModel(body="this.tables = tables;
this.utils = utils;")
					op void setMonitorAmb(base.Table tables, base.Util utils);

					@GenModel(body="this.row = row;
this.parent = parent;
super.setMonitorPoint(row, parent);
mac = AmbFactory.eINSTANCE.createMandC();
mac.setMandCAmb(tables, utils);
mac.setMandCAmb(row, sheet, this);")
					op void setMonitorAmb(base.EStringArray row, EObject parent);
					ref MandC mac;
				}

			}

			@namespace(uri="http://alma/Control/datamodel/meta/base/1.0", prefix="alma.Control.datamodel.meta.base")
			package base {
				class ArchiveProperty {

					@GenModel(body="return mp != null || cp !=null;")
					op boolean IsRefersTo();

					@GenModel(body="return mp != null;")
					op boolean IsMonitorPoint();

					@GenModel(body="return cp != null;")
					op boolean IsControlPoint();

					@GenModel(body="return row[tables.getColNum(sheet, \"Name\")];")
					op String Name();

					@GenModel(body="	String name = Name();
							if (name.startsWith(tables.getDepChar()))
							name = name.substring(1);
						return name;")
					op String APName();

					@GenModel(body="return row[tables.getColNum(sheet,  \"Refers To\")];")
					op String RefersTo();

					@GenModel(body="return row[tables.getColNum(sheet,  \"Interval (secs)\")];")
					op String IntervalFull();

					@GenModel(body="return row[tables.getColNum(sheet, \"Interval (secs)\")];")
					op String Interval();

					@GenModel(body="return row[tables.getColNum(sheet, \"Only On Change\")].equals(\"yes\");")
					op boolean OnlyOnChange();

					@GenModel(body="return row[tables.getColNum(sheet, \"Display Units\")];")
					op String DisplayUnits();

					@GenModel(body="return row[tables.getColNum(sheet, \"Graph Min\")];")
					op String GraphMin();

					@GenModel(body="return row[tables.getColNum(sheet, \"Graph Max\")];")
					op String GraphMax();

					@GenModel(body="return row[tables.getColNum(sheet, \"Format\")];")
					op String Format();

					@GenModel(body="return row[tables.getColNum(sheet, \"On Startup\")].equals(\"yes\");")
					op boolean OnStartup();

					@GenModel(body="return row[tables.getColNum(sheet, \"Title\")];")
					op String Title();

					@GenModel(body="this.row = row;
this.tables = tables;
this.sheet = tables.getSheetNum(\"Archive Property\");")
					op void setArchiveProperty(EStringArray row, Table tables);
					derived attr EStringArray row;
					attr int sheet;
					ref ControlPoint cp;
					ref MonitorPoint mp;
					ref Table tables;
				}

				abstract class ControlPoint extends MandCBase {

					@GenModel(body="return PName();")
					op String CPName();

					@GenModel(body="return AltPName();
")
					op String AltCPName();

					@GenModel(body="return row[tables.getColNum(sheet, \"Archive On Use\")].equals(\"yes\");")
					op boolean ArchiveOnUse();

					@GenModel(body="return false;
")
					op boolean IsMonitored();

					@GenModel(body="this.tables = tables;
this.utils = utils;")
					op void setControlPoint(Table tables, Util utils);

					@GenModel(body="this. row = row;
this.parent = parent;
super.setMandCBase(row, parent);")
					op void setControlPoint(EStringArray row, EObject parent);
				}

				abstract class DeviceModel {
					op String CreateModel();

					@GenModel(body="return main.Assembly();")
					op String Assembly();

					@GenModel(body="return main.Extends();")
					op String Extends();

					@GenModel(body="return main.DeviceName();")
					op String DeviceName();

					@GenModel(body="return main.Description();")
					op String Description();

					@GenModel(body="return main.DescriptionAsString();")
					op String DescriptionAsString();

					@GenModel(body="return main.ICD();")
					op String ICD();

					@GenModel(body="return main.ICDDate();")
					op String ICDDate();

					@GenModel(body="return main.ICDDateAsDatabaseDate();")
					op String ICDDateAsDatabaseDate();

					@GenModel(body="return main.ICDDateAsArrayTime();")
					op String ICDDateAsArrayTime();

					@GenModel(body="return Assembly();
")
					op String DirPath();

					@GenModel(body="String dir = generatedDir + \"/\" + Assembly();
				utils.RemoveLinesFromFile(dir + \"/src\", Assembly() + \"Base.cpp\", 1);
				utils.RemoveLinesFromFile(dir + \"/include\", Assembly() + \"Base.h\", 1);
				utils.RemoveLinesFromFile(dir + \"/idl\", Assembly() + \"Base.idl\", 1);
				utils.RemoveLinesFromFile(dir + \"/idl\", Assembly() + \"Add.sql\", 1);
				utils.RemoveLinesFromFile(dir + \"/doc\", Assembly() + \".xml\", 1);
				utils.RemoveLinesFromFile(dir + \"/doc\", Assembly() + \"Component.xml\", 1);
				utils.RemoveLinesFromFile(dir + \"/config/CDB/schemas\", Assembly() + \"Base.xsd\", 1);
				utils.RemoveLinesFromFile(dir + \"/config\", \"TMCDB\" + Assembly() + \"Add.xml\", 1);
				utils.RemoveLinesFromFile(dir + \"/src/CCL\", Assembly() + \"Base.py\", 1);
				utils.RemoveLinesFromFile(dir + \"/src/CCL\", \"__init__.py\", 1);
				System.out.println(\"Code generation for \" + deviceName + \" done.\");
				return \"\";")
					op String TheEnd();

					@GenModel(body="java.io.File f = new java.io.File(fileName);
if(f.exists() == true){	return true;
 }else{
	return false;
          }")
					op boolean checkIfFileExists(String fileName);

					@GenModel(body="if(directory.isEmpty() == false){
	return checkIfFileExists(directory + \"/\" + fileName);
} else{
        return checkIfFileExists(fileName);
          }")
					op boolean checkIfFileExists(String directory, String fileName);

					@GenModel(body="String fileName = getDeviceDir() + \"/\" + directory + \"/\" + Assembly() + localFileName;
return checkIfFileExists(fileName);")
					op boolean checkIfDeviceFileExists(String directory, String localFileName);

					@GenModel(body="String fileName = getDeviceDir() + \"/\" + directory + \"/Test\" + Assembly() + localFileName;
return checkIfFileExists(fileName);")
					op boolean checkIfTestFileExists(String directory, String localFileName);

					@GenModel(body="String fileName = getDeviceDir() + \"/\" + directory + \"/.cvsignore\";
return checkIfFileExists(fileName);")
					op boolean checkIfCvsignoreFileExists(String directory);

					@GenModel(body="this.setDeviceName(System.getProperty(\"deviceName\"));
this.setDeviceDir(System.getProperty(\"deviceDir\"));
this.setCodegenDir(System.getProperty(\"codegenDir\"));
this.setSpreadsheetDir(System.getProperty(\"spreadsheetDir\"));
this.setGeneratedDir(System.getProperty(\"generatedDir\"));")
					op void setDeviceModel();
					attr int DescriptionIndex = 1;
					attr EStringArray3 spreadsheet;
					transient attr EResourceSet container;
					transient attr EResource notes;
					transient attr EResource monitorPoints;
					transient attr EResource controlPoints;
					transient attr EResource archiveProperties;
					attr String deviceName;
					attr String busType;
					attr String deviceDir;
					attr String codegenDir;
					attr String spreadsheetDir;
					attr String generatedDir;
					attr boolean monitorDBOnly;
					attr boolean generateAlt;
					val MainBase main;
					ref Table tables;
					ref Util utils;
				}

				class MainBase {

					@GenModel(body="return row[tables.getColNum(sheet, \"Assembly\")];")
					op String Assembly();

					@GenModel(body="return row[tables.getColNum(sheet, \"Description\")];")
					op String Description();

					@GenModel(body="return utils.descriptionAsString(Description());")
					op String DescriptionAsString();

					@GenModel(body="return row[tables.getColNum(sheet, \"Device Name\")];")
					op String DeviceName();

					@GenModel(body="return row[tables.getColNum(sheet, \"Extends\")];")
					op String Extends();

					@GenModel(body="return row[tables.getColNum(sheet, \"ICD\")];")
					op String ICD();

					@GenModel(body="return row[tables.getColNum(sheet, \"ICD Date\")];")
					op String ICDDate();

					@GenModel(body="return utils.toDatabaseDate(ICDDate());")
					op String ICDDateAsDatabaseDate();

					@GenModel(body="return utils.toArrayTime(ICDDate());")
					op String ICDDateAsArrayTime();

					@GenModel(body="this.tables = tables;
this.utils = utils;")
					op void setMainBase(Table tables, Util utils);

					@GenModel(body="this.row = row;
this.sheet = tables.getSheetNum(\"Hardware Device\");")
					op void setMainBase(EStringArray row);
					attr EStringArray row;
					attr int sheet;
					ref Table tables;
					ref Util utils;
				}

				abstract class MandCBase {

					@GenModel(body="dependents.getContents().add(son);
container.getResources().add(dependents);")
					op void addDependent(EObject son);

					@GenModel(body="			if (getParent() == null){
				//	System.out.println(\"no tiene padre\");
					return false;
				}
				//System.out.println(\"si tiene padre\");
				return true;")
					op boolean IsDependent();

					@GenModel(body="return !dependents.getContents().isEmpty();")
					op boolean hasDependents();

					@GenModel(body="return row[tables.getColNum(sheet, \"Name\")];")
					op String FullName();

					@GenModel(body="if(IsDependent())
					return row[tables.getColNum(sheet, \"Name\")].substring(1);
				else
					return row[tables.getColNum(sheet, \"Name\")];")
					op String Name();

					@GenModel(body="return Name();
")
					op String GetDependentName();

					@GenModel(body="return utils.AltName(GetDependentName());")
					op String GetAltDependentName();

					@GenModel(body="if(!IsDependent())
			return \"\";
		return ((MandCBase)getParent()).Name();")
					op String GetDependsOnName();

					@GenModel(body="		return utils.AltName(((MandCBase)getParent()).Name());")
					op String GetAltDependsOnName();

					@GenModel(body="return row[tables.getColNum(sheet, \"Data Units\")];")
					op String DataUnits();

					@GenModel(body="return row[tables.getColNum(sheet, \"Min Range\")];")
					op String MinRange();

					@GenModel(body="return row[tables.getColNum(sheet, \"Max Range\")];")
					op String MaxRange();

					@GenModel(body="return row[tables.getColNum(sheet, \"Mode\")];")
					op String Mode();

					@GenModel(body="return row[tables.getColNum(sheet, \"Implement\")].equals(\"yes\");")
					op boolean Implement();

					@GenModel(body="return row[tables.getColNum(sheet, \"External\")].equals(\"yes\");")
					op boolean External();

					@GenModel(body="return row[tables.getColNum(sheet, \"Description\")];")
					op String Description();

					@GenModel(body="return External();")
					op boolean IsExternal();

					@GenModel(body="return true;")
					op boolean IsArchived();

					@GenModel(body="return Implement();")
					op boolean IsImplemented();

					@GenModel(body="return new RuntimeException(spreadsheetName +\":\"+ sheetName +\":\"+ cell +\":\"+ err.toString());")
					op RuntimeExceptionDT dErr(RuntimeExceptionDT err, String cell);

					@GenModel(body="return new RuntimeException(spreadsheetName +\":\"+ sheetName +\":\"+ cell +\":\"+ err);")
					op RuntimeExceptionDT dErr(String err, String cell);

					@GenModel(body="if (s.startsWith(\"GET_\") || s.startsWith(\"SET_\"))
	return s.substring(4);
return s;")
					op String dropPrefix(String s);

					@GenModel(body="		if (Name().startsWith(tables.getDepChar()))
			return dropPrefix(Name().substring(1));
		return dropPrefix(Name());")
					op String PName();

					@GenModel(body="	if (Name().startsWith(\"SET_\"))
			return \"Cntl\" + utils.AltName(PName()); 
		return utils.AltName(PName());")
					op String AltPName();

					@GenModel(body="return utils.descriptionAsString(Description());")
					op String DescriptionAsString();

					@GenModel(body="return utils.formatDescriptionL2(Description());")
					op String DescriptionFormatted();

					@GenModel(body="return utils.formatDescriptionL4(Description());")
					op String DescriptionFormattedL4();

					@GenModel(body="return utils.formatDescriptionL5(Description());")
					op String DescriptionFormattedL5();
					op boolean IsMonitored();

					@GenModel(body="this.tables = tables;
this.utils = utils;")
					op void setMandCBase(Table tables, Util utils);

					@GenModel(body="this.row = row;
this.parent = parent;
dependents = container.createResource(URI.createURI(\"\"));
sheet = (this instanceof MonitorPoint) ? tables.getSheetNum(\"Monitor Point\") : tables.getSheetNum(\"Control Point\");")
					op void setMandCBase(EStringArray row, EObject parent);
					attr String spreadsheetName = "Not needed";
					transient attr EResourceSet container;
					transient id attr EResource dependents;
					transient attr EObjectDT parent;
					ref ArchiveProperty archive;
					attr String sheetName;
					attr EStringArray row;
					attr int sheet;
					val MandCBase[*] manc;
					ref Table tables;
					ref Util utils;
				}

				abstract class MonitorPoint extends MandCBase {

					@GenModel(body="return row[tables.getColNum(sheet, \"Default\")];")
					op String Default();

					@GenModel(body="return row[tables.getColNum(sheet, \"Error Condition\")];")
					op String ErrorCondition();

					@GenModel(body="return row[tables.getColNum(sheet, \"Error Severity\")];")
					op String ErrorSeverity();

					@GenModel(body="return row[tables.getColNum(sheet, \"Error Action\")];")
					op String ErrorAction();

					@GenModel(body="return PName();")
					op String APName();

					@GenModel(body="return PName();")
					op String RefersTo();

					@GenModel(body="	int defaultValue = 300;
				if(archive != null) {
					if ( ((ArchiveProperty)archive).Interval().equals(\"none\") )
						return Integer.toString(defaultValue);
					int value = Integer.valueOf(((ArchiveProperty)archive).Interval());
					if (value <= 0)
						value = defaultValue;
					return Integer.toString(value);
				}
				else
					return Integer.toString(defaultValue);")
					op String Interval();

					@GenModel(body="	if(archive != null)
					return ((ArchiveProperty)archive).OnlyOnChange();
				else
					return false;")
					op boolean OnlyOnChange();

					@GenModel(body="if(archive != null)
					return ((ArchiveProperty)archive).DisplayUnits();
				else
					return DataUnits();")
					op String DisplayUnits();

					@GenModel(body="		if(archive != null)
					return ((ArchiveProperty)archive).GraphMin();
				else
					return \"none\";")
					op String GraphMin();

					@GenModel(body="	if(archive != null)
					return ((ArchiveProperty)archive).GraphMax();
				else
					return \"none\";")
					op String GraphMax();

					@GenModel(body="				if(archive != null)
					return ((ArchiveProperty)archive).Format();
				else
					return \"none\";")
					op String Format();

					@GenModel(body="				if(archive != null)
					return ((ArchiveProperty)archive).Title();
				else
					return Description();")
					op String Title();

					@GenModel(body="return PName();
")
					op String MPName();

					@GenModel(body="return AltPName();
")
					op String AltMPName();

					@GenModel(body="return true;")
					op boolean IsMonitored();
					op boolean IsPartOfPattern();
					op boolean IsHomogeneous();
					op boolean IsPartOfHomogeneous();

					@GenModel(body="this.tables = tables;
this.utils = utils;")
					op void setMonitorPoint(Table tables, Util utils);

					@GenModel(body="this. row = row;
this.parent = parent;
super.setMandCBase(row, parent);")
					op void setMonitorPoint(EStringArray row, EObject parent);
				}

				class Note {
					attr String note = "";
				}

				abstract class Pair extends SpreadsheetParser {

					@GenModel(body="content = c;
newString = n;")
					op void setPair(String c, String n);
					attr String content;
					attr String newString;
				}

				class SimpleErrorHandler extends ErrorHandlerAuxClass {

					@GenModel(body="System.out.println(\"error: line \"+ exception.getLineNumber() + \": \" + exception.getMessage());
errors = true;")
					op void error(SAXParseExceptionDT exception);

					@GenModel(body="System.out.println(\"fatalError: line \"+ exception.getLineNumber() + \": \" + exception.getMessage());
errors = true;")
					op void fatalError(SAXParseExceptionDT exception);

					@GenModel(body="System.out.println(\"warning: line \"+ exception.getLineNumber() + \": \" + exception.getMessage());
errors = true;")
					op void warning(SAXParseExceptionDT exception);

					@GenModel(body="return errors;")
					op boolean areErrors();
					attr boolean errors = false;
				}

				class SpreadsheetParser {

					@GenModel(body="		java.io.File dir = new java.io.File(dirName);
		if (!dir.isDirectory())
			throw new RuntimeException (\"Directory \" + dirName + \" does not exist.\");
		java.io.File file = new java.io.File(dir, fileName);
		if (!file.exists())
			throw new RuntimeException (\"File \" + fileName + \" in directory \" + dirName + \" does not exist.\");
		java.io.BufferedReader in = null;
		StringBuffer xmlDoc = null;
		String line = null;
		try {
			in = new java.io.BufferedReader(new java.io.FileReader(file));
			//Read the entire file and store in it xmlDoc.
			xmlDoc = new StringBuffer();
			line = in.readLine();
			while (line != null) {
				xmlDoc.append(line + newline);
				//xmlDoc.append(line);
				line = in.readLine();
			}
			in.close();
		} catch (java.io.IOException e) {
			throw new RuntimeException(e.getMessage());
		}
		String xml = new String(xmlDoc);
		// Now, the entire xml file is in the string: xml.
		return xml;")
					op String getSpreadsheet(String dirName, String fileName);

					@GenModel(body="		int b1 = s.indexOf(beginPart1);
		if (b1 == -1)
			return null;
		int b2 = s.indexOf(beginPart2,b1);
		if (b2 == -1)
			return null;
		int e = s.indexOf(end,b2);
		if (e == -1)
			return null;
		String content = s.substring(b2 + 1,e).trim();
		int n = e + end.length();
		String newS = null;
		if (n < s.length())
			newS = s.substring(n);
		PairImpl pp = new PairImpl() {};
		pp.setPair(content,newS);
		return pp;")
					op Pair getBoundedContent(String s, String beginPart1, String beginPart2, String end);

					@GenModel(body="ArrayList list = new ArrayList ();
		String data = null;
		String content = null;
		while (row != null && row.length() > 0) {
			Pair p = getBoundedContent(row,\"<Cell\",\">\",\"</Cell>\");
			if (p == null)
				break;
			data = p.getContent();
			row = p.getNewString();
			p = getBoundedContent(data,\"<Data\",\">\",\"</Data>\");
			if (p == null)
				continue;
			content = p.getContent();
			list.add(content);
		}
		if(list.size() == 0)
			return null;
		String[] x = new String [list.size()];
		return (String[])list.toArray(x);")
					op EStringArray getDataCells(String row);

					@GenModel(body="ArrayList rowList = null;
		ArrayList sheetList = null;
		String sheet = null;
		String row = null;
		String[] data = null;
		sheetList = new ArrayList ();
		String doc = new String (xml);
		if (doc.startsWith(\"@reference\")) {
			refStatus = true;
			return filter(doc);
		}
		Pair p = null;
		while (doc != null && doc.length() > 0) {
			p = getBoundedContent(doc,\"<Worksheet\",\">\",\"</Worksheet>\");
			if (p == null)
				break;
			sheet = p.getContent();
			doc = p.getNewString();
			rowList = new ArrayList ();
			while (sheet != null && sheet.length() > 0) {
				Pair p2 = getBoundedContent(sheet,\"<Row\",\">\",\"</Row>\");
				if (p2 == null)
					break;
				row = p2.getContent();
				sheet = p2.getNewString();
				data = getDataCells(row);
				if (data != null)
					rowList.add(data);
			}
			sheetList.add(rowList);
		}

		if(p == null){
			doc = new String(xml);
			while (doc != null && doc.length() > 0) {
				p = getBoundedContent(doc,\"<ss:Worksheet\",\">\",\"</ss:Worksheet>\");
				if(p == null)
					break;
				sheet = p.getContent();
				doc = p.getNewString();
				rowList = new ArrayList ();
				while (sheet != null && sheet.length() > 0) {
					Pair p2 = getBoundedContent(sheet,\"<Row\",\">\",\"</Row>\");
					if (p2 == null)
						break;
					row = p2.getContent();
					sheet = p2.getNewString();
					data = getDataCells(row);
					if (data != null)
						rowList.add(data);
				}
				sheetList.add(rowList);
			}
		}


		String[][][] result = new String [sheetList.size()][][];
		for (int i = 0; i < result.length; ++i) {
			ArrayList x = (ArrayList)sheetList.get(i);
			result[i] = new String [x.size()][];
			for (int j = 0; j < result[i].length; ++j) {
				String[] y = (String[])x.get(j);
				result[i][j] = new String [y.length];
				for (int k = 0; k < y.length; ++k)
					result[i][j][k] = y[k];
			}
		}
		return result;")
					op EStringArray3 getWorksheets();

					@GenModel(body="return refStatus;
")
					op boolean isReference();

					@GenModel(body="return refPath;")
					op String getReference();

					@GenModel(body="xsdFile = xsd;")
					op void setXSD(String xsd);

					@GenModel(body="// A. Get the directory that is referenced, and the old and new assembly names.
						// Syntax: @reference = <base-directory-path-name> <base-assembly-name> = <new-assembly-name>
						java.io.LineNumberReader text = new java.io.LineNumberReader(new java.io.StringReader(doc));
						String line = null;
						try {
							line = text.readLine();
						} catch (java.io.IOException err) {
							throw new RuntimeException(\"Cannot read file: \" + err.toString());
						}
						String[] tmp = line.split(\"[ |\t]+\");
						if (!tmp[0].equals(\"@reference\") || !tmp[1].equals(\"=\") || !tmp[4].equals(\"=\")) {
							throw new RuntimeException(\"Invalid syntax at line number \" + text.getLineNumber() + \" in file filter.\");
						}
						String baseDirectory = tmp[2];
						String baseAssemblyName = tmp[3];
						String newAssemblyName = tmp[5];
						System.out.println(\"Applying filter in directory \" + baseDirectory + 
								\" to assembly \" + baseAssemblyName + \".  New assembly is \" + newAssemblyName + \".\");
				
						// B. Get the contents of this base spreadsheet.
						BaseFactory baseFac = BaseFactory.eINSTANCE;
						String referenceXml = baseFac.createSpreadsheetParser().getSpreadsheet(baseDirectory, baseAssemblyName + \"_spreadsheet.xml\");
						refPath = baseDirectory + \"/\" + baseAssemblyName + \"_spreadsheet.xml\";
						SpreadsheetParser p = baseFac.createSpreadsheetParser();
						p.setSpreadsheetParser(referenceXml);
						SpreadsheetValidator v = baseFac.createSpreadsheetValidator();
						if (!v.validate(refPath,xsdFile)) {
							String s = \"Spreadsheet \" + baseAssemblyName + \"_spreadsheet.xml is not a valid spreadsheet.\";
							throw new RuntimeException(s);
						}
						System.out.println(\"Base spreadsheet \" + baseAssemblyName + \" has been validated.\");
						String[][][] base = p.getWorksheets();
				
						// C. Change the assembly name in the base spreadsheet.
						for (int i = 0; i < base.length; ++i) {
							for (int j = 0; j < base[i].length; ++j) {
								if (base[i][j][0].equals(baseAssemblyName)) {
									base[i][j][0] = newAssemblyName;
								}
							}
						}
				
						// D. Apply the filter to the base.
						//    Any deleted rows we will simply make null.
						String[][] worksheet = null;
						while (true) {
							try {
								line = text.readLine();
							} catch (java.io.IOException err) {
								throw new RuntimeException(\"Cannot read file: \" + err.toString());
							}
							if (line == null)
								break;
							if (line.trim().length() == 0)
								continue;
							if (line.startsWith(\"Main\"))
								worksheet = base[0];
							else if (line.startsWith(\"EndMain\"))
								worksheet = null;
							else if (line.startsWith(\"Monitor\"))
								worksheet = base[1];
							else if (line.startsWith(\"EndMonitor\"))
								worksheet = null;
							else if (line.startsWith(\"Control\"))
								worksheet = base[2];
							else if (line.startsWith(\"EndControl\"))
								worksheet = null;
							else if (line.startsWith(\"Archive\"))
								worksheet = base[3];
							else if (line.startsWith(\"EndArchive\"))
								worksheet = null;
							else {
								if (worksheet == null)
									throw new RuntimeException(\"Invalid syntax at line number \" + text.getLineNumber() + \" in file filter. (Missing statement)\");
								tmp = line.split(\"[ |\t]+\");
								if (line.startsWith(\"~\")) {
									deleteRow(worksheet,tmp[0].substring(1));
								} else {
									String s = line.substring(tmp[0].length());
									modifyRow(worksheet,text.getLineNumber(),tmp[0],s);
								}
							}
						}
				
						// E. Assign the non-null array.
						String[][][] result = new String [base.length] [] [];
						for (int i = 0; i < result.length; ++i) {
							int nrow = 0;
							for (int j = 0; j < base[i].length; ++j) {
								if (base[i][j] != null)
									++nrow;
							}
							result[i] = new String [nrow] [];
							int jj = 0;
							for (int j = 0; j < base[i].length; ++j) {
								if (base[i][j] != null) {
									result[i][jj] = new String [base[i][j].length];
									for (int k = 0; k < base[i][j].length; ++k)
										result[i][jj][k] = base[i][j][k];
									++jj;
								}
							}
						}
				
						// F. Return the new spreadsheet. 
						return result;")
					op EStringArray3 filter(String doc);

					@GenModel(body="if (worksheet[0][0].equals(\"Hardware Device\")) {
			for (int i = 2; i < worksheet.length; ++i) {
				if (worksheet[i] == null)
					continue;
				if (worksheet[i][0].equals(name)) {
					worksheet[i] = null;
					return;
				}
			}
			throw new RuntimeException(\"The name \" + name + \" is not the name of a row in the Main worksheet.\");
		}
		for (int i = 2; i < worksheet.length; ++i) {
			if (worksheet[i] == null)
				continue;
			if (worksheet[i][1].equals(name)) {
				worksheet[i] = null;
				return;
			}
		}		
		throw new RuntimeException(\"The name \" + name + \" is not the name of a row in the \" + worksheet[0][0] + \" worksheet.\");")
					op void deleteRow(EStringArray2 worksheet, String name);

					@GenModel(body="		// Find the row.
		int row = 0;
		if (worksheet[0][0].equals(\"Hardware Device\")) {
			int i = 2;
			for (; i < worksheet.length; ++i) {
				if (worksheet[i] == null)
					continue;
				if (worksheet[i][0].equals(rowName)) {
					row = i;
					break;
				}
			}
			if (i == worksheet.length)
				throw new RuntimeException(\"The name \" + rowName + \" is not the name of a row in the Main worksheet.\");
		} else {
			int i = 2;
			for (; i < worksheet.length; ++i) {
				if (worksheet[i] == null)
					continue;
				if (worksheet[i][1].equals(rowName)) {
					row = i;
					break;
				}
			}
			if (i == worksheet.length)
				throw new RuntimeException(\"The name \" + rowName + \" is not the name of a row in the \" + worksheet[0][0] + \" worksheet.\");
		}
		String name;
		String value;
		int b;
		int m;
		int e;        				
		while(true) {
			b = s.indexOf('<');
			m = s.indexOf('=');
			e = s.indexOf('>');
			if (b == -1 || m == -1 || e == -1 || m < b || e < m) {
				throw new RuntimeException(\"Invalid syntax at line number \" + lineNumber + \" in file filter.\");
			}
			name = s.substring(b + 1, m).trim();
			value = s.substring(m + 1, e).trim();
			// Apply the change.
			int j = 0;
			for (; j < worksheet[row].length; ++j) {
				if (worksheet[1][j].equals(name)) {
					worksheet[row][j] = value;
					break;
				}
			}
			if (j == worksheet[row].length)
				throw new RuntimeException(\"The name \" + name + \" is not the name of a column in the \" + worksheet[0][0] + \" worksheet.\");
			// Get the next change.
			++e;
			while (e < s.length() && (s.charAt(e) == ' ' || s.charAt(e) == '\t'))
				++e;
			if (e == s.length())
				break;
			s = s.substring(e);
		}")
					op void modifyRow(EStringArray2 worksheet, int lineNumber, String rowName, String s);

					@GenModel(body="this.xml = xml;")
					op void setSpreadsheetParser(String xml);
					attr String refPath;
					attr boolean refStatus = false;
					attr String xml;
					attr String xsdFile;
					attr String newline = "";
				}

				class SpreadsheetValidator {

					@GenModel(body="				javax.xml.parsers.DocumentBuilderFactory factory = javax.xml.parsers.DocumentBuilderFactory.newInstance();
				factory.setNamespaceAware(true);
				factory.setValidating(true);
				factory.setAttribute(
						\"http://java.sun.com/xml/jaxp/properties/schemaLanguage\",
						\"http://www.w3.org/2001/XMLSchema\");
				// Specify our own schema - this overrides the schemaLocation in the xml
				// file
				factory.setAttribute(
						\"http://java.sun.com/xml/jaxp/properties/schemaSource\",
						\"file://\" + xsdFile);
				seh = BaseFactory.eINSTANCE.createSimpleErrorHandler();
		
				try {
					javax.xml.parsers.DocumentBuilder builder = factory.newDocumentBuilder();
					builder.setErrorHandler(seh);
					org.w3c.dom.Document document = builder.parse(xmlFile);
				}
				catch(Exception e) {
					System.out.println(\"Validating error file \" + xmlFile
							+ \" with schema file \" + xsdFile + \" failed!\");
					return false;
				}
		
				if(seh.areErrors()) {
					System.out.println(\"Validating error file \" + xmlFile
							+ \" with schema file \" + xsdFile + \" failed!\");
					return false;
				}
				else {
					return true;
				}")
					op boolean validate(String xmlFile, String xsdFile);

					@GenModel(body="this.errorList = new ArrayList< String >();
")
					op void setSpreadsheetValidator();
					attr SimpleErrorHandlerDT seh;
					transient attr ArrayList errorList;
					attr ErrorHandlerDT sehTmp;
				}

				class Table {

					@GenModel(body="int i;
	for(i = 0; i < sheetNames.size(); i++)
		if(((String)sheetNames.get(i)).compareTo(name) == 0)
			return i;
	return -1;")
					op int getSheetNum(String name);

					@GenModel(body="int i;
for(i = 0; i < ((ArrayList)colNames.get(sheet)).size(); i++)
	if(((String)((ArrayList)colNames.get(sheet)).get(i)).compareTo(name) == 0)
		return i;
	return -1;")
					op int getColNum(int sheet, String name);

					@GenModel(body="sheetNames.add(name);
colNames.add(new ArrayList());")
					op void addSheet(String name);

					@GenModel(body="((ArrayList)colNames.get(sheet)).add(name);
")
					op void addCol(int sheet, String name);

					@GenModel(body="		int i, j;
		sheetNames = new ArrayList();
		colNames = new ArrayList();
		for(i = 0; i < sh.length; i++){
			addSheet(sh[i][0][0]);
			for(j = 0; j < sh[i][1].length; j++){
				addCol(i, sh[i][1][j]);
			}
		}
		toCPP = new Hashtable();
		toCPP.put(\"char\", \"char\");
		toCPP.put(\"short\", \"short\");
		toCPP.put(\"int\", \"int\");
		toCPP.put(\"long long\", \"long long\");
		toCPP.put(\"float\", \"float\");
		toCPP.put(\"double\", \"double\");
		toCPP.put(\"bool\", \"bool\");
		toCPP.put(\"string\", \"char *\");
		toCPP.put(\"void\", \"void\");

		toIDL = new Hashtable();
		toIDL.put(\"char\", \"long\");
		toIDL.put(\"short\", \"long\");
		toIDL.put(\"int\", \"long\");
		toIDL.put(\"long long\", \"long long\");
		toIDL.put(\"float\", \"float\");
		toIDL.put(\"double\", \"double\");
		toIDL.put(\"bool\", \"boolean\");
		toIDL.put(\"string\", \"string\");
		toIDL.put(\"void\", \"void\");

		toIDLSeq = new Hashtable();
		toIDLSeq.put(\"char\", \"Control::LongSeq\");
		toIDLSeq.put(\"short\", \"Control::LongSeq\");
		toIDLSeq.put(\"int\", \"Control::LongSeq\");
		toIDLSeq.put(\"long long\", \"Control::LongLongSeq\");
		toIDLSeq.put(\"float\", \"Control::FloatSeq\");
		toIDLSeq.put(\"double\", \"Control::DoubleSeq\");
		toIDLSeq.put(\"bool\", \"Control::BooleanSeq\");
		toIDLSeq.put(\"string\", \"Control::StringSeq\");
		toIDLSeq.put(\"void\", \"NOTHING\");

		toCORBA = new Hashtable();
		toCORBA.put(\"char\", \"CORBA::Long\");
		toCORBA.put(\"short\", \"CORBA::Long\");
		toCORBA.put(\"int\", \"CORBA::Long\");
		toCORBA.put(\"long long\", \"CORBA::LongLong\");
		toCORBA.put(\"float\", \"CORBA::Float\");
		toCORBA.put(\"double\", \"CORBA::Double\");
		toCORBA.put(\"bool\", \"CORBA::Boolean\");
		toCORBA.put(\"string\", \"char *\");
		toCORBA.put(\"void\", \"void\");

		toCORBADevIO = new Hashtable();
		toCORBADevIO.put(\"char\", \"CORBA::Long\");
		toCORBADevIO.put(\"short\", \"CORBA::Long\");
		toCORBADevIO.put(\"int\", \"CORBA::Long\");
		toCORBADevIO.put(\"long long\", \"CORBA::LongLong\");
		toCORBADevIO.put(\"float\", \"CORBA::Float\");
		toCORBADevIO.put(\"double\", \"CORBA::Double\");
		toCORBADevIO.put(\"bool\", \"CORBA::Boolean\");
		toCORBADevIO.put(\"string\", \"CORBA::String\");
		toCORBADevIO.put(\"void\", \"NOTHING\");

		toCORBASeq = new Hashtable();
		toCORBASeq.put(\"char\", \"Control::LongSeq\");
		toCORBASeq.put(\"short\", \"Control::LongSeq\");
		toCORBASeq.put(\"int\", \"Control::LongSeq\");
		toCORBASeq.put(\"long long\", \"Control::LongLongSeq\");
		toCORBASeq.put(\"float\", \"Control::FloatSeq\");
		toCORBASeq.put(\"double\", \"Control::DoubleSeq\");
		toCORBASeq.put(\"bool\", \"Control::BooleanSeq\");
		toCORBASeq.put(\"string\", \"Control::StringSeq\");
		toCORBASeq.put(\"void\", \"NOTHING\");

		toBACI = new Hashtable();
		toBACI.put(\"char\", \"long\");
		toBACI.put(\"short\", \"long\");
		toBACI.put(\"int\", \"long\");
		toBACI.put(\"long long\", \"longLong\");
		toBACI.put(\"float\", \"float\");
		toBACI.put(\"double\", \"double\");
		toBACI.put(\"bool\", \"boolean\");
		toBACI.put(\"string\", \"string\");
		toBACI.put(\"void\", \"void\");

		toDatabase = new Hashtable();
		toDatabase.put(\"char\", \"char\");
		toDatabase.put(\"short\", \"integer\");
		toDatabase.put(\"int\", \"integer\");
		toDatabase.put(\"long long\", \"integer\");
		toDatabase.put(\"float\", \"float\");
		toDatabase.put(\"double\", \"double\");
		toDatabase.put(\"bool\", \"boolean\");
		toDatabase.put(\"string\", \"string\");
		toDatabase.put(\"void\", \"-none-\");

		rawToCPP = new Hashtable();
		rawToCPP.put(\"bit\", \"char\");
		rawToCPP.put(\"ubyte\", \"unsigned char\");
		rawToCPP.put(\"int8\", \"char\");
		rawToCPP.put(\"uint8\", \"unsigned char\");
		rawToCPP.put(\"int16\", \"short\");
		rawToCPP.put(\"uint16\", \"unsigned short\");
		rawToCPP.put(\"int24\", \"int\");
		rawToCPP.put(\"uint24\", \"unsigned int\");
		rawToCPP.put(\"int32\", \"int\");
		rawToCPP.put(\"uint32\", \"unsigned int\");
		rawToCPP.put(\"int48\", \"long long\");
		rawToCPP.put(\"uint48\", \"unsigned long long\");
		rawToCPP.put(\"int64\", \"long long\");
		rawToCPP.put(\"uint64\", \"unsigned long long\");
		rawToCPP.put(\"float\", \"float\");
		rawToCPP.put(\"double\", \"double\");

		rawToByteSwapped = new Hashtable();
		rawToByteSwapped.put(\"bit\", \"false\");
		rawToByteSwapped.put(\"ubyte\", \"false\");
		rawToByteSwapped.put(\"int8\", \"false\");
		rawToByteSwapped.put(\"uint8\", \"false\");
		rawToByteSwapped.put(\"int16\", \"true\");
		rawToByteSwapped.put(\"uint16\", \"true\");
		rawToByteSwapped.put(\"int24\", \"true\");
		rawToByteSwapped.put(\"uint24\", \"true\");
		rawToByteSwapped.put(\"int32\", \"true\");
		rawToByteSwapped.put(\"uint32\", \"true\");
		rawToByteSwapped.put(\"int48\", \"true\");
		rawToByteSwapped.put(\"uint48\", \"true\");
		rawToByteSwapped.put(\"int64\", \"true\");
		rawToByteSwapped.put(\"uint64\", \"true\");
		rawToByteSwapped.put(\"float\", \"true\");
		rawToByteSwapped.put(\"double\", \"true\");

		rawBytes = new Hashtable();
		rawBytes.put(\"bit\", \"1\");
		rawBytes.put(\"ubyte\", \"1\");
		rawBytes.put(\"int8\", \"1\");
		rawBytes.put(\"uint8\", \"1\");
		rawBytes.put(\"int16\", \"2\");
		rawBytes.put(\"uint16\", \"2\");
		rawBytes.put(\"int24\", \"3\");
		rawBytes.put(\"uint24\", \"3\");
		rawBytes.put(\"int32\", \"4\");
		rawBytes.put(\"uint32\", \"4\");
		rawBytes.put(\"int48\", \"6\");
		rawBytes.put(\"uint48\", \"6\");
		rawBytes.put(\"int64\", \"8\");
		rawBytes.put(\"uint64\", \"8\");
		rawBytes.put(\"float\", \"4\");
		rawBytes.put(\"double\", \"8\");

		worldToCPP = new Hashtable();
		worldToCPP.put(\"byte\", \"char\");
		worldToCPP.put(\"ubyte\", \"unsigned char\");
		worldToCPP.put(\"short\", \"short\");
		worldToCPP.put(\"ushort\", \"unsigned short\");
		worldToCPP.put(\"int\", \"int\");
		worldToCPP.put(\"uint\", \"unsigned int\");
		worldToCPP.put(\"long\", \"long long\");
		worldToCPP.put(\"ulong\", \"unsigned long long\");
		worldToCPP.put(\"float\", \"float\");
		worldToCPP.put(\"double\", \"double\");
		worldToCPP.put(\"boolean\", \"bool\");
		worldToCPP.put(\"string\", \"std::string\");
		worldToCPP.put(\"acstime\", \"ACS::Time\");
		worldToCPP.put(\"void\", \"void\");

		worldToJava = new Hashtable();
		worldToJava.put(\"byte\", \"int\");
		worldToJava.put(\"ubyte\", \"int\");
		worldToJava.put(\"short\", \"int\");
		worldToJava.put(\"ushort\", \"int\");
		worldToJava.put(\"int\", \"int\");
		worldToJava.put(\"uint\", \"long\");
		worldToJava.put(\"long\", \"long\");
		worldToJava.put(\"ulong\", \"long\");
		worldToJava.put(\"float\", \"float\");
		worldToJava.put(\"double\", \"double\");
		worldToJava.put(\"boolean\", \"boolean\");
		worldToJava.put(\"string\", \"String\");
		worldToJava.put(\"acstime\", \"ACSTime\");
		worldToJava.put(\"void\", \"void\");

		worldToBACI = new Hashtable();
		worldToBACI.put(\"byte\", \"long\");
		worldToBACI.put(\"ubyte\", \"long\");
		worldToBACI.put(\"short\", \"long\");
		worldToBACI.put(\"ushort\", \"long\");
		worldToBACI.put(\"int\", \"long\");
		worldToBACI.put(\"uint\", \"uLong\");
		worldToBACI.put(\"long\", \"longLong\");
		worldToBACI.put(\"ulong\", \"uLongLong\");
		worldToBACI.put(\"float\", \"float\");
		worldToBACI.put(\"double\", \"double\");
		worldToBACI.put(\"boolean\", \"boolean\");
		worldToBACI.put(\"string\", \"string\");
		worldToBACI.put(\"acstime\", \"uLongLong\");
		worldToBACI.put(\"void\", \"void\");

		worldToCORBA = new Hashtable();
		worldToCORBA.put(\"byte\", \"CORBA::Long\");
		worldToCORBA.put(\"ubyte\", \"CORBA::Long\");
		worldToCORBA.put(\"short\", \"CORBA::Long\");
		worldToCORBA.put(\"ushort\", \"CORBA::Long\");
		worldToCORBA.put(\"int\", \"CORBA::Long\");
		worldToCORBA.put(\"uint\", \"CORBA::ULong\");
		worldToCORBA.put(\"long\", \"CORBA::LongLong\");
		worldToCORBA.put(\"ulong\", \"CORBA::ULongLong\");
		worldToCORBA.put(\"float\", \"CORBA::Float\");
		worldToCORBA.put(\"double\", \"CORBA::Double\");
		worldToCORBA.put(\"boolean\", \"CORBA::Boolean\");
		worldToCORBA.put(\"string\", \"char *\");
		worldToCORBA.put(\"acstime\", \"ACS::Time\");
		worldToCORBA.put(\"void\", \"void\");

		worldToCORBADevIO = new Hashtable();
		worldToCORBADevIO.put(\"byte\", \"CORBA::Long\");
		worldToCORBADevIO.put(\"ubyte\", \"CORBA::Long\");
		worldToCORBADevIO.put(\"short\", \"CORBA::Long\");
		worldToCORBADevIO.put(\"ushort\", \"CORBA::Long\");
		worldToCORBADevIO.put(\"int\", \"CORBA::Long\");
		worldToCORBADevIO.put(\"uint\", \"CORBA::ULong\");
		worldToCORBADevIO.put(\"long\", \"CORBA::LongLong\");
		worldToCORBADevIO.put(\"ulong\", \"CORBA::ULongLong\");
		worldToCORBADevIO.put(\"float\", \"CORBA::Float\");
		worldToCORBADevIO.put(\"double\", \"CORBA::Double\");
		worldToCORBADevIO.put(\"boolean\", \"CORBA::Boolean\");
		worldToCORBADevIO.put(\"string\", \"CORBA::String\");
		worldToCORBADevIO.put(\"acstime\", \"ACS::Time\");
		worldToCORBADevIO.put(\"void\", \"NOTHING\");

		worldToCORBASeq = new Hashtable();
		worldToCORBASeq.put(\"byte\", \"Control::LongSeq\");
		worldToCORBASeq.put(\"ubyte\", \"Control::LongSeq\");
		worldToCORBASeq.put(\"short\", \"Control::LongSeq\");
		worldToCORBASeq.put(\"ushort\", \"Control::LongSeq\");
		worldToCORBASeq.put(\"int\", \"Control::LongSeq\");
		worldToCORBASeq.put(\"uint\", \"Control::ULongSeq\");
		worldToCORBASeq.put(\"long\", \"Control::LongLongSeq\");
		worldToCORBASeq.put(\"ulong\", \"Control::ULongLongSeq\");
		worldToCORBASeq.put(\"float\", \"Control::FloatSeq\");
		worldToCORBASeq.put(\"double\", \"Control::DoubleSeq\");
		worldToCORBASeq.put(\"boolean\", \"Control::BooleanSeq\");
		worldToCORBASeq.put(\"string\", \"Control::StringSeq\");
		worldToCORBASeq.put(\"acstime\", \"Control::ACSTimeSeq\");
		worldToCORBASeq.put(\"void\", \"NOTHING\");

		worldToIDLSeq = new Hashtable();
		worldToIDLSeq.put(\"byte\", \"Control::LongSeq\");
		worldToIDLSeq.put(\"ubyte\", \"Control::LongSeq\");
		worldToIDLSeq.put(\"short\", \"Control::LongSeq\");
		worldToIDLSeq.put(\"ushort\", \"Control::LongSeq\");
		worldToIDLSeq.put(\"int\", \"Control::LongSeq\");
		worldToIDLSeq.put(\"uint\", \"Control::ULongSeq\");
		worldToIDLSeq.put(\"long\", \"Control::LongLongSeq\");
		worldToIDLSeq.put(\"ulong\", \"Control::ULongLongSeq\");
		worldToIDLSeq.put(\"float\", \"Control::FloatSeq\");
		worldToIDLSeq.put(\"double\", \"Control::DoubleSeq\");
		worldToIDLSeq.put(\"boolean\", \"Control::BooleanSeq\");
		worldToIDLSeq.put(\"string\", \"Control::StringSeq\");
		worldToIDLSeq.put(\"acstime\", \"Control::ACSTimeSeq\");
		worldToIDLSeq.put(\"void\", \"NOTHING\");

		worldToIDL = new Hashtable();
		worldToIDL.put(\"byte\", \"long\");
		worldToIDL.put(\"ubyte\", \"long\");
		worldToIDL.put(\"short\", \"long\");
		worldToIDL.put(\"ushort\", \"long\");
		worldToIDL.put(\"int\", \"long\");
		worldToIDL.put(\"uint\", \"unsigned long\");
		worldToIDL.put(\"long\", \"long long\");
		worldToIDL.put(\"ulong\", \"unsigned long long\");
		worldToIDL.put(\"float\", \"float\");
		worldToIDL.put(\"double\", \"double\");
		worldToIDL.put(\"boolean\", \"boolean\");
		worldToIDL.put(\"string\", \"string\");
		worldToIDL.put(\"acstime\", \"ACS::Time\");
		worldToIDL.put(\"void\", \"void\");

		worldToDatabase = new Hashtable();
		worldToDatabase.put(\"byte\", \"integer\");
		worldToDatabase.put(\"ubyte\", \"integer\");
		worldToDatabase.put(\"short\", \"integer\");
		worldToDatabase.put(\"ushort\", \"integer\");
		worldToDatabase.put(\"int\", \"integer\");
		worldToDatabase.put(\"uint\", \"integer\");
		worldToDatabase.put(\"long\", \"integer\");
		worldToDatabase.put(\"ulong\", \"integer\");
		worldToDatabase.put(\"float\", \"float\");
		worldToDatabase.put(\"double\", \"double\");
		worldToDatabase.put(\"boolean\", \"boolean\");
		worldToDatabase.put(\"string\", \"string\");
		worldToDatabase.put(\"acstime\", \"integer\");
		worldToDatabase.put(\"void\", \"-none-\");")
					op void initialize(EStringArray3 sh);
					readonly attr String DepChar = "^";
					readonly attr String CelsiusToKelvin = "CelsiusToKelvin";
					attr ArrayList sheetNames;
					attr ArrayList colNames;
					attr Hashtable toCPP;
					attr Hashtable toIDL;
					attr Hashtable toIDLSeq;
					attr Hashtable toCORBA;
					attr Hashtable toCORBASeq;
					attr Hashtable toCORBADevIO;
					attr Hashtable toBACI;
					attr Hashtable toDatabase;
					attr Hashtable rawToCPP;
					attr Hashtable rawToByteSwapped;
					attr Hashtable rawBytes;
					attr Hashtable worldToCPP;
					attr Hashtable worldToIDL;
					attr Hashtable worldToIDLSeq;
					attr Hashtable worldToCORBA;
					attr Hashtable worldToCORBASeq;
					attr Hashtable worldToCORBADevIO;
					attr Hashtable worldToBACI;
					attr Hashtable worldToJava;
					attr Hashtable worldToDatabase;
				}

				class Util {

					@GenModel(body="System.out.println(msg);
System.exit(0);")
					op void error(String msg);

					@GenModel(body="				java.io.PrintStream out = null;
				java.io.LineNumberReader in = null;
				String line = null;
				
				java.io.File file = new java.io.File (dirName,fileName);
				if (!file.isFile())
					error(file.getAbsolutePath() + \" is not a file.\");
				
				try {
					// Open the input file.
					in = new java.io.LineNumberReader(new java.io.FileReader(file));
					
					// Create the output file.
					String newName = file.getAbsolutePath() + \".tmp\";
					out = new java.io.PrintStream (new java.io.FileOutputStream (new java.io.File(newName)));
					
					line = in.readLine();
					// Skip all blank lines at the beginning.
					while (true) {
						if (line != null && line.trim().length() == 0)
							line = in.readLine();
						else
							break;
					}
					boolean blankFound = false;
					while (line != null) {
						if (line.trim().length() == 0) {
							blankFound = true;
						} else {
							if (blankFound) {
								blankFound = false;
								if (replace == 1)
									out.println();
							}
							out.println(line);
						}
						line = in.readLine();
					}
					// Close the input file and the output file.
					in.close();
					out.close();
					// Delete the old file and rename the new file.
					if (!file.delete())
						error(\"Could not delete \" + file.getAbsolutePath());
					java.io.File newFile = new java.io.File (newName);
					newFile.renameTo(file);
				}catch (java.io.IOException err) {
					error(err.toString());
				}")
					op void RemoveLinesFromFile(String dirName, String fileName, int replace);

					@GenModel(body="if (str == null || str.length() == 0)
            return null;
        String s = str;
        StringBuffer x = new StringBuffer ();
        char c = s.charAt(0);
        x.append(Character.toUpperCase(c));
        for (int i = 1; i < s.length(); ++i) {
            c = s.charAt(i);
            if (c == '_') {
                do {
                    ++i;
                    if (i == s.length())
                        break;
                    c = s.charAt(i);
                } while (c == '_');
                if (i == s.length())
                    break;
                x.append(Character.toUpperCase(c));
            } else {
                x.append(Character.toLowerCase(c));
            }
        }
        return x.toString();")
					op String AltName(String str);

					@GenModel(body="if (s == null)
            return \"\";
        String raw = decodeHTMLChars(s);
        StringBuffer extract = new StringBuffer ();
        int begin = 0;
        int current = 0;
        int len = raw.length();
        char c = 0;
        while (current < len) {
            c = raw.charAt(current);
            if (c == '&' && (current + 4) <= len && raw.charAt(current + 1) == '#' &&
                        raw.charAt(current + 2) == '1' && raw.charAt(current + 3) == '0' &&
                        raw.charAt(current + 4) == ';') {
                c = ' ';
                current += 4;
            }
            extract.append(c);
            if ((current - begin) > maxLength && c == ' ') {
                extract.append(newline);
                extract.append(prefix);
                begin = current + 1;
            }
            ++current;
        }
        return extract.toString();")
					op String formatDescriptionBase(String s, String prefix);

					@GenModel(body="return formatDescriptionBase(s,\"\");")
					op String formatDescription(String s);

					@GenModel(body="return formatDescriptionBase(s,\"/// \");")
					op String formatDescriptionL1(String s);

					@GenModel(body="return formatDescriptionBase(s,\"    /// \");")
					op String formatDescriptionL2(String s);

					@GenModel(body="return formatDescriptionBase(s,\"/// \");")
					op String formatDescriptionL4(String s);

					@GenModel(body="return formatDescriptionBase(s,\"    /// \");")
					op String formatDescriptionL5(String s);

					@GenModel(body="if (s == null)
            return \"\";
        String raw = decodeHTMLChars(s);
        StringBuffer extract = new StringBuffer ();
        int current = 0;
        int len = raw.length();
        char c = 0;
        while (current < len) {
            c = raw.charAt(current);
            if (c == '&' && (current + 4) <= len && raw.charAt(current + 1) == '#' &&
                        raw.charAt(current + 2) == '1' && raw.charAt(current + 3) == '0' &&
                        raw.charAt(current + 4) == ';') {
                c = ' ';
                current += 4;
            }
            extract.append(c);
            ++current;
        }
        return extract.toString();")
					op String descriptionAsString(String s);

					@GenModel(body=" if (s == null || s.length() == 0)
            return s;
        StringBuffer x = new StringBuffer();
        int index = 0;
        int index1 = 0;
        int index2 = 0;
        int index3 = 0;
        int index4 = 0;
        int current = 0;
        while (true) {
            // look for any HTML encoded character
            index1 = s.indexOf(\"&lt;\", current);
            index2 = s.indexOf(\"&gt;\", current);
            index3 = s.indexOf(\"&amp;\", current);
            index4 = s.indexOf(\"&#xd;\", current);
            // if there aren't any, we're done
            if (index1 == -1 && index2 == -1 && index3 == -1 && index4 == -1) {
                x.append(s.substring(current));
                break;
            }
            // set index to the least value that is not -1
            index = index1;
            if (index == -1 || (index2 != -1 && index2 < index))
                index = index2;
            if (index == -1 || (index3 != -1 && index3 < index))
                index = index3;
            if (index == -1 || (index4 != -1 && index4 < index))
                index = index4;
            // append the current text up to index
            x.append(s.substring(current,index));
            // append the correct character and skip over the HTML encoded characters
            if (index == index1) {
                x.append('<');
                current = index + 4;
            } else if (index == index2) {
                x.append('>');
                current = index + 4;
            } else if (index == index3) {
                x.append('&');
                current = index + 5;
            } else if (index == index4) {
                x.append('\n');
                current = index + 5;
            }
        }
        return new String (x);")
					op String decodeHTMLChars(String s);

					@GenModel(body="return s.endsWith(\"]\") ? true : false;")
					op boolean isArray(String s);

					@GenModel(body="return (String)tables.getRawBytes().get(s);")
					op String NumberRawDataTypeBytes(String s);

					@GenModel(body="		if (isArray(s)) {
			int b;
			int n = Integer.parseInt(NumberOfItems(s));
			if(s.startsWith(\"&lt;\"))
				return \"0\";
			if(s.startsWith(\"[\"))
				return \"0\";
			int i = s.indexOf(\"[\");
			String aux = (String) tables.getRawBytes().get(s.substring(0, i));
			b = Integer.parseInt(aux);

			String x = Integer.toString(n * b);
			return x;
		}
		return (String)tables.getRawBytes().get(s);")
					op String RawDataTypeTotalBytes(String s);

					@GenModel(body="		if (s.startsWith(\"&lt;\"))
			return \"1\";
		if (!isArray(s))
			return \"1\";
		int i = s.indexOf(\"[\");
		if (i == -1)
			throw new RuntimeException(\"Invalid syntax in array notation: (\" + s + \")\");
		String x = s.substring(i + 1, s.length() - 1);
		try {
			int n = Integer.parseInt(x);
		} catch (NumberFormatException err) {
			throw new RuntimeException(\"Invalid syntax in array notation: (\" + s + \")\");
		}
		return x;")
					op String NumberOfItems(String s);

					@GenModel(body="		if (s.startsWith(\"&lt;\"))
			return 0;
		if (s.startsWith(\"[\"))
			return 0; // This isn't really true, but it will pass the validation.
		String x = s;
		if (isArray(s)) {
			int i = s.indexOf(\"[\");
			if (i == -1)
				throw new RuntimeException(\"Invalid syntax in array notation: (\" + s + \")\");
			x = s.substring(0, i);
		}
		return 0;
")
					op int getRawDataTypeIndex(String s);

					@GenModel(body="		    	//The required string date form is \"YYYY-MM-DDThh:mm:ss.ssss\".
		    	alma.hla.runtime.asdm.types.ArrayTime t = new alma.hla.runtime.asdm.types.ArrayTime (\"20\" + parseDateString(s,true) + \"T00:00:00.0\");
		    	long l = t.get();
		    	return Long.toString(l);")
					op String toArrayTime(String s);

					@GenModel(body="return parseDateString(s,false);")
					op String toDatabaseDate(String s);

					@GenModel(body="		int pos = 0;
		int n = s.indexOf('-'); 	if (n == -1) return null;
		String yy = s.substring(pos,n);
		if (yy.startsWith(\"20\"))
			yy = yy.substring(2);
		pos = n + 1;
		n = s.indexOf('-',pos); 	if (n == -1) return null;
		String mm = s.substring(pos,n);
		int nmm = 0;
		try {
			nmm = Integer.parseInt(mm);
		} catch (NumberFormatException err) {
			return null;
		}
		if (nmm < 1 || nmm > 12) return null;
		pos = n + 1;
		n = s.indexOf('T',pos); 	if (n == -1) return null;
		String dd = s.substring(pos,n);
		return yy + '-' + (alt ? montHalt[nmm - 1] : month[nmm - 1]) + '-' + dd;")
					op String parseDateString(String s, boolean alt);

					@GenModel(body=" if (wdt.equals(\"boolean\"))
		   return normalizeBoolean(value);
	   else if (wdt.equals(\"double\") || wdt.equals(\"float\"))
		   return normalizeFloat(value);
	   else
		   return value;")
					op String normalizeNumber(String wdt, String value);

					@GenModel(body="	   try {
          // Does value contain a valid \"double\" or \"float\"?
		  Double.parseDouble(value);
          // Does value contain a decimal point?
          if (-1 == value.indexOf('.')) {
        	  // No decimal point found.
		      // Does value contain an exponent?
		      int i = value.indexOf('E');
		      if (-1 != i) {
			      // Insert the \".0\" before the \"E\".
			      String parts[] = value.split(\"E\");
			      return parts[0] + \".0E\" + parts[1];
		       } else {
		    	   // No exponent found.
			       // Append the \".0\" to the end.
                   return value + \".0\";
		       }
	       } else {
	    	   // value contains a decimal point.  Return it without changes.  
	           return value;
	       }
       } catch (NumberFormatException de) {
           try {
               // Does this contain a valid \"integer\" or \"long\"?
        	   Integer.parseInt(value);
        	   // Add the missing decimal point and trailing \"0\".
        	   return value + \".0\";
       	   } catch (NumberFormatException ie) {
       		   // This is not a number.
       		   // Return it as is.
       		   return value;
       	   }
       }")
					op String normalizeFloat(String value);

					@GenModel(body="	   int indexOfDot = value.indexOf('.');
	   if (-1 == indexOfDot) {
		   return value;
	   } else {
		   return value.substring(0,indexOfDot);
	   }")
					op String normalizeBoolean(String value);

					@GenModel(body="		String dirLocation = null;
		String acsroot = System.getenv(\"ACSROOT\");
		String intlist = System.getenv(\"INTLIST\");
		String introot = System.getenv(\"INTROOT\");

		if (acsroot != null && new java.io.File(acsroot + \"/lib/ControlGenHwDevicev2\").exists()) {
			dirLocation = acsroot + \"/lib/ControlGenHwDevicev2\";
		}

		if (intlist != null ) {
			String dirs[] = intlist.split(\":\");
			for (int i = 0; i < dirs.length; i++) {
				if (new java.io.File(dirs[i] + \"/lib/ControlGenHwDevicev2\").exists()) {
					dirLocation = dirs[i] + \"/lib/ControlGenHwDevicev2\";
					break;
				}
			}

		}

		if (introot != null && new java.io.File(introot + \"/lib/ControlGenHwDevicev2\").exists()) {
			dirLocation = introot + \"/lib/ControlGenHwDevicev2\";
		}  

		assert dirLocation != null : \"dirLocation is null, this means that I cannot find lib/ControlGenHwDevicev2\";
		return dirLocation;")
					op String getInstallDir();
					attr String newline;
					attr int maxLength = 54;
					attr EStringArray MONTH;
					attr EStringArray MONTHalt;
					ref Table tables;
				}

				datatype ArrayList : java.util.ArrayList;

				datatype Hashtable : java.util.Hashtable;

				datatype SimpleErrorHandlerDT : alma.control.datamodel.meta.base.SimpleErrorHandler;

				datatype RuntimeExceptionDT : java.lang.RuntimeException;

				datatype ErrorHandlerDT : org.xml.sax.ErrorHandler;

				datatype EObjectDT : org.eclipse.emf.ecore.EObject;

				datatype SAXParseExceptionDT : org.xml.sax.SAXParseException;

				datatype EStringArray : "java.lang.String[]";

				datatype EStringArray2 : "java.lang.String[][]";

				datatype EStringArray3 : "java.lang.String[][][]";

				abstract interface ErrorHandlerAuxClass : org.xml.sax.ErrorHandler {
				}

			}

			@namespace(uri="http://alma/Control/datamodel/meta/eth/1.0", prefix="alma.Control.datamodel.meta.eth")
			package eth {
				class Archive extends base.ArchiveProperty {

					@GenModel(body="this.tables = tables;
setArchiveProperty(row, tables);")
					op void setArchiveEth(base.EStringArray row, base.Table tables);
				}

				class Control extends base.ControlPoint {

					@GenModel(body="mac.setAssemblyName(assembly);")
					op void setAssemblyName(String assembly);

					@GenModel(body="return mac.Assembly();")
					op String Assembly();

					@GenModel(body="return mac.Address();")
					op String Address();

					@GenModel(body="		try{
			Integer.decode(mac.Address());
		}catch(Exception e){
			return true;
		}

		return false;")
					op boolean IsEnumAddress();

					@GenModel(body="return mac.DataType();")
					op String DataType();

					@GenModel(body="return mac.IsDataArray();")
					op boolean IsDataArray();

					@GenModel(body="return mac.IsOpenArray();")
					op boolean IsOpenArray();

					@GenModel(body="return mac.getArrayLength();")
					op String getArrayLength();

					@GenModel(body="return mac.DataToIDLType();")
					op String DataToIDLType();

					@GenModel(body="return mac.DataToIDLSeqType();")
					op String DataToIDLSeqType();

					@GenModel(body="return mac.DataToCPPType();")
					op String DataToCPPType();

					@GenModel(body="return mac.DataToCORBAType();")
					op String DataToCORBAType();

					@GenModel(body="return mac.DataToCORBADevIOType();")
					op String DataToCORBADevIOType();

					@GenModel(body="return mac.DataToCORBASeqType();")
					op String DataToCORBASeqType();

					@GenModel(body="return mac.DataToBACIType();")
					op String DataToBACIType();

					@GenModel(body="return mac.DataToDatabaseType();")
					op String DataToDatabaseType();

					@GenModel(body="this.tables = tables;
this.utils = utils;")
					op void setControlEth(base.Table tables, base.Util utils);

					@GenModel(body="this.parent = parent;
setControlPoint(row, parent);
mac = EthFactory.eINSTANCE.createMandC();
mac.setMandCEth(row, sheet);")
					op void setControlEth(base.EStringArray row, EObject parent);
					ref MandC mac;
				}

				class DeviceModel extends base.DeviceModel {

					@GenModel(body="return \"\";")
					op String CreateModel();

					@GenModel(body="return ((MainImpl)main).VendorClass();")
					op String VendorClass();
					val Main mainEth;
					val Control[*] cPoints;
					val Archive[*] aPoints;
					val Monitor[*] mPoints;
					val base.Note note;
				}

				class Main extends base.MainBase {

					@GenModel(body="return row[tables.getColNum(sheet, \"Vendor Class\")];")
					op String VendorClass();

					@GenModel(body="this.row = row;
super.setMainBase(row);")
					op void setMainEth(base.EStringArray row);
				}

				class MandC {

					@GenModel(body="this.assembly = assembly;")
					op void setAssemblyName(String assembly);

					@GenModel(body="return assembly;")
					op String Assembly();

					@GenModel(body="return row[tables.getColNum(sheet, \"Address\")];")
					op String Address();

					@GenModel(body="String s = row[tables.getColNum(sheet, \"Data Type\")];
return IsDataArray() ? s.substring(0,s.indexOf(\"[\")) : s;")
					op String DataType();

					@GenModel(body="return row[tables.getColNum(sheet, \"Data Type\")].endsWith(\"]\") ? true : false;")
					op boolean IsDataArray();

					@GenModel(body="if(!IsDataArray()) return false;
String s =  row[tables.getColNum(sheet, \"Data Type\")];
return (s.indexOf(\"]\") - s.indexOf(\"[\") == 1) ? true : false;")
					op boolean IsOpenArray();

					@GenModel(body="if(!IsDataArray()) return \"1\";
String s = row[tables.getColNum(sheet, \"Data Type\")];
return s.substring(s.indexOf(\"[\")+1,s.indexOf(\"]\"));")
					op String getArrayLength();

					@GenModel(body="return (String)tables.getToCPP().get(DataType());")
					op String DataToCPPType();

					@GenModel(body="return (String)tables.getToIDL().get(DataType());")
					op String DataToIDLType();

					@GenModel(body="return (String)tables.getToIDLSeq().get(DataType());")
					op String DataToIDLSeqType();

					@GenModel(body="return (String)tables.getToCORBA().get(DataType());")
					op String DataToCORBAType();

					@GenModel(body="return (String)tables.getToCORBADevIO().get(DataType());")
					op String DataToCORBADevIOType();

					@GenModel(body="return (String)tables.getToCORBASeq().get(DataType());")
					op String DataToCORBASeqType();

					@GenModel(body="return (String)tables.getToBACI().get(DataType());")
					op String DataToBACIType();

					@GenModel(body="return (String)tables.getToDatabase().get(DataType());")
					op String DataToDatabaseType();

					@GenModel(body="this.tables = tables;
this.utils = utils;")
					op void setMandCEth(base.Table tables, base.Util utils);

					@GenModel(body="this.row = row;
this.sheet = sheet;")
					op void setMandCEth(base.EStringArray row, int sheet);
					attr base.EStringArray row;
					attr int sheet;
					attr String assembly;
					ref base.Table tables;
					ref base.Util utils;
				}

				class Monitor extends base.MonitorPoint {

					@GenModel(body="mac.setAssemblyName(assembly);")
					op void setAssemblyName(String assembly);

					@GenModel(body="return mac.Assembly();")
					op String Assembly();

					@GenModel(body="return mac.Address();")
					op String Address();

					@GenModel(body="		try{
			Integer.decode(mac.Address());
		}catch(Exception e){
			return true;
		}
		return false;")
					op boolean IsEnumAddress();

					@GenModel(body="return mac.DataType();")
					op String DataType();

					@GenModel(body="return mac.IsDataArray();")
					op boolean IsDataArray();

					@GenModel(body="return mac.IsOpenArray();")
					op boolean IsOpenArray();

					@GenModel(body="return mac.getArrayLength();")
					op String getArrayLength();

					@GenModel(body="return mac.DataToIDLType();")
					op String DataToIDLType();

					@GenModel(body="return mac.DataToIDLSeqType();")
					op String DataToIDLSeqType();

					@GenModel(body="return mac.DataToCPPType();")
					op String DataToCPPType();

					@GenModel(body="return mac.DataToCORBAType();")
					op String DataToCORBAType();

					@GenModel(body="return mac.DataToCORBADevIOType();")
					op String DataToCORBADevIOType();

					@GenModel(body="return mac.DataToCORBASeqType();")
					op String DataToCORBASeqType();

					@GenModel(body="return mac.DataToBACIType();")
					op String DataToBACIType();

					@GenModel(body="
		if (DataType().equals(\"uint\"))
			return false;
	
		if ( DataType().equals(\"bool\") || DataType().equals(\"boolean\")
				|| DataType().equals(\"string\")
				|| (DataType().equals(\"double\") && IsDataArray())
				|| (DataType().equals(\"int\") && IsDataArray()) )
			return false;
		return true;")
					op boolean IsArchived();

					@GenModel(body="return mac.DataToDatabaseType();")
					op String DataToDatabaseType();

					@GenModel(body="return false;")
					op boolean IsPartOfPattern();

					@GenModel(body="return true;")
					op boolean IsHomogeneous();

					@GenModel(body="return false;")
					op boolean IsPartOfHomogeneous();

					@GenModel(body="this.tables = tables;
this.utils = utils;")
					op void setMonitorEth(base.Table tables, base.Util utils);

					@GenModel(body="this.row = row;
this.parent = parent;
setMonitorPoint(row, parent);
mac = EthFactory.eINSTANCE.createMandC();
mac.setMandCEth(tables, utils);
mac.setMandCEth(row, sheet);")
					op void setMonitorEth(base.EStringArray row, EObject parent);
					ref MandC mac;
				}

			}

		}

	}

}

