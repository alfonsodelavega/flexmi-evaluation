@namespace(uri="http://www.eclipse.org/MoDisco/Javaee/ejb-jar_3_0.xsd", prefix="EjbJar30")
package EjbJar30;

import "http://www.eclipse.org/emf/2003/XMLType";
import "platform:/plugin/org.eclipse.emf.ecore/model/XMLNamespace.ecore";

@GenModel(documentation="

	The activation-config-propertyType contains a name/value
	configuration property pair for a message-driven bean.

	The properties that are recognized for a particular
	message-driven bean are determined by the messaging type.

      ")
@ExtendedMetaData(name="activation-config-propertyType", kind="elementOnly")
class ActivationConfigPropertyType {

	@GenModel(documentation="

	    The activation-config-property-name element contains
	    the name for an activation configuration property of
	    a message-driven bean.

	    For JMS message-driven beans, the following property
	    names are recognized: acknowledgeMode,
	    messageSelector, destinationType, subscriptionDurability

	  ")
	@ExtendedMetaData(kind="element", name="activation-config-property-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType[1] activationConfigPropertyName;

	@GenModel(documentation="

	    The activation-config-property-value element
	    contains the value for an activation configuration
	    property of a message-driven bean.

	  ")
	@ExtendedMetaData(kind="element", name="activation-config-property-value", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType[1] activationConfigPropertyValue;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The activation-configType defines information about the
	expected configuration properties of the message-driven bean
	in its operational environment. This may include information
	about message acknowledgement, message selector, expected
	destination type, etc.

	The configuration information is expressed in terms of
	name/value configuration properties.

	The properties that are recognized for a particular
	message-driven bean are determined by the messaging type.

      ")
@ExtendedMetaData(name="activation-configType", kind="elementOnly")
class ActivationConfigType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="activation-config-property", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ActivationConfigPropertyType[+] activationConfigProperty;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

        The application-exceptionType declares an application
        exception. The declaration consists of:

            - the exception class. When the container receives
              an exception of this type, it is required to
              forward this exception as an applcation exception
              to the client regardless of whether it is a checked
              or unchecked exception.
            - an optional rollback element. If this element is
              set to true, the container must rollback the current
              transaction before forwarding the exception to the
              client.  If not specified, it defaults to false.

      ")
@ExtendedMetaData(name="application-exceptionType", kind="elementOnly")
class ApplicationExceptionType {

	@ExtendedMetaData(kind="element", name="exception-class", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType[1] exceptionClass;

	@ExtendedMetaData(kind="element", name="rollback", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val TrueFalseType rollback;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

        The around-invoke type specifies a method on a
        class to be called during the around invoke portion of an
        ejb invocation.  Note that each class may have only one
        around invoke method and that the method may not be
        overloaded.

        If the class element is missing then
        the class defining the callback is assumed to be the
        interceptor class or component class in scope at the
        location in the descriptor in which the around invoke
        definition appears.

      ")
@ExtendedMetaData(name="around-invokeType", kind="elementOnly")
class AroundInvokeType {

	@ExtendedMetaData(kind="element", name="class", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType ~class;

	@ExtendedMetaData(kind="element", name="method-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val JavaIdentifierType[1] methodName;
}

@GenModel(documentation="

	The assembly-descriptorType defines
	application-assembly information.

	The application-assembly information consists of the
	following parts: the definition of security roles, the
	definition of method permissions, the definition of
	transaction attributes for enterprise beans with
	container-managed transaction demarcation, the definition
        of interceptor bindings, a list of
	methods to be excluded from being invoked, and a list of
        exception types that should be treated as application exceptions.

	All the parts are optional in the sense that they are
	omitted if the lists represented by them are empty.

	Providing an assembly-descriptor in the deployment
	descriptor is optional for the ejb-jar file producer.

      ")
@ExtendedMetaData(name="assembly-descriptorType", kind="elementOnly")
class AssemblyDescriptorType {

	@ExtendedMetaData(kind="element", name="security-role", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val SecurityRoleType[*] securityRole;

	@ExtendedMetaData(kind="element", name="method-permission", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MethodPermissionType[*] methodPermission;

	@ExtendedMetaData(kind="element", name="container-transaction", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ContainerTransactionType[*] containerTransaction;

	@ExtendedMetaData(kind="element", name="interceptor-binding", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val InterceptorBindingType[*] interceptorBinding;

	@ExtendedMetaData(kind="element", name="message-destination", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MessageDestinationType[*] messageDestination;

	@ExtendedMetaData(kind="element", name="exclude-list", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ExcludeListType excludeList;

	@ExtendedMetaData(kind="element", name="application-exception", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ApplicationExceptionType[*] applicationException;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The cmp-fieldType describes a container-managed field. The
	cmp-fieldType contains an optional description of the field,
	and the name of the field.

      ")
@ExtendedMetaData(name="cmp-fieldType", kind="elementOnly")
class CmpFieldType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@GenModel(documentation="

	    The field-name element specifies the name of a
	    container managed field.

	    The name of the cmp-field of an entity bean with
	    cmp-version 2.x must begin with a lowercase
	    letter. This field is accessed by methods whose
	    names consists of the name of the field specified by
	    field-name in which the first letter is uppercased,
	    prefixed by \"get\" or \"set\".

	    The name of the cmp-field of an entity bean with
	    cmp-version 1.x must denote a public field of the
	    enterprise bean class or one of its superclasses.

	  ")
	@ExtendedMetaData(kind="element", name="field-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val JavaIdentifierType[1] fieldName;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The cmp-versionType specifies the version of an entity bean
	with container-managed persistence. It is used by
	cmp-version elements.

	The value must be one of the two following:

	    1.x
	    2.x

      ")
@ExtendedMetaData(name="cmp-versionType", kind="simple")
class CmpVersionType extends String {
}

@ExtendedMetaData(name="cmp-versionType_._base")
enum CmpVersionTypeBase {
	_1X = 0;
	_2X = 1;
}

@ExtendedMetaData(name="cmp-versionType_._base:Object", baseType="cmp-versionType_._base")
datatype CmpVersionTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="

	The cmr-fieldType describes the bean provider's view of
	a relationship. It consists of an optional description, and
	the name and the class type of a field in the source of a
	role of a relationship. The cmr-field-name element
	corresponds to the name used for the get and set accessor
	methods for the relationship. The cmr-field-type element is
	used only for collection-valued cmr-fields. It specifies the
	type of the collection that is used.

      ")
@ExtendedMetaData(name="cmr-fieldType", kind="elementOnly")
class CmrFieldType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@GenModel(documentation="

	    The cmr-field-name element specifies the name of a
	    logical relationship field in the entity bean
	    class. The name of the cmr-field must begin with a
	    lowercase letter. This field is accessed by methods
	    whose names consist of the name of the field
	    specified by cmr-field-name in which the first
	    letter is uppercased, prefixed by \"get\" or \"set\".

	  ")
	@ExtendedMetaData(kind="element", name="cmr-field-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val String[1] cmrFieldName;

	@ExtendedMetaData(kind="element", name="cmr-field-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val CmrFieldTypeType cmrFieldType;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The cmr-field-type element specifies the class of a
	collection-valued logical relationship field in the entity
	bean class. The value of an element using cmr-field-typeType
	must be either: java.util.Collection or java.util.Set.

      ")
@ExtendedMetaData(name="cmr-field-typeType", kind="simple")
class CmrFieldTypeType extends String {
}

@ExtendedMetaData(name="cmr-field-typeType_._base")
enum CmrFieldTypeTypeBase {
	javaUtilCollection = 0;
	javaUtilSet = 1;
}

@ExtendedMetaData(name="cmr-field-typeType_._base:Object", baseType="cmr-field-typeType_._base")
datatype CmrFieldTypeTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="

	The container-transactionType specifies how the container
	must manage transaction scopes for the enterprise bean's
	method invocations. It defines an optional description, a
	list of method elements, and a transaction attribute. The
	transaction attribute is to be applied to all the specified
	methods.

      ")
@ExtendedMetaData(name="container-transactionType", kind="elementOnly")
class ContainerTransactionType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="method", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MethodType[+] method;

	@ExtendedMetaData(kind="element", name="trans-attribute", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val TransAttributeType[1] transAttribute;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The description type is used by a description element to
	provide text describing the parent element.  The elements
	that use this type should include any information that the
	Deployment Component's Deployment File file producer wants
	to provide to the consumer of the Deployment Component's
	Deployment File (i.e., to the Deployer). Typically, the
	tools used by such a Deployment File consumer will display
	the description when processing the parent element that
	contains the description.

	The lang attribute defines the language that the
	description is provided in. The default value is \"en\" (English).

      ")
@ExtendedMetaData(name="descriptionType", kind="simple")
class DescriptionType extends XsdStringType {

	@GenModel(documentation="
    <div xmlns=\"http://www.w3.org/1999/xhtml\">
     
      <h3>lang (as an attribute name)</h3>
      <p>
       denotes an attribute whose value
       is a language code for the natural language of the content of
       any element; its value is inherited.  This name is reserved
       by virtue of its definition in the XML specification.</p>
     
    </div>
    <div xmlns=\"http://www.w3.org/1999/xhtml\">
     <h4>Notes</h4>
     <p>
      Attempting to install the relevant ISO 2- and 3-letter
      codes as the enumerated possible values is probably never
      going to be a realistic possibility.  
     </p>
     <p>
      See BCP 47 at <a href=\"http://www.rfc-editor.org/rfc/bcp/bcp47.txt\">
       http://www.rfc-editor.org/rfc/bcp/bcp47.txt</a>
      and the IANA language subtag registry at
      <a href=\"http://www.iana.org/assignments/language-subtag-registry\">
       http://www.iana.org/assignments/language-subtag-registry</a>
      for further information.
     </p>
     <p>
      The union allows for the 'un-declaration' of xml:lang with
      the empty string.
     </p>
    </div>
   ")
	@ExtendedMetaData(kind="attribute", name="lang", namespace="http://www.w3.org/XML/1998/namespace")
	attr namespace.LangType lang;
}

@GenModel(documentation="

	This type defines a dewey decimal that is used
	to describe versions of documents.

      ")
@ExtendedMetaData(name="dewey-versionType", baseType="http://www.eclipse.org/emf/2003/XMLType#token", pattern="\.?[0-9]+(\.[0-9]+)*")
datatype DeweyVersionType : java.lang.String;

@GenModel(documentation="
	<![CDATA[

	  The display-name type contains a short name that is intended
	  to be displayed by tools. It is used by display-name
	  elements.  The display name need not be unique.

	  Example:

	  ...
	     <display-name xml:lang=\"en\">
	       Employee Self Service
	     </display-name>

	  The value of the xml:lang attribute is \"en\" (English) by default.

	  ]]>
      ")
@ExtendedMetaData(name="display-nameType", kind="simple")
class DisplayNameType extends String {

	@GenModel(documentation="
    <div xmlns=\"http://www.w3.org/1999/xhtml\">
     
      <h3>lang (as an attribute name)</h3>
      <p>
       denotes an attribute whose value
       is a language code for the natural language of the content of
       any element; its value is inherited.  This name is reserved
       by virtue of its definition in the XML specification.</p>
     
    </div>
    <div xmlns=\"http://www.w3.org/1999/xhtml\">
     <h4>Notes</h4>
     <p>
      Attempting to install the relevant ISO 2- and 3-letter
      codes as the enumerated possible values is probably never
      going to be a realistic possibility.  
     </p>
     <p>
      See BCP 47 at <a href=\"http://www.rfc-editor.org/rfc/bcp/bcp47.txt\">
       http://www.rfc-editor.org/rfc/bcp/bcp47.txt</a>
      and the IANA language subtag registry at
      <a href=\"http://www.iana.org/assignments/language-subtag-registry\">
       http://www.iana.org/assignments/language-subtag-registry</a>
      for further information.
     </p>
     <p>
      The union allows for the 'un-declaration' of xml:lang with
      the empty string.
     </p>
    </div>
   ")
	@ExtendedMetaData(kind="attribute", name="lang", namespace="http://www.w3.org/XML/1998/namespace")
	attr namespace.LangType lang;
}

@ExtendedMetaData(name="", kind="mixed")
class DocumentRoot {

	@ExtendedMetaData(kind="elementWildcard", name=":mixed")
	!unique attr ecore.EFeatureMapEntry[*] mixed;

	@ExtendedMetaData(kind="attribute", name="xmlns:prefix")
	transient !resolve val ecore.EStringToStringMapEntry[*] xMLNSPrefixMap;

	@ExtendedMetaData(kind="attribute", name="xsi:schemaLocation")
	transient !resolve val ecore.EStringToStringMapEntry[*] xSISchemaLocation;

	@GenModel(documentation="

	This is the root of the ejb-jar deployment descriptor.

      ")
	@ExtendedMetaData(kind="element", name="ejb-jar", namespace="http://java.sun.com/xml/ns/javaee")
	volatile transient derived !resolve val EjbJarType[0..?] ejbJar;
}

@GenModel(documentation="
	<![CDATA[

	  The ejb-classType contains the fully-qualified name of the
	  enterprise bean's class. It is used by ejb-class elements.

	  Example:

	      <ejb-class>com.wombat.empl.EmployeeServiceBean</ejb-class>

	  ]]>
      ")
@ExtendedMetaData(name="ejb-classType", kind="simple")
class EjbClassType extends FullyQualifiedClassType {
}

@ExtendedMetaData(name="ejb-classType_._base")
datatype EjbClassTypeBase : java.lang.String;

@GenModel(documentation="

	The ejb-jarType defines the root element of the EJB
	deployment descriptor. It contains

	    - an optional description of the ejb-jar file
	    - an optional display name
	    - an optional icon that contains a small and a large
	      icon file name
	    - structural information about all included
	      enterprise beans that is not specified through
              annotations
            - structural information about interceptor classes
	    - a descriptor for container managed relationships,
	      if any.
	    - an optional application-assembly descriptor
	    - an optional name of an ejb-client-jar file for the
	      ejb-jar.

      ")
@ExtendedMetaData(name="ejb-jarType", kind="elementOnly")
class EjbJarType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="display-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DisplayNameType[*] displayName;

	@ExtendedMetaData(kind="element", name="icon", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val IconType[*] icon;

	@ExtendedMetaData(kind="element", name="enterprise-beans", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EnterpriseBeansType enterpriseBeans;

	@ExtendedMetaData(kind="element", name="interceptors", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val InterceptorsType interceptors;

	@ExtendedMetaData(kind="element", name="relationships", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val RelationshipsType relationships;

	@GenModel(documentation="

	    Providing an assembly-descriptor in the deployment
	    descriptor is optional for the ejb-jar file
	    producer.

	  ")
	@ExtendedMetaData(kind="element", name="assembly-descriptor", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val AssemblyDescriptorType assemblyDescriptor;

	@GenModel(documentation="
	    <![CDATA[

	      The optional ejb-client-jar element specifies a JAR
	      file that contains the class files necessary for a
	      client program to access the
	      enterprise beans in the ejb-jar file.

	      Example:

		  <ejb-client-jar>employee_service_client.jar
		  </ejb-client-jar>

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="ejb-client-jar", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PathType ejbClientJar;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;

	@GenModel(documentation="

	  The metadata-complete attribute defines whether this
	  deployment descriptor and other related deployment
	  descriptors for this module (e.g., web service
	  descriptors) are complete, or whether the class
	  files available to this module and packaged with
	  this application should be examined for annotations
	  that specify deployment information.

	  If metadata-complete is set to \"true\", the deployment
	  tool must ignore any annotations that specify deployment
	  information, which might be present in the class files
	  of the application.

	  If metadata-complete is not specified or is set to
	  \"false\", the deployment tool must examine the class
	  files of the application for annotations, as
	  specified by the specifications.

	")
	@ExtendedMetaData(kind="attribute", name="metadata-complete")
	unsettable attr type.Boolean metadataComplete;

	@GenModel(documentation="

	  The version specifies the version of the
	  EJB specification that the instance document must
	  comply with. This information enables deployment tools
	  to validate a particular EJB Deployment
	  Descriptor with respect to a specific version of the EJB
	  schema.

	")
	@ExtendedMetaData(kind="attribute", name="version")
	unsettable attr DeweyVersionType[1] version = "3.0";
}

@GenModel(documentation="
	<![CDATA[

	  The ejb-linkType is used by ejb-link
	  elements in the ejb-ref or ejb-local-ref elements to specify
	  that an EJB reference is linked to enterprise bean.

	  The value of the ejb-link element must be the ejb-name of an
	  enterprise bean in the same ejb-jar file or in another ejb-jar
	  file in the same Java EE application unit.

	  Alternatively, the name in the ejb-link element may be
	  composed of a path name specifying the ejb-jar containing the
	  referenced enterprise bean with the ejb-name of the target
	  bean appended and separated from the path name by \"#\".  The
	  path name is relative to the Deployment File containing
	  Deployment Component that is referencing the enterprise
	  bean.  This allows multiple enterprise beans with the same
	  ejb-name to be uniquely identified.

	  Examples:

	      <ejb-link>EmployeeRecord</ejb-link>

	      <ejb-link>../products/product.jar#ProductEJB</ejb-link>

	  ]]>
      ")
@ExtendedMetaData(name="ejb-linkType", kind="simple")
class EjbLinkType extends String {
}

@ExtendedMetaData(name="ejb-linkType_._base", baseType="http://www.eclipse.org/emf/2003/XMLType#token")
datatype EjbLinkTypeBase : java.lang.String;

@GenModel(documentation="

	The ejb-local-refType is used by ejb-local-ref elements for
	the declaration of a reference to an enterprise bean's local
	home or to the local business interface of a 3.0 bean.
        The declaration consists of:

	    - an optional description
	    - the EJB reference name used in the code of the Deployment
	      Component that's referencing the enterprise bean.
	    - the optional expected type of the referenced enterprise bean
	    - the optional expected local interface of the referenced
              enterprise bean or the local business interface of the
              referenced enterprise bean.
	    - the optional expected local home interface of the referenced
              enterprise bean. Not applicable if this ejb-local-ref refers
              to the local business interface of a 3.0 bean.
	    - optional ejb-link information, used to specify the
	      referenced enterprise bean
            - optional elements to define injection of the named enterprise
              bean into a component field or property.

      ")
@ExtendedMetaData(name="ejb-local-refType", kind="elementOnly")
class EjbLocalRefType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="ejb-ref-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbRefNameType[1] ejbRefName;

	@ExtendedMetaData(kind="element", name="ejb-ref-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbRefTypeType ejbRefType;

	@ExtendedMetaData(kind="element", name="local-home", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LocalHomeType localHome;

	@ExtendedMetaData(kind="element", name="local", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LocalType local;

	@ExtendedMetaData(kind="element", name="ejb-link", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbLinkType ejbLink;

	@GenModel(documentation="
	    <![CDATA[

	      A product specific name that this resource should be
	      mapped to.  The name of this resource, as defined by the
	      resource's name element or defaulted, is a name that is
	      local to the application component using the resource.
	      (It's a name in the JNDI java:comp/env namespace.)  Many
	      application servers provide a way to map these local
	      names to names of resources known to the application
	      server.  This mapped name is often a global JNDI name,
	      but may be a name of any form.

	      Application servers are not required to support any
	      particular form or type of mapped name, nor the ability
	      to use mapped names.  The mapped name is
	      product-dependent and often installation-dependent.  No
	      use of a mapped name is portable.

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="mapped-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType mappedName;

	@ExtendedMetaData(kind="element", name="injection-target", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val InjectionTargetType[*] injectionTarget;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="
	<![CDATA[

	  The ejb-nameType specifies an enterprise bean's name. It is
	  used by ejb-name elements. This name is assigned by the
	  ejb-jar file producer to name the enterprise bean in the
	  ejb-jar file's deployment descriptor. The name must be
	  unique among the names of the enterprise beans in the same
	  ejb-jar file.

	  There is no architected relationship between the used
	  ejb-name in the deployment descriptor and the JNDI name that
	  the Deployer will assign to the enterprise bean's home.

	  The name for an entity bean must conform to the lexical
	  rules for an NMTOKEN.

	  Example:

	  <ejb-name>EmployeeService</ejb-name>

	  ]]>
      ")
@ExtendedMetaData(name="ejb-nameType", kind="simple")
class EjbNameType extends XsdNMTOKENType {
}

@ExtendedMetaData(name="ejb-nameType_._base", baseType="http://www.eclipse.org/emf/2003/XMLType#NMTOKEN")
datatype EjbNameTypeBase : java.lang.String;

@GenModel(documentation="
	<![CDATA[

	  The ejb-ref-name element contains the name of an EJB
	  reference. The EJB reference is an entry in the
	  Deployment Component's environment and is relative to the
	  java:comp/env context.  The name must be unique within the
	  Deployment Component.

	  It is recommended that name is prefixed with \"ejb/\".

	  Example:

	  <ejb-ref-name>ejb/Payroll</ejb-ref-name>

	  ]]>
      ")
@ExtendedMetaData(name="ejb-ref-nameType", kind="simple")
class EjbRefNameType extends JndiNameType {
}

@ExtendedMetaData(name="ejb-ref-nameType_._base")
datatype EjbRefNameTypeBase : java.lang.String;

@GenModel(documentation="

	The ejb-refType is used by ejb-ref elements for the
	declaration of a reference to an enterprise bean's home or
        to the remote business interface of a 3.0 bean.
	The declaration consists of:

	    - an optional description
	    - the EJB reference name used in the code of
	      the Deployment Component that's referencing the enterprise
	      bean.
	    - the optional expected type of the referenced enterprise bean
            - the optional remote interface of the referenced enterprise bean
              or the remote business interface of the referenced enterprise
              bean
	    - the optional expected home interface of the referenced
              enterprise bean.  Not applicable if this ejb-ref
              refers to the remote business interface of a 3.0 bean.
	    - optional ejb-link information, used to specify the
	      referenced enterprise bean
            - optional elements to define injection of the named enterprise
              bean into a component field or property

      ")
@ExtendedMetaData(name="ejb-refType", kind="elementOnly")
class EjbRefType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="ejb-ref-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbRefNameType[1] ejbRefName;

	@ExtendedMetaData(kind="element", name="ejb-ref-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbRefTypeType ejbRefType;

	@ExtendedMetaData(kind="element", name="home", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val HomeType home;

	@ExtendedMetaData(kind="element", name="remote", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val RemoteType remote;

	@ExtendedMetaData(kind="element", name="ejb-link", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbLinkType ejbLink;

	@GenModel(documentation="
	    <![CDATA[

	      A product specific name that this resource should be
	      mapped to.  The name of this resource, as defined by the
	      resource's name element or defaulted, is a name that is
	      local to the application component using the resource.
	      (It's a name in the JNDI java:comp/env namespace.)  Many
	      application servers provide a way to map these local
	      names to names of resources known to the application
	      server.  This mapped name is often a global JNDI name,
	      but may be a name of any form.

	      Application servers are not required to support any
	      particular form or type of mapped name, nor the ability
	      to use mapped names.  The mapped name is
	      product-dependent and often installation-dependent.  No
	      use of a mapped name is portable.

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="mapped-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType mappedName;

	@ExtendedMetaData(kind="element", name="injection-target", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val InjectionTargetType[*] injectionTarget;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The ejb-ref-typeType contains the expected type of the
	referenced enterprise bean.

	The ejb-ref-type designates a value
	that must be one of the following:

	    Entity
	    Session

      ")
@ExtendedMetaData(name="ejb-ref-typeType", kind="simple")
class EjbRefTypeType extends String {
}

@ExtendedMetaData(name="ejb-ref-typeType_._base")
enum EjbRefTypeTypeBase {
	Entity = 0;
	Session = 1;
}

@ExtendedMetaData(name="ejb-ref-typeType_._base:Object", baseType="ejb-ref-typeType_._base")
datatype EjbRefTypeTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="
	<![CDATA[

	  The ejb-relationship-roleType describes a role within a
	  relationship. There are two roles in each relationship.

	  The ejb-relationship-roleType contains an optional
	  description; an optional name for the relationship role; a
	  specification of the multiplicity of the role; an optional
	  specification of cascade-delete functionality for the role;
	  the role source; and a declaration of the cmr-field, if any,
	  by means of which the other side of the relationship is
	  accessed from the perspective of the role source.

	  The multiplicity and role-source element are mandatory.

	  The relationship-role-source element designates an entity
	  bean by means of an ejb-name element. For bidirectional
	  relationships, both roles of a relationship must declare a
	  relationship-role-source element that specifies a cmr-field
	  in terms of which the relationship is accessed. The lack of
	  a cmr-field element in an ejb-relationship-role specifies
	  that the relationship is unidirectional in navigability and
	  the entity bean that participates in the relationship is
	  \"not aware\" of the relationship.

	  Example:

	  <ejb-relation>
	      <ejb-relation-name>Product-LineItem</ejb-relation-name>
	      <ejb-relationship-role>
		  <ejb-relationship-role-name>product-has-lineitems
		  </ejb-relationship-role-name>
		  <multiplicity>One</multiplicity>
		  <relationship-role-source>
		  <ejb-name>ProductEJB</ejb-name>
		  </relationship-role-source>
	       </ejb-relationship-role>
	  </ejb-relation>

	  ]]>
      ")
@ExtendedMetaData(name="ejb-relationship-roleType", kind="elementOnly")
class EjbRelationshipRoleType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@GenModel(documentation="

	    The ejb-relationship-role-name element defines a
	    name for a role that is unique within an
	    ejb-relation. Different relationships can use the
	    same name for a role.

	  ")
	@ExtendedMetaData(kind="element", name="ejb-relationship-role-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val String ejbRelationshipRoleName;

	@ExtendedMetaData(kind="element", name="multiplicity", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MultiplicityType[1] multiplicity;

	@GenModel(documentation="

	    The cascade-delete element specifies that, within a
	    particular relationship, the lifetime of one or more
	    entity beans is dependent upon the lifetime of
	    another entity bean. The cascade-delete element can
	    only be specified for an ejb-relationship-role
	    element contained in an ejb-relation element in
	    which the other ejb-relationship-role
	    element specifies a multiplicity of One.

	  ")
	@ExtendedMetaData(kind="element", name="cascade-delete", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EmptyType cascadeDelete;

	@ExtendedMetaData(kind="element", name="relationship-role-source", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val RelationshipRoleSourceType[1] relationshipRoleSource;

	@ExtendedMetaData(kind="element", name="cmr-field", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val CmrFieldType cmrField;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The ejb-relationType describes a relationship between two
	entity beans with container-managed persistence.  It is used
	by ejb-relation elements. It contains a description; an
	optional ejb-relation-name element; and exactly two
	relationship role declarations, defined by the
	ejb-relationship-role elements. The name of the
	relationship, if specified, is unique within the ejb-jar
	file.

      ")
@ExtendedMetaData(name="ejb-relationType", kind="elementOnly")
class EjbRelationType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@GenModel(documentation="

	    The ejb-relation-name element provides a unique name
	    within the ejb-jar file for a relationship.

	  ")
	@ExtendedMetaData(kind="element", name="ejb-relation-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val String ejbRelationName;

	@ExtendedMetaData(kind="element", name="ejb-relationship-role", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbRelationshipRoleType[1] ejbRelationshipRole;

	@ExtendedMetaData(kind="element", name="ejb-relationship-role", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbRelationshipRoleType[1] ejbRelationshipRole1;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	This type is used to designate an empty
	element when used.

      ")
@ExtendedMetaData(name="emptyType", kind="empty")
class EmptyType {

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The enterprise-beansType declares one or more enterprise
	beans. Each bean can be a session, entity or message-driven
	bean.

      ")
@ExtendedMetaData(name="enterprise-beansType", kind="elementOnly")
class EnterpriseBeansType {

	@ExtendedMetaData(kind="group", name="group:0")
	!unique attr ecore.EFeatureMapEntry[*] group;

	@ExtendedMetaData(kind="element", name="session", namespace="http://java.sun.com/xml/ns/javaee", group="#group:0")
	volatile transient derived !resolve val SessionBeanType[*] session;

	@ExtendedMetaData(kind="element", name="entity", namespace="http://java.sun.com/xml/ns/javaee", group="#group:0")
	volatile transient derived !resolve val EntityBeanType[*] entity;

	@ExtendedMetaData(kind="element", name="message-driven", namespace="http://java.sun.com/xml/ns/javaee", group="#group:0")
	volatile transient derived !resolve val MessageDrivenBeanType[*] messageDriven;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The entity-beanType declares an entity bean. The declaration
	consists of:

	    - an optional description
	    - an optional display name
	    - an optional icon element that contains a small and a large
	      icon file name
	    - a unique name assigned to the enterprise bean
	      in the deployment descriptor
            - an optional mapped-name element that can be used to provide
              vendor-specific deployment information such as the physical
              jndi-name of the entity bean's remote home interface. This
              element is not required to be supported by all implementations.
              Any use of this element is non-portable.
	    - the names of the entity bean's remote home
	      and remote interfaces, if any
	    - the names of the entity bean's local home and local
	      interfaces, if any
	    - the entity bean's implementation class
	    - the optional entity bean's persistence management type. If
              this element is not specified it is defaulted to Container.
	    - the entity bean's primary key class name
	    - an indication of the entity bean's reentrancy
	    - an optional specification of the
	      entity bean's cmp-version
	    - an optional specification of the entity bean's
	      abstract schema name
	    - an optional list of container-managed fields
	    - an optional specification of the primary key
	      field
	    - an optional declaration of the bean's environment
	      entries
	    - an optional declaration of the bean's EJB
	      references
	    - an optional declaration of the bean's local
	      EJB references
	    - an optional declaration of the bean's web
	      service references
	    - an optional declaration of the security role
	      references
	    - an optional declaration of the security identity
	      to be used for the execution of the bean's methods
	    - an optional declaration of the bean's
	      resource manager connection factory references
	    - an optional declaration of the bean's
	      resource environment references
	    - an optional declaration of the bean's message
	      destination references
	    - an optional set of query declarations
	      for finder and select methods for an entity
	      bean with cmp-version 2.x.

	The optional abstract-schema-name element must be specified
	for an entity bean with container-managed persistence and
	cmp-version 2.x.

	The optional primkey-field may be present in the descriptor
	if the entity's persistence-type is Container.

	The optional cmp-version element may be present in the
	descriptor if the entity's persistence-type is Container. If
	the persistence-type is Container and the cmp-version
	element is not specified, its value defaults to 2.x.

	The optional home and remote elements must be specified if
	the entity bean cmp-version is 1.x.

	The optional home and remote elements must be specified if
	the entity bean has a remote home and remote interface.

	The optional local-home and local elements must be specified
	if the entity bean has a local home and local interface.

	Either both the local-home and the local elements or both
	the home and the remote elements must be specified.

	The optional query elements must be present if the
	persistence-type is Container and the cmp-version is 2.x and
	query methods other than findByPrimaryKey have been defined
	for the entity bean.

	The other elements that are optional are \"optional\" in the
	sense that they are omitted if the lists represented by them
	are empty.

	At least one cmp-field element must be present in the
	descriptor if the entity's persistence-type is Container and
	the cmp-version is 1.x, and none must not be present if the
	entity's persistence-type is Bean.

      ")
@ExtendedMetaData(name="entity-beanType", kind="elementOnly")
class EntityBeanType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="display-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DisplayNameType[*] displayName;

	@ExtendedMetaData(kind="element", name="icon", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val IconType[*] icon;

	@ExtendedMetaData(kind="element", name="ejb-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbNameType[1] ejbName;

	@ExtendedMetaData(kind="element", name="mapped-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType mappedName;

	@ExtendedMetaData(kind="element", name="home", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val HomeType home;

	@ExtendedMetaData(kind="element", name="remote", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val RemoteType remote;

	@ExtendedMetaData(kind="element", name="local-home", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LocalHomeType localHome;

	@ExtendedMetaData(kind="element", name="local", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LocalType local;

	@ExtendedMetaData(kind="element", name="ejb-class", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbClassType[1] ejbClass;

	@ExtendedMetaData(kind="element", name="persistence-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PersistenceTypeType[1] persistenceType;

	@GenModel(documentation="

	    The prim-key-class element contains the
	    fully-qualified name of an
	    entity bean's primary key class.

	    If the definition of the primary key class is
	    deferred to deployment time, the prim-key-class
	    element should specify java.lang.Object.

	  ")
	@ExtendedMetaData(kind="element", name="prim-key-class", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType[1] primKeyClass;

	@GenModel(documentation="

	    The reentrant element specifies whether an entity
	    bean is reentrant or not.

	    The reentrant element must be one of the two
	    following: true or false

	  ")
	@ExtendedMetaData(kind="element", name="reentrant", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val TrueFalseType[1] reentrant;

	@ExtendedMetaData(kind="element", name="cmp-version", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val CmpVersionType cmpVersion;

	@GenModel(documentation="

	    The abstract-schema-name element specifies the name
	    of the abstract schema type of an entity bean with
	    cmp-version 2.x. It is used in EJB QL queries.

	    For example, the abstract-schema-name for an entity
	    bean whose local interface is
	    com.acme.commerce.Order might be Order.

	  ")
	@ExtendedMetaData(kind="element", name="abstract-schema-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val JavaIdentifierType abstractSchemaName;

	@ExtendedMetaData(kind="element", name="cmp-field", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val CmpFieldType[*] cmpField;

	@GenModel(documentation="

	    The primkey-field element is used to specify the
	    name of the primary key field for an entity with
	    container-managed persistence.

	    The primkey-field must be one of the fields declared
	    in the cmp-field element, and the type of the field
	    must be the same as the primary key type.

	    The primkey-field element is not used if the primary
	    key maps to multiple container-managed fields
	    (i.e. the key is a compound key). In this case, the
	    fields of the primary key class must be public, and
	    their names must correspond to the field names of
	    the entity bean class that comprise the key.

	  ")
	@ExtendedMetaData(kind="element", name="primkey-field", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val String primkeyField;

	@ExtendedMetaData(kind="element", name="env-entry", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EnvEntryType[*] envEntry;

	@ExtendedMetaData(kind="element", name="ejb-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbRefType[*] ejbRef;

	@ExtendedMetaData(kind="element", name="ejb-local-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbLocalRefType[*] ejbLocalRef;

	@ExtendedMetaData(kind="element", name="service-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ServiceRefType[*] serviceRef;

	@ExtendedMetaData(kind="element", name="resource-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ResourceRefType[*] resourceRef;

	@ExtendedMetaData(kind="element", name="resource-env-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ResourceEnvRefType[*] resourceEnvRef;

	@ExtendedMetaData(kind="element", name="message-destination-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MessageDestinationRefType[*] messageDestinationRef;

	@ExtendedMetaData(kind="element", name="persistence-context-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PersistenceContextRefType[*] persistenceContextRef;

	@ExtendedMetaData(kind="element", name="persistence-unit-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PersistenceUnitRefType[*] persistenceUnitRef;

	@ExtendedMetaData(kind="element", name="post-construct", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LifecycleCallbackType[*] postConstruct;

	@ExtendedMetaData(kind="element", name="pre-destroy", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LifecycleCallbackType[*] preDestroy;

	@ExtendedMetaData(kind="element", name="security-role-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val SecurityRoleRefType[*] securityRoleRef;

	@ExtendedMetaData(kind="element", name="security-identity", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val SecurityIdentityType securityIdentity;

	@ExtendedMetaData(kind="element", name="query", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val QueryType[*] query;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The env-entryType is used to declare an application's
	environment entry. The declaration consists of an optional
	description, the name of the environment entry, a type
	(optional if the value is injected, otherwise required), and
	an optional value.

	It also includes optional elements to define injection of
	the named resource into fields or JavaBeans properties.

	If a value is not specified and injection is requested,
	no injection will occur and no entry of the specified name
	will be created.  This allows an initial value to be
	specified in the source code without being incorrectly
	changed when no override has been specified.

	If a value is not specified and no injection is requested,
	a value must be supplied during deployment.

	This type is used by env-entry elements.

      ")
@ExtendedMetaData(name="env-entryType", kind="elementOnly")
class EnvEntryType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@GenModel(documentation="
	    <![CDATA[

	      The env-entry-name element contains the name of a
	      Deployment Component's environment entry.  The name
	      is a JNDI name relative to the java:comp/env
	      context.  The name must be unique within a
	      Deployment Component. The uniqueness
	      constraints must be defined within the declared
	      context.

	      Example:

	      <env-entry-name>minAmount</env-entry-name>

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="env-entry-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val JndiNameType[1] envEntryName;

	@GenModel(documentation="
	    <![CDATA[

	      The env-entry-type element contains the Java language
	      type of the environment entry.  If an injection target
	      is specified for the environment entry, the type may
	      be omitted, or must match the type of the injection
	      target.  If no injection target is specified, the type
	      is required.

	      Example:

	      <env-entry-type>java.lang.Integer</env-entry-type>

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="env-entry-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EnvEntryTypeValuesType envEntryType;

	@GenModel(documentation="
	    <![CDATA[

	      The env-entry-value designates the value of a
	      Deployment Component's environment entry. The value
	      must be a String that is valid for the
	      constructor of the specified type that takes a
	      single String parameter, or for java.lang.Character,
	      a single character.

	      Example:

	      <env-entry-value>100.00</env-entry-value>

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="env-entry-value", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType envEntryValue;

	@GenModel(documentation="
	    <![CDATA[

	      A product specific name that this resource should be
	      mapped to.  The name of this resource, as defined by the
	      resource's name element or defaulted, is a name that is
	      local to the application component using the resource.
	      (It's a name in the JNDI java:comp/env namespace.)  Many
	      application servers provide a way to map these local
	      names to names of resources known to the application
	      server.  This mapped name is often a global JNDI name,
	      but may be a name of any form.

	      Application servers are not required to support any
	      particular form or type of mapped name, nor the ability
	      to use mapped names.  The mapped name is
	      product-dependent and often installation-dependent.  No
	      use of a mapped name is portable.

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="mapped-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType mappedName;

	@ExtendedMetaData(kind="element", name="injection-target", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val InjectionTargetType[*] injectionTarget;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="
	<![CDATA[

	  This type contains the fully-qualified Java type of the
	  environment entry value that is expected by the
	  application's code.

	  The following are the legal values of env-entry-type-valuesType:

	      java.lang.Boolean
	      java.lang.Byte
	      java.lang.Character
	      java.lang.String
	      java.lang.Short
	      java.lang.Integer
	      java.lang.Long
	      java.lang.Float
	      java.lang.Double

	  Example:

	  <env-entry-type>java.lang.Boolean</env-entry-type>

	  ]]>
      ")
@ExtendedMetaData(name="env-entry-type-valuesType", kind="simple")
class EnvEntryTypeValuesType extends String {
}

@ExtendedMetaData(name="env-entry-type-valuesType_._base")
enum EnvEntryTypeValuesTypeBase {
	javaLangBoolean = 0;
	javaLangByte = 1;
	javaLangCharacter = 2;
	javaLangString = 3;
	javaLangShort = 4;
	javaLangInteger = 5;
	javaLangLong = 6;
	javaLangFloat = 7;
	javaLangDouble = 8;
}

@ExtendedMetaData(name="env-entry-type-valuesType_._base:Object", baseType="env-entry-type-valuesType_._base")
datatype EnvEntryTypeValuesTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="

	The exclude-listType specifies one or more methods which
	the Assembler marks to be uncallable.

	If the method permission relation contains methods that are
	in the exclude list, the Deployer should consider those
	methods to be uncallable.

      ")
@ExtendedMetaData(name="exclude-listType", kind="elementOnly")
class ExcludeListType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="method", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MethodType[+] method;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The elements that use this type designate the name of a
	Java class or interface.  The name is in the form of a
	\"binary name\", as defined in the JLS.  This is the form
	of name used in Class.forName().  Tools that need the
	canonical name (the name used in source code) will need
	to convert this binary name to the canonical name.

      ")
@ExtendedMetaData(name="fully-qualified-classType", kind="simple")
class FullyQualifiedClassType extends String {
}

@ExtendedMetaData(name="fully-qualified-classType_._base", baseType="http://www.eclipse.org/emf/2003/XMLType#token")
datatype FullyQualifiedClassTypeBase : java.lang.String;

@GenModel(documentation="

	This type defines four different values which can designate
	boolean values. This includes values yes and no which are
	not designated by xsd:boolean

      ")
@ExtendedMetaData(name="generic-booleanType", kind="simple")
class GenericBooleanType extends String {
}

@ExtendedMetaData(name="generic-booleanType_._base")
enum GenericBooleanTypeBase {
	~true = 0;
	~false = 1;
	yes = 2;
	no = 3;
}

@ExtendedMetaData(name="generic-booleanType_._base:Object", baseType="generic-booleanType_._base")
datatype GenericBooleanTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="
	<![CDATA[

	  The homeType defines the fully-qualified name of
	  an enterprise bean's home interface.

	  Example:

	      <home>com.aardvark.payroll.PayrollHome</home>

	  ]]>
      ")
@ExtendedMetaData(name="homeType", kind="simple")
class HomeType extends FullyQualifiedClassType {
}

@ExtendedMetaData(name="homeType_._base")
datatype HomeTypeBase : java.lang.String;

@GenModel(documentation="

	The icon type contains small-icon and large-icon elements
	that specify the file names for small and large GIF, JPEG,
	or PNG icon images used to represent the parent element in a
	GUI tool.

	The xml:lang attribute defines the language that the
	icon file names are provided in. Its value is \"en\" (English)
	by default.

      ")
@ExtendedMetaData(name="iconType", kind="elementOnly")
class IconType {

	@GenModel(documentation="
	    <![CDATA[

	      The small-icon element contains the name of a file
	      containing a small (16 x 16) icon image. The file
	      name is a relative path within the Deployment
	      Component's Deployment File.

	      The image may be in the GIF, JPEG, or PNG format.
	      The icon can be used by tools.

	      Example:

	      <small-icon>employee-service-icon16x16.jpg</small-icon>

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="small-icon", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PathType smallIcon;

	@GenModel(documentation="
	    <![CDATA[

	      The large-icon element contains the name of a file
	      containing a large
	      (32 x 32) icon image. The file name is a relative
	      path within the Deployment Component's Deployment
	      File.

	      The image may be in the GIF, JPEG, or PNG format.
	      The icon can be used by tools.

	      Example:

	      <large-icon>employee-service-icon32x32.jpg</large-icon>

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="large-icon", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PathType largeIcon;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;

	@GenModel(documentation="
    <div xmlns=\"http://www.w3.org/1999/xhtml\">
     
      <h3>lang (as an attribute name)</h3>
      <p>
       denotes an attribute whose value
       is a language code for the natural language of the content of
       any element; its value is inherited.  This name is reserved
       by virtue of its definition in the XML specification.</p>
     
    </div>
    <div xmlns=\"http://www.w3.org/1999/xhtml\">
     <h4>Notes</h4>
     <p>
      Attempting to install the relevant ISO 2- and 3-letter
      codes as the enumerated possible values is probably never
      going to be a realistic possibility.  
     </p>
     <p>
      See BCP 47 at <a href=\"http://www.rfc-editor.org/rfc/bcp/bcp47.txt\">
       http://www.rfc-editor.org/rfc/bcp/bcp47.txt</a>
      and the IANA language subtag registry at
      <a href=\"http://www.iana.org/assignments/language-subtag-registry\">
       http://www.iana.org/assignments/language-subtag-registry</a>
      for further information.
     </p>
     <p>
      The union allows for the 'un-declaration' of xml:lang with
      the empty string.
     </p>
    </div>
   ")
	@ExtendedMetaData(kind="attribute", name="lang", namespace="http://www.w3.org/XML/1998/namespace")
	attr namespace.LangType lang;
}

@ExtendedMetaData(name="init-methodType", kind="elementOnly")
class InitMethodType {

	@ExtendedMetaData(kind="element", name="create-method", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val NamedMethodType[1] createMethod;

	@ExtendedMetaData(kind="element", name="bean-method", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val NamedMethodType[1] beanMethod;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	An injection target specifies a class and a name within
	that class into which a resource should be injected.

	The injection target class specifies the fully qualified
	class name that is the target of the injection.  The
	Java EE specifications describe which classes can be an
	injection target.

	The injection target name specifies the target within
	the specified class.  The target is first looked for as a
	JavaBeans property name.  If not found, the target is
	looked for as a field name.

	The specified resource will be injected into the target
	during initialization of the class by either calling the
	set method for the target property or by setting a value
	into the named field.

      ")
@ExtendedMetaData(name="injection-targetType", kind="elementOnly")
class InjectionTargetType {

	@ExtendedMetaData(kind="element", name="injection-target-class", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType[1] injectionTargetClass;

	@ExtendedMetaData(kind="element", name="injection-target-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val JavaIdentifierType[1] injectionTargetName;
}

@GenModel(documentation="

        The interceptor-bindingType element describes the binding of
        interceptor classes to beans within the ejb-jar.
        It consists of :

          - An optional description.
          - The name of an ejb within the ejb-jar or the wildcard value \"*\",
            which is used to define interceptors that are bound to all
            beans in the ejb-jar.
          - A list of interceptor classes that are bound to the contents of
            the ejb-name element or a specification of the total ordering
            over the interceptors defined for the given level and above.
          - An optional exclude-default-interceptors element.  If set to true,
            specifies that default interceptors are not to be applied to
            a bean-class and/or business method.
          - An optional exclude-class-interceptors element.  If set to true,
            specifies that class interceptors are not to be applied to
            a business method.
          - An optional set of method elements for describing the name/params
            of a method-level interceptor.

         Interceptors bound to all classes using the wildcard syntax
         \"*\" are default interceptors for the components in the ejb-jar.
         In addition, interceptors may be bound at the level of the bean
         class (class-level interceptors) or business methods (method-level
         interceptors ).

         The binding of interceptors to classes is additive.  If interceptors
         are bound at the class-level and/or default-level as well as the
         method-level, both class-level and/or default-level as well as
         method-level will apply.

         There are four possible styles of the interceptor element syntax :

         1.
         <interceptor-binding xmlns=\"http://www.w3.org/2001/XMLSchema\">
           <ejb-name>*</ejb-name>
           <interceptor-class>INTERCEPTOR</interceptor-class>
         </interceptor-binding>

         Specifying the ejb-name as the wildcard value \"*\" designates
         default interceptors (interceptors that apply to all session and
         message-driven beans contained in the ejb-jar).

         2.
         <interceptor-binding xmlns=\"http://www.w3.org/2001/XMLSchema\">
           <ejb-name>EJBNAME</ejb-name>
           <interceptor-class>INTERCEPTOR</interceptor-class>
         </interceptor-binding>

         This style is used to refer to interceptors associated with the
         specified enterprise bean(class-level interceptors).

         3.
         <interceptor-binding xmlns=\"http://www.w3.org/2001/XMLSchema\">
           <ejb-name>EJBNAME</ejb-name>
           <interceptor-class>INTERCEPTOR</interceptor-class>
           <method>
             <method-name>METHOD</method-name>
           </method>
         </interceptor-binding>

         This style is used to associate a method-level interceptor with
         the specified enterprise bean.  If there are multiple methods
         with the same overloaded name, the element of this style refers
         to all the methods with the overloaded name.  Method-level
         interceptors can only be associated with business methods of the
         bean class.   Note that the wildcard value \"*\" cannot be used
         to specify method-level interceptors.

         4.
         <interceptor-binding xmlns=\"http://www.w3.org/2001/XMLSchema\">
           <ejb-name>EJBNAME</ejb-name>
           <interceptor-class>INTERCEPTOR</interceptor-class>
           <method>
             <method-name>METHOD</method-name>
             <method-params>
               <method-param>PARAM-1</method-param>
               <method-param>PARAM-2</method-param>
               ...
               <method-param>PARAM-N</method-param>
             </method-params>
           </method>
         </interceptor-binding>

         This style is used to associate a method-level interceptor with
         the specified method of the specified enterprise bean.  This
         style is used to refer to a single method within a set of methods
         with an overloaded name.  The values PARAM-1 through PARAM-N
         are the fully-qualified Java types of the method's input parameters
         (if the method has no input arguments, the method-params element
         contains no method-param elements). Arrays are specified by the
         array element's type, followed by one or more pair of square
         brackets (e.g. int[][]).

      ")
@ExtendedMetaData(name="interceptor-bindingType", kind="elementOnly")
class InterceptorBindingType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="ejb-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val String[1] ejbName;

	@ExtendedMetaData(kind="element", name="interceptor-class", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType[*] interceptorClass;

	@ExtendedMetaData(kind="element", name="interceptor-order", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val InterceptorOrderType interceptorOrder;

	@ExtendedMetaData(kind="element", name="exclude-default-interceptors", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val TrueFalseType excludeDefaultInterceptors;

	@ExtendedMetaData(kind="element", name="exclude-class-interceptors", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val TrueFalseType excludeClassInterceptors;

	@ExtendedMetaData(kind="element", name="method", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val NamedMethodType method;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="
        The interceptor-orderType element describes a total ordering
        of interceptor classes.
      ")
@ExtendedMetaData(name="interceptor-orderType", kind="elementOnly")
class InterceptorOrderType {

	@ExtendedMetaData(kind="element", name="interceptor-class", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType[+] interceptorClass;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

        The interceptorsType element declares one or more interceptor
        classes used by components within this ejb-jar.  The declaration
        consists of :

            - An optional description.
            - One or more interceptor elements.

      ")
@ExtendedMetaData(name="interceptorsType", kind="elementOnly")
class InterceptorsType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="interceptor", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val InterceptorType[+] interceptor;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

        The interceptorType element declares information about a single
        interceptor class.  It consists of :

            - An optional description.
            - The fully-qualified name of the interceptor class.
            - An optional list of around invoke methods declared on the
              interceptor class and/or its super-classes.
            - An optional list environment dependencies for the interceptor
              class and/or its super-classes.
            - An optional list of post-activate methods declared on the
              interceptor class and/or its super-classes.
            - An optional list of pre-passivate methods declared on the
              interceptor class and/or its super-classes.

      ")
@ExtendedMetaData(name="interceptorType", kind="elementOnly")
class InterceptorType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="interceptor-class", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType[1] interceptorClass;

	@ExtendedMetaData(kind="element", name="around-invoke", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val AroundInvokeType[*] aroundInvoke;

	@ExtendedMetaData(kind="element", name="env-entry", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EnvEntryType[*] envEntry;

	@ExtendedMetaData(kind="element", name="ejb-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbRefType[*] ejbRef;

	@ExtendedMetaData(kind="element", name="ejb-local-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbLocalRefType[*] ejbLocalRef;

	@ExtendedMetaData(kind="element", name="service-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ServiceRefType[*] serviceRef;

	@ExtendedMetaData(kind="element", name="resource-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ResourceRefType[*] resourceRef;

	@ExtendedMetaData(kind="element", name="resource-env-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ResourceEnvRefType[*] resourceEnvRef;

	@ExtendedMetaData(kind="element", name="message-destination-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MessageDestinationRefType[*] messageDestinationRef;

	@ExtendedMetaData(kind="element", name="persistence-context-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PersistenceContextRefType[*] persistenceContextRef;

	@ExtendedMetaData(kind="element", name="persistence-unit-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PersistenceUnitRefType[*] persistenceUnitRef;

	@ExtendedMetaData(kind="element", name="post-construct", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LifecycleCallbackType[*] postConstruct;

	@ExtendedMetaData(kind="element", name="pre-destroy", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LifecycleCallbackType[*] preDestroy;

	@ExtendedMetaData(kind="element", name="post-activate", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LifecycleCallbackType[*] postActivate;

	@ExtendedMetaData(kind="element", name="pre-passivate", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LifecycleCallbackType[*] prePassivate;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The java-identifierType defines a Java identifier.
	The users of this type should further verify that
	the content does not contain Java reserved keywords.

      ")
@ExtendedMetaData(name="java-identifierType", kind="simple")
class JavaIdentifierType extends String {
}

@ExtendedMetaData(name="java-identifierType_._base", baseType="http://www.eclipse.org/emf/2003/XMLType#token", pattern="($|_|\p{L})(\p{L}|\p{Nd}|_|$)*")
datatype JavaIdentifierTypeBase : java.lang.String;

@GenModel(documentation="

	This is a generic type that designates a Java primitive
	type or a fully qualified name of a Java interface/type,
	or an array of such types.

      ")
@ExtendedMetaData(name="java-typeType", kind="simple")
class JavaTypeType extends String {
}

@ExtendedMetaData(name="java-typeType_._base", baseType="http://www.eclipse.org/emf/2003/XMLType#token", pattern="[^\p{Z}]*")
datatype JavaTypeTypeBase : java.lang.String;

@GenModel(documentation="

	The jndi-nameType type designates a JNDI name in the
	Deployment Component's environment and is relative to the
	java:comp/env context.  A JNDI name must be unique within the
	Deployment Component.

      ")
@ExtendedMetaData(name="jndi-nameType", kind="simple")
class JndiNameType extends String {
}

@ExtendedMetaData(name="jndi-nameType_._base", baseType="http://www.eclipse.org/emf/2003/XMLType#token")
datatype JndiNameTypeBase : java.lang.String;

@GenModel(documentation="

	The lifecycle-callback type specifies a method on a
	class to be called when a lifecycle event occurs.
	Note that each class may have only one lifecycle callback
        method for any given event and that the method may not
	be overloaded.

        If the lifefycle-callback-class element is missing then
        the class defining the callback is assumed to be the
        component class in scope at the place in the descriptor
        in which the callback definition appears.

      ")
@ExtendedMetaData(name="lifecycle-callbackType", kind="elementOnly")
class LifecycleCallbackType {

	@ExtendedMetaData(kind="element", name="lifecycle-callback-class", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType lifecycleCallbackClass;

	@ExtendedMetaData(kind="element", name="lifecycle-callback-method", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val JavaIdentifierType[1] lifecycleCallbackMethod;
}

@GenModel(documentation="

	The listenerType indicates the deployment properties for a web
	application listener bean.

      ")
@ExtendedMetaData(name="listenerType", kind="elementOnly")
class ListenerType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="display-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DisplayNameType[*] displayName;

	@ExtendedMetaData(kind="element", name="icon", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val IconType[*] icon;

	@GenModel(documentation="

	    The listener-class element declares a class in the
	    application must be registered as a web
	    application listener bean. The value is the fully
	    qualified classname of the listener class.

	  ")
	@ExtendedMetaData(kind="element", name="listener-class", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType[1] listenerClass;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The local-homeType defines the fully-qualified
	name of an enterprise bean's local home interface.

      ")
@ExtendedMetaData(name="local-homeType", kind="simple")
class LocalHomeType extends FullyQualifiedClassType {
}

@ExtendedMetaData(name="local-homeType_._base")
datatype LocalHomeTypeBase : java.lang.String;

@GenModel(documentation="

	The localType defines the fully-qualified name of an
	enterprise bean's local interface.

      ")
@ExtendedMetaData(name="localType", kind="simple")
class LocalType extends FullyQualifiedClassType {
}

@ExtendedMetaData(name="localType_._base")
datatype LocalTypeBase : java.lang.String;

@GenModel(documentation="

	The message-destination-linkType is used to link a message
	destination reference or message-driven bean to a message
	destination.

	The Assembler sets the value to reflect the flow of messages
	between producers and consumers in the application.

	The value must be the message-destination-name of a message
	destination in the same Deployment File or in another
	Deployment File in the same Java EE application unit.

	Alternatively, the value may be composed of a path name
	specifying a Deployment File containing the referenced
	message destination with the message-destination-name of the
	destination appended and separated from the path name by
	\"#\". The path name is relative to the Deployment File
	containing Deployment Component that is referencing the
	message destination.  This allows multiple message
	destinations with the same name to be uniquely identified.

      ")
@ExtendedMetaData(name="message-destination-linkType", kind="simple")
class MessageDestinationLinkType extends String {
}

@ExtendedMetaData(name="message-destination-linkType_._base", baseType="http://www.eclipse.org/emf/2003/XMLType#token")
datatype MessageDestinationLinkTypeBase : java.lang.String;

@GenModel(documentation="
	<![CDATA[

	  The message-destination-ref element contains a declaration
	  of Deployment Component's reference to a message destination
	  associated with a resource in Deployment Component's
	  environment. It consists of:

		  - an optional description
		  - the message destination reference name
		  - an optional message destination type
		  - an optional specification as to whether
		    the destination is used for
		    consuming or producing messages, or both.
		    if not specified, \"both\" is assumed.
		  - an optional link to the message destination
		  - optional injection targets

	  The message destination type must be supplied unless an
	  injection target is specified, in which case the type
	  of the target is used.  If both are specified, the type
	  must be assignment compatible with the type of the injection
	  target.

	  Examples:

	  <message-destination-ref>
		  <message-destination-ref-name>jms/StockQueue
		  </message-destination-ref-name>
		  <message-destination-type>javax.jms.Queue
		  </message-destination-type>
		  <message-destination-usage>Consumes
		  </message-destination-usage>
		  <message-destination-link>CorporateStocks
		  </message-destination-link>
	  </message-destination-ref>

	  ]]>
      ")
@ExtendedMetaData(name="message-destination-refType", kind="elementOnly")
class MessageDestinationRefType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@GenModel(documentation="

	    The message-destination-ref-name element specifies
	    the name of a message destination reference; its
	    value is the environment entry name used in
	    Deployment Component code.  The name is a JNDI name
	    relative to the java:comp/env context and must be
	    unique within an ejb-jar (for enterprise beans) or a
	    Deployment File (for others).

	  ")
	@ExtendedMetaData(kind="element", name="message-destination-ref-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val JndiNameType[1] messageDestinationRefName;

	@ExtendedMetaData(kind="element", name="message-destination-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MessageDestinationTypeType messageDestinationType;

	@ExtendedMetaData(kind="element", name="message-destination-usage", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MessageDestinationUsageType messageDestinationUsage;

	@ExtendedMetaData(kind="element", name="message-destination-link", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MessageDestinationLinkType messageDestinationLink;

	@GenModel(documentation="
	    <![CDATA[

	      A product specific name that this resource should be
	      mapped to.  The name of this resource, as defined by the
	      resource's name element or defaulted, is a name that is
	      local to the application component using the resource.
	      (It's a name in the JNDI java:comp/env namespace.)  Many
	      application servers provide a way to map these local
	      names to names of resources known to the application
	      server.  This mapped name is often a global JNDI name,
	      but may be a name of any form.

	      Application servers are not required to support any
	      particular form or type of mapped name, nor the ability
	      to use mapped names.  The mapped name is
	      product-dependent and often installation-dependent.  No
	      use of a mapped name is portable.

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="mapped-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType mappedName;

	@ExtendedMetaData(kind="element", name="injection-target", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val InjectionTargetType[*] injectionTarget;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="
	<![CDATA[

	  The message-destinationType specifies a message
	  destination. The logical destination described by this
	  element is mapped to a physical destination by the Deployer.

	  The message destination element contains:

		  - an optional description
		  - an optional display-name
		  - an optional icon
		  - a message destination name which must be unique
		    among message destination names within the same
		    Deployment File.
		  - an optional mapped name

	  Example:

	  <message-destination>
		  <message-destination-name>CorporateStocks
		  </message-destination-name>
	  </message-destination>

	  ]]>
      ")
@ExtendedMetaData(name="message-destinationType", kind="elementOnly")
class MessageDestinationType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="display-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DisplayNameType[*] displayName;

	@ExtendedMetaData(kind="element", name="icon", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val IconType[*] icon;

	@GenModel(documentation="

	    The message-destination-name element specifies a
	    name for a message destination.  This name must be
	    unique among the names of message destinations
	    within the Deployment File.

	  ")
	@ExtendedMetaData(kind="element", name="message-destination-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val String[1] messageDestinationName;

	@GenModel(documentation="
	    <![CDATA[

	      A product specific name that this message destination
	      should be mapped to.  Each message-destination-ref
	      element that references this message destination will
	      define a name in the namespace of the referencing
	      component.  (It's a name in the JNDI java:comp/env
	      namespace.)  Many application servers provide a way to
	      map these local names to names of resources known to the
	      application server.  This mapped name is often a global
	      JNDI name, but may be a name of any form.  Each of the
	      local names should be mapped to this same global name.

	      Application servers are not required to support any
	      particular form or type of mapped name, nor the ability
	      to use mapped names.  The mapped name is
	      product-dependent and often installation-dependent.  No
	      use of a mapped name is portable.

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="mapped-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType mappedName;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="
	<![CDATA[

	  The message-destination-typeType specifies the type of
	  the destination. The type is specified by the Java interface
	  expected to be implemented by the destination.

	  Example:

	    <message-destination-type>javax.jms.Queue
	    </message-destination-type>

	  ]]>
      ")
@ExtendedMetaData(name="message-destination-typeType", kind="simple")
class MessageDestinationTypeType extends FullyQualifiedClassType {
}

@ExtendedMetaData(name="message-destination-typeType_._base")
datatype MessageDestinationTypeTypeBase : java.lang.String;

@GenModel(documentation="

	The message-destination-usageType specifies the use of the
	message destination indicated by the reference.  The value
	indicates whether messages are consumed from the message
	destination, produced for the destination, or both.  The
	Assembler makes use of this information in linking producers
	of a destination with its consumers.

	The value of the message-destination-usage element must be
	one of the following:
	    Consumes
	    Produces
	    ConsumesProduces

      ")
@ExtendedMetaData(name="message-destination-usageType", kind="simple")
class MessageDestinationUsageType extends String {
}

@ExtendedMetaData(name="message-destination-usageType_._base")
enum MessageDestinationUsageTypeBase {
	Consumes = 0;
	Produces = 1;
	ConsumesProduces = 2;
}

@ExtendedMetaData(name="message-destination-usageType_._base:Object", baseType="message-destination-usageType_._base")
datatype MessageDestinationUsageTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="

	The message-driven element declares a message-driven
	bean. The declaration consists of:

	    - an optional description
	    - an optional display name
	    - an optional icon element that contains a small and a large
	      icon file name.
	    - a name assigned to the enterprise bean in
	      the deployment descriptor
            - an optional mapped-name element that can be used to provide
              vendor-specific deployment information such as the physical
              jndi-name of destination from which this message-driven bean
              should consume.  This element is not required to be supported
              by all implementations.  Any use of this element is non-portable.
	    - the message-driven bean's implementation class
	    - an optional declaration of the bean's messaging
	      type
            - an optional declaration of the bean's timeout method.
	    - the optional message-driven bean's transaction management
              type. If it is not defined, it is defaulted to Container.
	    - an optional declaration of the bean's
	      message-destination-type
	    - an optional declaration of the bean's
	      message-destination-link
	    - an optional declaration of the message-driven bean's
	      activation configuration properties
            - an optional list of the message-driven bean class and/or
              superclass around-invoke methods.
	    - an optional declaration of the bean's environment
	      entries
	    - an optional declaration of the bean's EJB references
	    - an optional declaration of the bean's local EJB
	      references
	    - an optional declaration of the bean's web service
	      references
	    - an optional declaration of the security
	      identity to be used for the execution of the bean's
	      methods
	    - an optional declaration of the bean's
	      resource manager connection factory
	      references
	    - an optional declaration of the bean's resource
	      environment references.
	    - an optional declaration of the bean's message
	      destination references

      ")
@ExtendedMetaData(name="message-driven-beanType", kind="elementOnly")
class MessageDrivenBeanType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="display-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DisplayNameType[*] displayName;

	@ExtendedMetaData(kind="element", name="icon", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val IconType[*] icon;

	@ExtendedMetaData(kind="element", name="ejb-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbNameType[1] ejbName;

	@ExtendedMetaData(kind="element", name="mapped-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType mappedName;

	@GenModel(documentation="

             The ejb-class element specifies the fully qualified name
             of the bean class for this ejb.  It is required unless
             there is a component-defining annotation for the same
             ejb-name.

          ")
	@ExtendedMetaData(kind="element", name="ejb-class", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbClassType ejbClass;

	@GenModel(documentation="

	    The messaging-type element specifies the message
	    listener interface of the message-driven bean.

	  ")
	@ExtendedMetaData(kind="element", name="messaging-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType messagingType;

	@ExtendedMetaData(kind="element", name="timeout-method", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val NamedMethodType timeoutMethod;

	@ExtendedMetaData(kind="element", name="transaction-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val TransactionTypeType transactionType;

	@ExtendedMetaData(kind="element", name="message-destination-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MessageDestinationTypeType messageDestinationType;

	@ExtendedMetaData(kind="element", name="message-destination-link", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MessageDestinationLinkType messageDestinationLink;

	@ExtendedMetaData(kind="element", name="activation-config", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ActivationConfigType activationConfig;

	@ExtendedMetaData(kind="element", name="around-invoke", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val AroundInvokeType[*] aroundInvoke;

	@ExtendedMetaData(kind="element", name="env-entry", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EnvEntryType[*] envEntry;

	@ExtendedMetaData(kind="element", name="ejb-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbRefType[*] ejbRef;

	@ExtendedMetaData(kind="element", name="ejb-local-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbLocalRefType[*] ejbLocalRef;

	@ExtendedMetaData(kind="element", name="service-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ServiceRefType[*] serviceRef;

	@ExtendedMetaData(kind="element", name="resource-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ResourceRefType[*] resourceRef;

	@ExtendedMetaData(kind="element", name="resource-env-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ResourceEnvRefType[*] resourceEnvRef;

	@ExtendedMetaData(kind="element", name="message-destination-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MessageDestinationRefType[*] messageDestinationRef;

	@ExtendedMetaData(kind="element", name="persistence-context-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PersistenceContextRefType[*] persistenceContextRef;

	@ExtendedMetaData(kind="element", name="persistence-unit-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PersistenceUnitRefType[*] persistenceUnitRef;

	@ExtendedMetaData(kind="element", name="post-construct", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LifecycleCallbackType[*] postConstruct;

	@ExtendedMetaData(kind="element", name="pre-destroy", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LifecycleCallbackType[*] preDestroy;

	@ExtendedMetaData(kind="element", name="security-identity", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val SecurityIdentityType securityIdentity;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The method-intf element allows a method element to
	differentiate between the methods with the same name and
	signature that are multiply defined across the home and
	component interfaces (e.g, in both an enterprise bean's
	remote and local interfaces or in both an enterprise bean's
	home and remote interfaces, etc.); the component and web
	service endpoint interfaces, and so on. The Local applies to
        both local component interface and local business interface.
        Similarly, Remote applies to both remote component interface
        and the remote business interface.

	The method-intf element must be one of the following:

	    Home
	    Remote
	    LocalHome
	    Local
	    ServiceEndpoint

      ")
@ExtendedMetaData(name="method-intfType", kind="simple")
class MethodIntfType extends String {
}

@ExtendedMetaData(name="method-intfType_._base")
enum MethodIntfTypeBase {
	Home = 0;
	Remote = 1;
	LocalHome = 2;
	Local = 3;
	ServiceEndpoint = 4;
}

@ExtendedMetaData(name="method-intfType_._base:Object", baseType="method-intfType_._base")
datatype MethodIntfTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="

	The method-nameType contains a name of an enterprise
	bean method or the asterisk (*) character. The asterisk is
	used when the element denotes all the methods of an
	enterprise bean's client view interfaces.

      ")
@ExtendedMetaData(name="method-nameType", kind="simple")
class MethodNameType extends String {
}

@ExtendedMetaData(name="method-nameType_._base", baseType="http://www.eclipse.org/emf/2003/XMLType#token")
datatype MethodNameTypeBase : java.lang.String;

@GenModel(documentation="

	The method-paramsType defines a list of the
	fully-qualified Java type names of the method parameters.

      ")
@ExtendedMetaData(name="method-paramsType", kind="elementOnly")
class MethodParamsType {

	@GenModel(documentation="

	    The method-param element contains a primitive
	    or a fully-qualified Java type name of a method
	    parameter.

	  ")
	@ExtendedMetaData(kind="element", name="method-param", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val JavaTypeType[*] methodParam;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The method-permissionType specifies that one or more
	security roles are allowed to invoke one or more enterprise
	bean methods. The method-permissionType consists of an
	optional description, a list of security role names or an
	indicator to state that the method is unchecked for
	authorization, and a list of method elements.

	The security roles used in the method-permissionType
	must be defined in the security-role elements of the
	deployment descriptor, and the methods must be methods
	defined in the enterprise bean's business, home, component
        and/or web service endpoint interfaces.

      ")
@ExtendedMetaData(name="method-permissionType", kind="elementOnly")
class MethodPermissionType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="role-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val RoleNameType[*] roleName;

	@GenModel(documentation="

	      The unchecked element specifies that a method is
	      not checked for authorization by the container
	      prior to invocation of the method.

	    ")
	@ExtendedMetaData(kind="element", name="unchecked", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EmptyType unchecked;

	@ExtendedMetaData(kind="element", name="method", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MethodType[+] method;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="
	<![CDATA[

	  The methodType is used to denote a method of an enterprise
	  bean's business, home, component, and/or web service endpoint
	  interface, or, in the case of a message-driven bean, the
	  bean's message listener method, or a set of such
	  methods. The ejb-name element must be the name of one of the
	  enterprise beans declared in the deployment descriptor; the
	  optional method-intf element allows to distinguish between a
	  method with the same signature that is multiply defined
	  across the business, home, component, and/or web service
          endpoint nterfaces; the method-name element specifies the
          method name; and the optional method-params elements identify
          a single method among multiple methods with an overloaded
	  method name.

	  There are three possible styles of using methodType element
	  within a method element:

	  1.
	  <method>
	      <ejb-name>EJBNAME</ejb-name>
	      <method-name>*</method-name>
	  </method>

	     This style is used to refer to all the methods of the
	     specified enterprise bean's business, home, component,
             and/or web service endpoint interfaces.

	  2.
	  <method>
	      <ejb-name>EJBNAME</ejb-name>
	      <method-name>METHOD</method-name>
	  </method>

	     This style is used to refer to the specified method of
	     the specified enterprise bean. If there are multiple
	     methods with the same overloaded name, the element of
	     this style refers to all the methods with the overloaded
	     name.

	  3.
	  <method>
	      <ejb-name>EJBNAME</ejb-name>
	      <method-name>METHOD</method-name>
	      <method-params>
		  <method-param>PARAM-1</method-param>
		  <method-param>PARAM-2</method-param>
		  ...
		  <method-param>PARAM-n</method-param>
	      </method-params>
	  </method>

	     This style is used to refer to a single method within a
	     set of methods with an overloaded name. PARAM-1 through
	     PARAM-n are the fully-qualified Java types of the
	     method's input parameters (if the method has no input
	     arguments, the method-params element contains no
	     method-param elements). Arrays are specified by the
	     array element's type, followed by one or more pair of
	     square brackets (e.g. int[][]). If there are multiple
	     methods with the same overloaded name, this style refers
	     to all of the overloaded methods.

	  Examples:

	  Style 1: The following method element refers to all the
	  methods of the EmployeeService bean's business, home,
          component, and/or web service endpoint interfaces:

	  <method>
	      <ejb-name>EmployeeService</ejb-name>
	      <method-name>*</method-name>
	  </method>

	  Style 2: The following method element refers to all the
	  create methods of the EmployeeService bean's home
	  interface(s).

	  <method>
	      <ejb-name>EmployeeService</ejb-name>
	      <method-name>create</method-name>
	  </method>

	  Style 3: The following method element refers to the
	  create(String firstName, String LastName) method of the
	  EmployeeService bean's home interface(s).

	  <method>
	      <ejb-name>EmployeeService</ejb-name>
	      <method-name>create</method-name>
	      <method-params>
		  <method-param>java.lang.String</method-param>
		  <method-param>java.lang.String</method-param>
	      </method-params>
	  </method>

	  The following example illustrates a Style 3 element with
	  more complex parameter types. The method
	  foobar(char s, int i, int[] iar, mypackage.MyClass mycl,
	  mypackage.MyClass[][] myclaar) would be specified as:

	  <method>
	      <ejb-name>EmployeeService</ejb-name>
	      <method-name>foobar</method-name>
	      <method-params>
		  <method-param>char</method-param>
		  <method-param>int</method-param>
		  <method-param>int[]</method-param>
		  <method-param>mypackage.MyClass</method-param>
		  <method-param>mypackage.MyClass[][]</method-param>
	      </method-params>
	  </method>

	  The optional method-intf element can be used when it becomes
	  necessary to differentiate between a method that is multiply
	  defined across the enterprise bean's business, home, component,
          and/or web service endpoint interfaces with the same name and
	  signature. However, if the same method is a method of both the
          local business interface, and the local component interface,
          the same attribute applies to the method for both interfaces.
          Likewise, if the same method is a method of both the remote
          business interface and the remote component interface, the same
          attribute applies to the method for both interfaces.

	  For example, the method element

	  <method>
	      <ejb-name>EmployeeService</ejb-name>
	      <method-intf>Remote</method-intf>
	      <method-name>create</method-name>
	      <method-params>
		  <method-param>java.lang.String</method-param>
		  <method-param>java.lang.String</method-param>
	      </method-params>
	  </method>

	  can be used to differentiate the create(String, String)
	  method defined in the remote interface from the
	  create(String, String) method defined in the remote home
	  interface, which would be defined as

	  <method>
	      <ejb-name>EmployeeService</ejb-name>
	      <method-intf>Home</method-intf>
	      <method-name>create</method-name>
	      <method-params>
		  <method-param>java.lang.String</method-param>
		  <method-param>java.lang.String</method-param>
	      </method-params>
	  </method>

	  and the create method that is defined in the local home
	  interface which would be defined as

	  <method>
	      <ejb-name>EmployeeService</ejb-name>
	      <method-intf>LocalHome</method-intf>
	      <method-name>create</method-name>
	      <method-params>
		  <method-param>java.lang.String</method-param>
		  <method-param>java.lang.String</method-param>
	      </method-params>
	  </method>

	  The method-intf element can be used with all three Styles
	  of the method element usage. For example, the following
	  method element example could be used to refer to all the
	  methods of the EmployeeService bean's remote home interface
          and the remote business interface.

	  <method>
	      <ejb-name>EmployeeService</ejb-name>
	      <method-intf>Home</method-intf>
	      <method-name>*</method-name>
	  </method>

	  ]]>
      ")
@ExtendedMetaData(name="methodType", kind="elementOnly")
class MethodType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="ejb-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbNameType[1] ejbName;

	@ExtendedMetaData(kind="element", name="method-intf", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MethodIntfType methodIntf;

	@ExtendedMetaData(kind="element", name="method-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MethodNameType[1] methodName;

	@ExtendedMetaData(kind="element", name="method-params", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MethodParamsType methodParams;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The multiplicityType describes the multiplicity of the
	role that participates in a relation.

	The value must be one of the two following:

	    One
	    Many

      ")
@ExtendedMetaData(name="multiplicityType", kind="simple")
class MultiplicityType extends String {
}

@ExtendedMetaData(name="multiplicityType_._base")
enum MultiplicityTypeBase {
	One = 0;
	Many = 1;
}

@ExtendedMetaData(name="multiplicityType_._base:Object", baseType="multiplicityType_._base")
datatype MultiplicityTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@ExtendedMetaData(name="named-methodType", kind="elementOnly")
class NamedMethodType {

	@ExtendedMetaData(kind="element", name="method-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val String[1] methodName;

	@ExtendedMetaData(kind="element", name="method-params", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MethodParamsType methodParams;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	This type is a general type that can be used to declare
	parameter/value lists.

      ")
@ExtendedMetaData(name="param-valueType", kind="elementOnly")
class ParamValueType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@GenModel(documentation="

	    The param-name element contains the name of a
	    parameter.

	  ")
	@ExtendedMetaData(kind="element", name="param-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val String[1] paramName;

	@GenModel(documentation="

	    The param-value element contains the value of a
	    parameter.

	  ")
	@ExtendedMetaData(kind="element", name="param-value", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType[1] paramValue;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The elements that use this type designate either a relative
	path or an absolute path starting with a \"/\".

	In elements that specify a pathname to a file within the
	same Deployment File, relative filenames (i.e., those not
	starting with \"/\") are considered relative to the root of
	the Deployment File's namespace.  Absolute filenames (i.e.,
	those starting with \"/\") also specify names in the root of
	the Deployment File's namespace.  In general, relative names
	are preferred.  The exception is .war files where absolute
	names are preferred for consistency with the Servlet API.

      ")
@ExtendedMetaData(name="pathType", kind="simple")
class PathType extends String {
}

@ExtendedMetaData(name="pathType_._base", baseType="http://www.eclipse.org/emf/2003/XMLType#token")
datatype PathTypeBase : java.lang.String;

@GenModel(documentation="
	<![CDATA[

	  The persistence-context-ref element contains a declaration
	  of Deployment Component's reference to a persistence context
	  associated within a Deployment Component's
	  environment. It consists of:

		  - an optional description
		  - the persistence context reference name
		  - an optional persistence unit name.  If not specified,
                    the default persistence unit is assumed.
		  - an optional specification as to whether
		    the persistence context type is Transaction or
		    Extended.  If not specified, Transaction is assumed.
                  - an optional list of persistence properties
		  - optional injection targets

	  Examples:

            <persistence-context-ref>
              <persistence-context-ref-name>myPersistenceContext
              </persistence-context-ref-name>
            </persistence-context-ref>

            <persistence-context-ref>
              <persistence-context-ref-name>myPersistenceContext
                </persistence-context-ref-name>
              <persistence-unit-name>PersistenceUnit1
                </persistence-unit-name>
              <persistence-context-type>Extended</persistence-context-type>
            </persistence-context-ref>

	  ]]>
      ")
@ExtendedMetaData(name="persistence-context-refType", kind="elementOnly")
class PersistenceContextRefType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@GenModel(documentation="

	    The persistence-context-ref-name element specifies
	    the name of a persistence context reference; its
	    value is the environment entry name used in
	    Deployment Component code.  The name is a JNDI name
	    relative to the java:comp/env context.

	  ")
	@ExtendedMetaData(kind="element", name="persistence-context-ref-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val JndiNameType[1] persistenceContextRefName;

	@GenModel(documentation="

            The Application Assembler(or BeanProvider) may use the
            following syntax to avoid the need to rename persistence
            units to have unique names within a Java EE application.

            The Application Assembler specifies the pathname of the
            root of the persistence.xml file for the referenced
            persistence unit and appends the name of the persistence
            unit separated from the pathname by #. The pathname is
            relative to the referencing application component jar file.
            In this manner, multiple persistence units with the same
            persistence unit name may be uniquely identified when the
            Application Assembler cannot change persistence unit names.

	  ")
	@ExtendedMetaData(kind="element", name="persistence-unit-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val String persistenceUnitName;

	@ExtendedMetaData(kind="element", name="persistence-context-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PersistenceContextTypeType persistenceContextType;

	@GenModel(documentation="

            Used to specify properties for the container or persistence
            provider.  Vendor-specific properties may be included in
            the set of properties.  Properties that are not recognized
            by a vendor must be ignored.  Entries that make use of the
            namespace javax.persistence and its subnamespaces must not
            be used for vendor-specific properties.  The namespace
            javax.persistence is reserved for use by the specification.

	  ")
	@ExtendedMetaData(kind="element", name="persistence-property", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PropertyType[*] persistenceProperty;

	@GenModel(documentation="
	    <![CDATA[

	      A product specific name that this resource should be
	      mapped to.  The name of this resource, as defined by the
	      resource's name element or defaulted, is a name that is
	      local to the application component using the resource.
	      (It's a name in the JNDI java:comp/env namespace.)  Many
	      application servers provide a way to map these local
	      names to names of resources known to the application
	      server.  This mapped name is often a global JNDI name,
	      but may be a name of any form.

	      Application servers are not required to support any
	      particular form or type of mapped name, nor the ability
	      to use mapped names.  The mapped name is
	      product-dependent and often installation-dependent.  No
	      use of a mapped name is portable.

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="mapped-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType mappedName;

	@ExtendedMetaData(kind="element", name="injection-target", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val InjectionTargetType[*] injectionTarget;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The persistence-context-typeType specifies the transactional
	nature of a persistence context reference.

	The value of the persistence-context-type element must be
	one of the following:
	    Transaction
            Extended

      ")
@ExtendedMetaData(name="persistence-context-typeType", kind="simple")
class PersistenceContextTypeType extends String {
}

@ExtendedMetaData(name="persistence-context-typeType_._base")
enum PersistenceContextTypeTypeBase {
	Transaction = 0;
	Extended = 1;
}

@ExtendedMetaData(name="persistence-context-typeType_._base:Object", baseType="persistence-context-typeType_._base")
datatype PersistenceContextTypeTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="

	The persistence-typeType specifies an entity bean's persistence
	management type.

	The persistence-type element must be one of the two following:

	    Bean
	    Container

      ")
@ExtendedMetaData(name="persistence-typeType", kind="simple")
class PersistenceTypeType extends String {
}

@ExtendedMetaData(name="persistence-typeType_._base")
enum PersistenceTypeTypeBase {
	Bean = 0;
	Container = 1;
}

@ExtendedMetaData(name="persistence-typeType_._base:Object", baseType="persistence-typeType_._base")
datatype PersistenceTypeTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="
	<![CDATA[

	  The persistence-unit-ref element contains a declaration
	  of Deployment Component's reference to a persistence unit
	  associated within a Deployment Component's
	  environment. It consists of:

		  - an optional description
		  - the persistence unit reference name
		  - an optional persistence unit name.  If not specified,
                    the default persistence unit is assumed.
		  - optional injection targets

	  Examples:

            <persistence-unit-ref>
              <persistence-unit-ref-name>myPersistenceUnit
              </persistence-unit-ref-name>
            </persistence-unit-ref>

            <persistence-unit-ref>
              <persistence-unit-ref-name>myPersistenceUnit
                </persistence-unit-ref-name>
              <persistence-unit-name>PersistenceUnit1
                </persistence-unit-name>
            </persistence-unit-ref>

	  ]]>
      ")
@ExtendedMetaData(name="persistence-unit-refType", kind="elementOnly")
class PersistenceUnitRefType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@GenModel(documentation="

	    The persistence-unit-ref-name element specifies
	    the name of a persistence unit reference; its
	    value is the environment entry name used in
	    Deployment Component code.  The name is a JNDI name
	    relative to the java:comp/env context.

	  ")
	@ExtendedMetaData(kind="element", name="persistence-unit-ref-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val JndiNameType[1] persistenceUnitRefName;

	@GenModel(documentation="

            The Application Assembler(or BeanProvider) may use the
            following syntax to avoid the need to rename persistence
            units to have unique names within a Java EE application.

            The Application Assembler specifies the pathname of the
            root of the persistence.xml file for the referenced
            persistence unit and appends the name of the persistence
            unit separated from the pathname by #. The pathname is
            relative to the referencing application component jar file.
            In this manner, multiple persistence units with the same
            persistence unit name may be uniquely identified when the
            Application Assembler cannot change persistence unit names.

	  ")
	@ExtendedMetaData(kind="element", name="persistence-unit-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val String persistenceUnitName;

	@GenModel(documentation="
	    <![CDATA[

	      A product specific name that this resource should be
	      mapped to.  The name of this resource, as defined by the
	      resource's name element or defaulted, is a name that is
	      local to the application component using the resource.
	      (It's a name in the JNDI java:comp/env namespace.)  Many
	      application servers provide a way to map these local
	      names to names of resources known to the application
	      server.  This mapped name is often a global JNDI name,
	      but may be a name of any form.

	      Application servers are not required to support any
	      particular form or type of mapped name, nor the ability
	      to use mapped names.  The mapped name is
	      product-dependent and often installation-dependent.  No
	      use of a mapped name is portable.

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="mapped-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType mappedName;

	@ExtendedMetaData(kind="element", name="injection-target", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val InjectionTargetType[*] injectionTarget;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The port-component-ref element declares a client dependency
	on the container for resolving a Service Endpoint Interface
	to a WSDL port. It optionally associates the Service Endpoint
	Interface with a particular port-component. This is only used
	by the container for a Service.getPort(Class) method call.

      ")
@ExtendedMetaData(name="port-component-refType", kind="elementOnly")
class PortComponentRefType {

	@GenModel(documentation="

	    The service-endpoint-interface element defines a fully qualified
	    Java class that represents the Service Endpoint Interface of a
	    WSDL port.

	  ")
	@ExtendedMetaData(kind="element", name="service-endpoint-interface", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType[1] serviceEndpointInterface;

	@GenModel(documentation="

            Used to enable or disable SOAP MTOM/XOP mechanism on the client
	    side for a port-component.

	    Not to be specified for JAX-RPC runtime
          ")
	@ExtendedMetaData(kind="element", name="enable-mtom", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val TrueFalseType enableMtom;

	@GenModel(documentation="

	    The port-component-link element links a port-component-ref
	    to a specific port-component required to be made available
	    by a service reference.

	    The value of a port-component-link must be the
	    port-component-name of a port-component in the same module
	    or another module in the same application unit. The syntax
	    for specification follows the syntax defined for ejb-link
	    in the EJB 2.0 specification.

	  ")
	@ExtendedMetaData(kind="element", name="port-component-link", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val String portComponentLink;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	Specifies a name/value pair.

      ")
@ExtendedMetaData(name="propertyType", kind="elementOnly")
class PropertyType {

	@ExtendedMetaData(kind="element", name="name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType[1] name;

	@ExtendedMetaData(kind="element", name="value", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType[1] value;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="
	<![CDATA[

	  The query-method specifies the method for a finder or select
	  query.

	  The method-name element specifies the name of a finder or select
	  method in the entity bean's implementation class.

	  Each method-param must be defined for a query-method using the
	  method-params element.

	  It is used by the query-method element.

	  Example:

	  <query>
	      <description>Method finds large orders</description>
	      <query-method>
		  <method-name>findLargeOrders</method-name>
		  <method-params></method-params>
	      </query-method>
	      <ejb-ql>
		SELECT OBJECT(o) FROM Order o
		  WHERE o.amount &gt; 1000
	      </ejb-ql>
	  </query>

	  ]]>
      ")
@ExtendedMetaData(name="query-methodType", kind="elementOnly")
class QueryMethodType {

	@ExtendedMetaData(kind="element", name="method-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MethodNameType[1] methodName;

	@ExtendedMetaData(kind="element", name="method-params", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MethodParamsType[1] methodParams;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The queryType defines a finder or select
	query. It contains
	    - an optional description of the query
	    - the specification of the finder or select
	      method it is used by
		- an optional specification of the result type
		  mapping, if the query is for a select method
		  and entity objects are returned.
		- the EJB QL query string that defines the query.

	Queries that are expressible in EJB QL must use the ejb-ql
	element to specify the query. If a query is not expressible
	in EJB QL, the description element should be used to
	describe the semantics of the query and the ejb-ql element
	should be empty.

	The result-type-mapping is an optional element. It can only
	be present if the query-method specifies a select method
	that returns entity objects.  The default value for the
	result-type-mapping element is \"Local\".

      ")
@ExtendedMetaData(name="queryType", kind="elementOnly")
class QueryType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType description;

	@ExtendedMetaData(kind="element", name="query-method", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val QueryMethodType[1] queryMethod;

	@ExtendedMetaData(kind="element", name="result-type-mapping", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ResultTypeMappingType resultTypeMapping;

	@ExtendedMetaData(kind="element", name="ejb-ql", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType[1] ejbQl;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The relationship-role-sourceType designates the source of a
	role that participates in a relationship. A
	relationship-role-sourceType is used by
	relationship-role-source elements to uniquely identify an
	entity bean.

      ")
@ExtendedMetaData(name="relationship-role-sourceType", kind="elementOnly")
class RelationshipRoleSourceType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="ejb-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbNameType[1] ejbName;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The relationshipsType describes the relationships in
	which entity beans with container-managed persistence
	participate. The relationshipsType contains an optional
	description; and a list of ejb-relation elements, which
	specify the container managed relationships.

      ")
@ExtendedMetaData(name="relationshipsType", kind="elementOnly")
class RelationshipsType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="ejb-relation", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbRelationType[+] ejbRelation;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="
	<![CDATA[

	  The remote element contains the fully-qualified name
	  of the enterprise bean's remote interface.

	  Example:

	      <remote>com.wombat.empl.EmployeeService</remote>

	  ]]>
      ")
@ExtendedMetaData(name="remoteType", kind="simple")
class RemoteType extends FullyQualifiedClassType {
}

@ExtendedMetaData(name="remoteType_._base")
datatype RemoteTypeBase : java.lang.String;

@ExtendedMetaData(name="remove-methodType", kind="elementOnly")
class RemoveMethodType {

	@ExtendedMetaData(kind="element", name="bean-method", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val NamedMethodType[1] beanMethod;

	@ExtendedMetaData(kind="element", name="retain-if-exception", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val TrueFalseType retainIfException;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The res-authType specifies whether the Deployment Component
	code signs on programmatically to the resource manager, or
	whether the Container will sign on to the resource manager
	on behalf of the Deployment Component. In the latter case,
	the Container uses information that is supplied by the
	Deployer.

	The value must be one of the two following:

	    Application
	    Container

      ")
@ExtendedMetaData(name="res-authType", kind="simple")
class ResAuthType extends String {
}

@ExtendedMetaData(name="res-authType_._base")
enum ResAuthTypeBase {
	Application = 0;
	Container = 1;
}

@ExtendedMetaData(name="res-authType_._base:Object", baseType="res-authType_._base")
datatype ResAuthTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="
	<![CDATA[

	  The resource-env-refType is used to define
	  resource-env-type elements.  It contains a declaration of a
	  Deployment Component's reference to an administered object
	  associated with a resource in the Deployment Component's
	  environment.  It consists of an optional description, the
	  resource environment reference name, and an optional
	  indication of the resource environment reference type
	  expected by the Deployment Component code.

	  It also includes optional elements to define injection of
	  the named resource into fields or JavaBeans properties.

	  The resource environment type must be supplied unless an
	  injection target is specified, in which case the type
	  of the target is used.  If both are specified, the type
	  must be assignment compatible with the type of the injection
	  target.

	  Example:

	  <resource-env-ref>
	      <resource-env-ref-name>jms/StockQueue
	      </resource-env-ref-name>
	      <resource-env-ref-type>javax.jms.Queue
	      </resource-env-ref-type>
	  </resource-env-ref>

	  ]]>
      ")
@ExtendedMetaData(name="resource-env-refType", kind="elementOnly")
class ResourceEnvRefType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@GenModel(documentation="

	    The resource-env-ref-name element specifies the name
	    of a resource environment reference; its value is
	    the environment entry name used in
	    the Deployment Component code.  The name is a JNDI
	    name relative to the java:comp/env context and must
	    be unique within a Deployment Component.

	  ")
	@ExtendedMetaData(kind="element", name="resource-env-ref-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val JndiNameType[1] resourceEnvRefName;

	@GenModel(documentation="

	    The resource-env-ref-type element specifies the type
	    of a resource environment reference.  It is the
	    fully qualified name of a Java language class or
	    interface.

	  ")
	@ExtendedMetaData(kind="element", name="resource-env-ref-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType resourceEnvRefType;

	@GenModel(documentation="
	    <![CDATA[

	      A product specific name that this resource should be
	      mapped to.  The name of this resource, as defined by the
	      resource's name element or defaulted, is a name that is
	      local to the application component using the resource.
	      (It's a name in the JNDI java:comp/env namespace.)  Many
	      application servers provide a way to map these local
	      names to names of resources known to the application
	      server.  This mapped name is often a global JNDI name,
	      but may be a name of any form.

	      Application servers are not required to support any
	      particular form or type of mapped name, nor the ability
	      to use mapped names.  The mapped name is
	      product-dependent and often installation-dependent.  No
	      use of a mapped name is portable.

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="mapped-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType mappedName;

	@ExtendedMetaData(kind="element", name="injection-target", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val InjectionTargetType[*] injectionTarget;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="
	<![CDATA[

	  The resource-refType contains a declaration of a
	  Deployment Component's reference to an external resource. It
	  consists of an optional description, the resource manager
	  connection factory reference name, an optional indication of
	  the resource manager connection factory type expected by the
	  Deployment Component code, an optional type of authentication
	  (Application or Container), and an optional specification of
	  the shareability of connections obtained from the resource
	  (Shareable or Unshareable).

	  It also includes optional elements to define injection of
	  the named resource into fields or JavaBeans properties.

	  The connection factory type must be supplied unless an
	  injection target is specified, in which case the type
	  of the target is used.  If both are specified, the type
	  must be assignment compatible with the type of the injection
	  target.

	  Example:

	  <resource-ref>
	      <res-ref-name>jdbc/EmployeeAppDB</res-ref-name>
	      <res-type>javax.sql.DataSource</res-type>
	      <res-auth>Container</res-auth>
	      <res-sharing-scope>Shareable</res-sharing-scope>
	  </resource-ref>

	  ]]>
      ")
@ExtendedMetaData(name="resource-refType", kind="elementOnly")
class ResourceRefType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@GenModel(documentation="

	    The res-ref-name element specifies the name of a
	    resource manager connection factory reference.
	    The name is a JNDI name relative to the
	    java:comp/env context.
	    The name must be unique within a Deployment File.

	  ")
	@ExtendedMetaData(kind="element", name="res-ref-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val JndiNameType[1] resRefName;

	@GenModel(documentation="

	    The res-type element specifies the type of the data
	    source. The type is specified by the fully qualified
	    Java language class or interface
	    expected to be implemented by the data source.

	  ")
	@ExtendedMetaData(kind="element", name="res-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType resType;

	@ExtendedMetaData(kind="element", name="res-auth", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ResAuthType resAuth;

	@ExtendedMetaData(kind="element", name="res-sharing-scope", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ResSharingScopeType resSharingScope;

	@GenModel(documentation="
	    <![CDATA[

	      A product specific name that this resource should be
	      mapped to.  The name of this resource, as defined by the
	      resource's name element or defaulted, is a name that is
	      local to the application component using the resource.
	      (It's a name in the JNDI java:comp/env namespace.)  Many
	      application servers provide a way to map these local
	      names to names of resources known to the application
	      server.  This mapped name is often a global JNDI name,
	      but may be a name of any form.

	      Application servers are not required to support any
	      particular form or type of mapped name, nor the ability
	      to use mapped names.  The mapped name is
	      product-dependent and often installation-dependent.  No
	      use of a mapped name is portable.

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="mapped-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType mappedName;

	@ExtendedMetaData(kind="element", name="injection-target", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val InjectionTargetType[*] injectionTarget;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The res-sharing-scope type specifies whether connections
	obtained through the given resource manager connection
	factory reference can be shared. The value, if specified,
	must be one of the two following:

	    Shareable
	    Unshareable

	The default value is Shareable.

      ")
@ExtendedMetaData(name="res-sharing-scopeType", kind="simple")
class ResSharingScopeType extends String {
}

@ExtendedMetaData(name="res-sharing-scopeType_._base")
enum ResSharingScopeTypeBase {
	Shareable = 0;
	Unshareable = 1;
}

@ExtendedMetaData(name="res-sharing-scopeType_._base:Object", baseType="res-sharing-scopeType_._base")
datatype ResSharingScopeTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="

	The result-type-mappingType is used in the query element to
	specify whether an abstract schema type returned by a query
	for a select method is to be mapped to an EJBLocalObject or
	EJBObject type.

	The value must be one of the following:

	    Local
	    Remote

      ")
@ExtendedMetaData(name="result-type-mappingType", kind="simple")
class ResultTypeMappingType extends String {
}

@ExtendedMetaData(name="result-type-mappingType_._base")
enum ResultTypeMappingTypeBase {
	Local = 0;
	Remote = 1;
}

@ExtendedMetaData(name="result-type-mappingType_._base:Object", baseType="result-type-mappingType_._base")
datatype ResultTypeMappingTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="

	The role-nameType designates the name of a security role.

	The name must conform to the lexical rules for a token.

      ")
@ExtendedMetaData(name="role-nameType", kind="simple")
class RoleNameType extends String {
}

@ExtendedMetaData(name="role-nameType_._base", baseType="http://www.eclipse.org/emf/2003/XMLType#token")
datatype RoleNameTypeBase : java.lang.String;

@GenModel(documentation="

	The run-asType specifies the run-as identity to be
	used for the execution of a component. It contains an
	optional description, and the name of a security role.

      ")
@ExtendedMetaData(name="run-asType", kind="elementOnly")
class RunAsType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="role-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val RoleNameType[1] roleName;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The security-identityType specifies whether the caller's
	security identity is to be used for the execution of the
	methods of the enterprise bean or whether a specific run-as
	identity is to be used. It contains an optional description
	and a specification of the security identity to be used.

      ")
@ExtendedMetaData(name="security-identityType", kind="elementOnly")
class SecurityIdentityType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@GenModel(documentation="

	      The use-caller-identity element specifies that
	      the caller's security identity be used as the
	      security identity for the execution of the
	      enterprise bean's methods.

	    ")
	@ExtendedMetaData(kind="element", name="use-caller-identity", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EmptyType useCallerIdentity;

	@ExtendedMetaData(kind="element", name="run-as", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val RunAsType runAs;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The security-role-refType contains the declaration of a
	security role reference in a component's or a
	Deployment Component's code. The declaration consists of an
	optional description, the security role name used in the
	code, and an optional link to a security role. If the
	security role is not specified, the Deployer must choose an
	appropriate security role.

      ")
@ExtendedMetaData(name="security-role-refType", kind="elementOnly")
class SecurityRoleRefType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@GenModel(documentation="

	    The value of the role-name element must be the String used
	    as the parameter to the
	    EJBContext.isCallerInRole(String roleName) method or the
	    HttpServletRequest.isUserInRole(String role) method.

	  ")
	@ExtendedMetaData(kind="element", name="role-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val RoleNameType[1] roleName;

	@GenModel(documentation="

	    The role-link element is a reference to a defined
	    security role. The role-link element must contain
	    the name of one of the security roles defined in the
	    security-role elements.

	  ")
	@ExtendedMetaData(kind="element", name="role-link", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val RoleNameType roleLink;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="
	<![CDATA[

	  The security-roleType contains the definition of a security
	  role. The definition consists of an optional description of
	  the security role, and the security role name.

	  Example:

	      <security-role>
	      <description>
		  This role includes all employees who are authorized
		  to access the employee service application.
	      </description>
	      <role-name>employee</role-name>
	      </security-role>

	  ]]>
      ")
@ExtendedMetaData(name="security-roleType", kind="elementOnly")
class SecurityRoleType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="role-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val RoleNameType[1] roleName;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

      The handler-chains element defines the handlerchains associated with this
      service or service endpoint.

      ")
@ExtendedMetaData(name="service-ref_handler-chainsType", kind="elementOnly")
class ServiceRefHandlerChainsType {

	@ExtendedMetaData(kind="element", name="handler-chain", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ServiceRefHandlerChainType[*] handlerChain;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

      The handler-chain element defines the handlerchain.
      Handlerchain can be defined such that the handlers in the
      handlerchain operate,all ports of a service, on a specific
      port or on a list of protocol-bindings. The choice of elements
      service-name-pattern, port-name-pattern and protocol-bindings
      are used to specify whether the handlers in handler-chain are
      for a service, port or protocol binding. If none of these
      choices are specified with the handler-chain element then the
      handlers specified in the handler-chain will be applied on
      everything.

      ")
@ExtendedMetaData(name="service-ref_handler-chainType", kind="elementOnly")
class ServiceRefHandlerChainType {

	@ExtendedMetaData(kind="element", name="service-name-pattern", namespace="http://java.sun.com/xml/ns/javaee")
	attr ServiceRefQnamePattern serviceNamePattern;

	@ExtendedMetaData(kind="element", name="port-name-pattern", namespace="http://java.sun.com/xml/ns/javaee")
	attr ServiceRefQnamePattern portNamePattern;

	@ExtendedMetaData(kind="element", name="protocol-bindings", namespace="http://java.sun.com/xml/ns/javaee")
	attr ServiceRefProtocolBindingListType protocolBindings;

	@ExtendedMetaData(kind="element", name="handler", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ServiceRefHandlerType[+] handler;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	Declares the handler for a port-component. Handlers can access the
	init-param name/value pairs using the HandlerInfo interface. If
	port-name is not specified, the handler is assumed to be associated
	with all ports of the service.

	Used in: service-ref

      ")
@ExtendedMetaData(name="service-ref_handlerType", kind="elementOnly")
class ServiceRefHandlerType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="display-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DisplayNameType[*] displayName;

	@ExtendedMetaData(kind="element", name="icon", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val IconType[*] icon;

	@GenModel(documentation="

	    Defines the name of the handler. The name must be unique
	    within the module.

	  ")
	@ExtendedMetaData(kind="element", name="handler-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val String[1] handlerName;

	@GenModel(documentation="

	    Defines a fully qualified class name for the handler
	    implementation.

	  ")
	@ExtendedMetaData(kind="element", name="handler-class", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType[1] handlerClass;

	@ExtendedMetaData(kind="element", name="init-param", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ParamValueType[*] initParam;

	@GenModel(documentation="

	    Defines the QName of a SOAP header that will be processed
	    by the handler.

	  ")
	@ExtendedMetaData(kind="element", name="soap-header", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdQNameType[*] soapHeader;

	@GenModel(documentation="

	    The soap-role element contains a SOAP actor definition that
	    the Handler will play as a role.

	  ")
	@ExtendedMetaData(kind="element", name="soap-role", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val String[*] soapRole;

	@GenModel(documentation="

	    The port-name element defines the WSDL port-name that a
	    handler should be associated with.

	  ")
	@ExtendedMetaData(kind="element", name="port-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val String[*] portName;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="
	   Defines the type used for specifying a list of
	   protocol-bindingType(s). For e.g.

	    ##SOAP11_HTTP ##SOAP12_HTTP ##XML_HTTP

        ")
@ExtendedMetaData(name="service-ref_protocol-bindingListType", itemType="service-ref_protocol-bindingType")
datatype ServiceRefProtocolBindingListType : java.util.List;

@GenModel(documentation="
	   Defines the type used for specifying the URI for the
	   protocol binding used by the port-component.  For
	   portability one could use one of the following tokens that
	   alias the standard binding types:

	    ##SOAP11_HTTP
	    ##SOAP11_HTTP_MTOM
            ##SOAP12_HTTP
            ##SOAP12_HTTP_MTOM
            ##XML_HTTP

	   Other specifications could define tokens that start with ##
	   to alias new standard binding URIs that are introduced.

        ")
@ExtendedMetaData(name="service-ref_protocol-bindingType", memberTypes="http://www.eclipse.org/emf/2003/XMLType#anyURI service-ref_protocol-URIAliasType")
datatype ServiceRefProtocolBindingType : java.lang.String;

@GenModel(documentation="
	   Defines the type that is used for specifying tokens that
	   start with ## which are used to alias existing standard
	   protocol bindings and support aliases for new standard
	   binding URIs that are introduced in future specifications.

	   The following tokens alias the standard protocol binding
	   URIs:

	   ##SOAP11_HTTP = \"http://schemas.xmlsoap.org/wsdl/soap/http\"
	   ##SOAP11_HTTP_MTOM =
                 \"http://schemas.xmlsoap.org/wsdl/soap/http?mtom=true\"
           ##SOAP12_HTTP = \"http://www.w3.org/2003/05/soap/bindings/HTTP/\"
           ##SOAP12_HTTP_MTOM =
                 \"http://www.w3.org/2003/05/soap/bindings/HTTP/?mtom=true\"
           ##XML_HTTP = \"http://www.w3.org/2004/08/wsdl/http\"

        ")
@ExtendedMetaData(name="service-ref_protocol-URIAliasType", baseType="http://www.eclipse.org/emf/2003/XMLType#token", pattern="##.+")
datatype ServiceRefProtocolURIAliasType : java.lang.String;

@GenModel(documentation="
	     This is used to specify the QName pattern in the
	     attribute service-name-pattern and port-name-pattern in
	     the handler-chain element

	     For example, the various forms acceptable here for
	     service-name-pattern attribute in handler-chain element
	     are :

	     Exact Name: service-name-pattern=\"ns1:EchoService\"

		 In this case, handlers specified in this
		 handler-chain element will apply to all ports with
		 this exact service name. The namespace prefix must
		 have been declared in a namespace declaration
		 attribute in either the start-tag of the element
		 where the prefix is used or in an an ancestor
		 element (i.e. an element in whose content the
		 prefixed markup occurs)

	     Pattern : service-name-pattern=\"ns1:EchoService*\"

		 In this case, handlers specified in this
		 handler-chain element will apply to all ports whose
		 Service names are like EchoService1, EchoServiceFoo
		 etc. The namespace prefix must have been declared in
		 a namespace declaration attribute in either the
		 start-tag of the element where the prefix is used or
		 in an an ancestor element (i.e. an element in whose
		 content the prefixed markup occurs)

	     Wild Card : service-name-pattern=\"*\"

		In this case, handlers specified in this handler-chain
		element will apply to ports of all service names.

	    The same can be applied to port-name attribute in
	    handler-chain element.

        ")
@ExtendedMetaData(name="service-ref_qname-pattern", baseType="http://www.eclipse.org/emf/2003/XMLType#token", pattern="\*|([\i-[:]][\c-[:]]*:)?[\i-[:]][\c-[:]]*\*?")
datatype ServiceRefQnamePattern : java.lang.String;

@GenModel(documentation="

	The service-ref element declares a reference to a Web
	service. It contains optional description, display name and
	icons, a declaration of the required Service interface,
	an optional WSDL document location, an optional set
	of JAX-RPC mappings, an optional QName for the service element,
	an optional set of Service Endpoint Interfaces to be resolved
	by the container to a WSDL port, and an optional set of handlers.

      ")
@ExtendedMetaData(name="service-refType", kind="elementOnly")
class ServiceRefType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="display-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DisplayNameType[*] displayName;

	@ExtendedMetaData(kind="element", name="icon", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val IconType[*] icon;

	@GenModel(documentation="

	    The service-ref-name element declares logical name that the
	    components in the module use to look up the Web service. It
	    is recommended that all service reference names start with
	    \"service/\".

	  ")
	@ExtendedMetaData(kind="element", name="service-ref-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val JndiNameType[1] serviceRefName;

	@GenModel(documentation="

	    The service-interface element declares the fully qualified class
	    name of the JAX-RPC Service interface the client depends on.
	    In most cases the value will be javax.xml.rpc.Service.  A JAX-RPC
	    generated Service Interface class may also be specified.

	  ")
	@ExtendedMetaData(kind="element", name="service-interface", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType[1] serviceInterface;

	@GenModel(documentation="

	    The service-ref-type element declares the type of the service-ref
	    element that is injected or returned when a JNDI lookup is done.
	    This must be either a fully qualified name of Service class or
	    the fully qualified name of service endpoint interface class.
	    This is only used with JAX-WS runtime where the corresponding
	    @WebServiceRef annotation can be used to denote both a Service
	    or a Port.

	    If this is not specified, then the type of service-ref element
	    that is injected or returned when a JNDI lookup is done is
	    always a Service interface/class.
	  ")
	@ExtendedMetaData(kind="element", name="service-ref-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType serviceRefType;

	@GenModel(documentation="

	    The wsdl-file element contains the URI location of a WSDL
	    file. The location is relative to the root of the module.

	  ")
	@ExtendedMetaData(kind="element", name="wsdl-file", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdAnyURIType wsdlFile;

	@GenModel(documentation="

	    The jaxrpc-mapping-file element contains the name of a file that
	    describes the JAX-RPC mapping between the Java interaces used by
	    the application and the WSDL description in the wsdl-file.  The
	    file name is a relative path within the module file.

	    This is not required when JAX-WS based runtime is used.

	  ")
	@ExtendedMetaData(kind="element", name="jaxrpc-mapping-file", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PathType jaxrpcMappingFile;

	@GenModel(documentation="

	    The service-qname element declares the specific WSDL service
	    element that is being refered to.  It is not specified if no
	    wsdl-file is declared.

	  ")
	@ExtendedMetaData(kind="element", name="service-qname", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdQNameType serviceQname;

	@GenModel(documentation="

	    The port-component-ref element declares a client dependency
	    on the container for resolving a Service Endpoint Interface
	    to a WSDL port. It optionally associates the Service Endpoint
	    Interface with a particular port-component. This is only used
	    by the container for a Service.getPort(Class) method call.

	  ")
	@ExtendedMetaData(kind="element", name="port-component-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PortComponentRefType[*] portComponentRef;

	@GenModel(documentation="

		Declares the handler for a port-component. Handlers can
		access the init-param name/value pairs using the
		HandlerInfo interface. If port-name is not specified, the
		handler is assumed to be associated with all ports of the
		service.

		To be used with JAX-RPC based runtime only.

	      ")
	@ExtendedMetaData(kind="element", name="handler", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ServiceRefHandlerType[*] handler;

	@GenModel(documentation="
		 To be used with JAX-WS based runtime only.
	      ")
	@ExtendedMetaData(kind="element", name="handler-chains", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ServiceRefHandlerChainsType handlerChains;

	@GenModel(documentation="
	    <![CDATA[

	      A product specific name that this resource should be
	      mapped to.  The name of this resource, as defined by the
	      resource's name element or defaulted, is a name that is
	      local to the application component using the resource.
	      (It's a name in the JNDI java:comp/env namespace.)  Many
	      application servers provide a way to map these local
	      names to names of resources known to the application
	      server.  This mapped name is often a global JNDI name,
	      but may be a name of any form.

	      Application servers are not required to support any
	      particular form or type of mapped name, nor the ability
	      to use mapped names.  The mapped name is
	      product-dependent and often installation-dependent.  No
	      use of a mapped name is portable.

	      ]]>
	  ")
	@ExtendedMetaData(kind="element", name="mapped-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType mappedName;

	@ExtendedMetaData(kind="element", name="injection-target", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val InjectionTargetType[*] injectionTarget;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The session-beanType declares an session bean. The
	declaration consists of:

	    - an optional description
	    - an optional display name
	    - an optional icon element that contains a small and a large
	      icon file name
	    - a name assigned to the enterprise bean
	      in the deployment description
            - an optional mapped-name element that can be used to provide
              vendor-specific deployment information such as the physical
              jndi-name of the session bean's remote home/business interface.
              This element is not required to be supported by all
              implementations. Any use of this element is non-portable.
            - the names of all the remote or local business interfaces,
              if any
	    - the names of the session bean's remote home and
	      remote interfaces, if any
	    - the names of the session bean's local home and
	      local interfaces, if any
	    - the name of the session bean's web service endpoint
	      interface, if any
	    - the session bean's implementation class
	    - the session bean's state management type
            - an optional declaration of the session bean's timeout method.
	    - the optional session bean's transaction management type.
              If it is not present, it is defaulted to Container.
            - an optional list of the session bean class and/or
              superclass around-invoke methods.
	    - an optional declaration of the bean's
	      environment entries
	    - an optional declaration of the bean's EJB references
	    - an optional declaration of the bean's local
	      EJB references
	    - an optional declaration of the bean's web
	      service references
	    - an optional declaration of the security role
	      references
	    - an optional declaration of the security identity
	      to be used for the execution of the bean's methods
	    - an optional declaration of the bean's resource
	      manager connection factory references
	    - an optional declaration of the bean's resource
	      environment references.
	    - an optional declaration of the bean's message
	      destination references

	The elements that are optional are \"optional\" in the sense
	that they are omitted when if lists represented by them are
	empty.

	Either both the local-home and the local elements or both
	the home and the remote elements must be specified for the
	session bean.

	The service-endpoint element may only be specified if the
	bean is a stateless session bean.

      ")
@ExtendedMetaData(name="session-beanType", kind="elementOnly")
class SessionBeanType {

	@ExtendedMetaData(kind="element", name="description", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DescriptionType[*] description;

	@ExtendedMetaData(kind="element", name="display-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val DisplayNameType[*] displayName;

	@ExtendedMetaData(kind="element", name="icon", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val IconType[*] icon;

	@ExtendedMetaData(kind="element", name="ejb-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbNameType[1] ejbName;

	@ExtendedMetaData(kind="element", name="mapped-name", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val XsdStringType mappedName;

	@ExtendedMetaData(kind="element", name="home", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val HomeType home;

	@ExtendedMetaData(kind="element", name="remote", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val RemoteType remote;

	@ExtendedMetaData(kind="element", name="local-home", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LocalHomeType localHome;

	@ExtendedMetaData(kind="element", name="local", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LocalType local;

	@ExtendedMetaData(kind="element", name="business-local", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType[*] businessLocal;

	@ExtendedMetaData(kind="element", name="business-remote", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType[*] businessRemote;

	@GenModel(documentation="

	    The service-endpoint element contains the
	    fully-qualified name of the enterprise bean's web
	    service endpoint interface. The service-endpoint
	    element may only be specified for a stateless
	    session bean. The specified interface must be a
	    valid JAX-RPC service endpoint interface.

	  ")
	@ExtendedMetaData(kind="element", name="service-endpoint", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val FullyQualifiedClassType serviceEndpoint;

	@GenModel(documentation="

             The ejb-class element specifies the fully qualified name
             of the bean class for this ejb.  It is required unless
             there is a component-defining annotation for the same
             ejb-name.

          ")
	@ExtendedMetaData(kind="element", name="ejb-class", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbClassType ejbClass;

	@ExtendedMetaData(kind="element", name="session-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val SessionTypeType sessionType;

	@ExtendedMetaData(kind="element", name="timeout-method", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val NamedMethodType timeoutMethod;

	@GenModel(documentation="

	    The init-method element specifies the mappings for
	    EJB 2.x style create methods for an EJB 3.0 bean.
	    This element can only be specified for stateful
            session beans.

	  ")
	@ExtendedMetaData(kind="element", name="init-method", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val InitMethodType[*] initMethod;

	@GenModel(documentation="

	    The remove-method element specifies the mappings for
	    EJB 2.x style remove methods for an EJB 3.0 bean.
	    This element can only be specified for stateful
            session beans.

	  ")
	@ExtendedMetaData(kind="element", name="remove-method", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val RemoveMethodType[*] removeMethod;

	@ExtendedMetaData(kind="element", name="transaction-type", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val TransactionTypeType transactionType;

	@ExtendedMetaData(kind="element", name="around-invoke", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val AroundInvokeType[*] aroundInvoke;

	@ExtendedMetaData(kind="element", name="env-entry", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EnvEntryType[*] envEntry;

	@ExtendedMetaData(kind="element", name="ejb-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbRefType[*] ejbRef;

	@ExtendedMetaData(kind="element", name="ejb-local-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val EjbLocalRefType[*] ejbLocalRef;

	@ExtendedMetaData(kind="element", name="service-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ServiceRefType[*] serviceRef;

	@ExtendedMetaData(kind="element", name="resource-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ResourceRefType[*] resourceRef;

	@ExtendedMetaData(kind="element", name="resource-env-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val ResourceEnvRefType[*] resourceEnvRef;

	@ExtendedMetaData(kind="element", name="message-destination-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val MessageDestinationRefType[*] messageDestinationRef;

	@ExtendedMetaData(kind="element", name="persistence-context-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PersistenceContextRefType[*] persistenceContextRef;

	@ExtendedMetaData(kind="element", name="persistence-unit-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val PersistenceUnitRefType[*] persistenceUnitRef;

	@ExtendedMetaData(kind="element", name="post-construct", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LifecycleCallbackType[*] postConstruct;

	@ExtendedMetaData(kind="element", name="pre-destroy", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LifecycleCallbackType[*] preDestroy;

	@ExtendedMetaData(kind="element", name="post-activate", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LifecycleCallbackType[*] postActivate;

	@ExtendedMetaData(kind="element", name="pre-passivate", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val LifecycleCallbackType[*] prePassivate;

	@ExtendedMetaData(kind="element", name="security-role-ref", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val SecurityRoleRefType[*] securityRoleRef;

	@ExtendedMetaData(kind="element", name="security-identity", namespace="http://java.sun.com/xml/ns/javaee")
	!resolve val SecurityIdentityType securityIdentity;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The session-typeType describes whether the session bean is a
	stateful session or stateless session. It is used by
	session-type elements.

	The value must be one of the two following:

	    Stateful
	    Stateless

      ")
@ExtendedMetaData(name="session-typeType", kind="simple")
class SessionTypeType extends String {
}

@ExtendedMetaData(name="session-typeType_._base")
enum SessionTypeTypeBase {
	Stateful = 0;
	Stateless = 1;
}

@ExtendedMetaData(name="session-typeType_._base:Object", baseType="session-typeType_._base")
datatype SessionTypeTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="

	This is a special string datatype that is defined by Java EE as
	a base type for defining collapsed strings. When schemas
	require trailing/leading space elimination as well as
	collapsing the existing whitespace, this base type may be
	used.

      ")
@ExtendedMetaData(name="string", kind="simple")
class String {

	@ExtendedMetaData(name=":0", kind="simple")
	attr type.Token value;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	The transaction-typeType specifies an enterprise bean's
	transaction management type.

	The transaction-type must be one of the two following:

	    Bean
	    Container

      ")
@ExtendedMetaData(name="transaction-typeType", kind="simple")
class TransactionTypeType extends String {
}

@ExtendedMetaData(name="transaction-typeType_._base")
enum TransactionTypeTypeBase {
	Bean = 0;
	Container = 1;
}

@ExtendedMetaData(name="transaction-typeType_._base:Object", baseType="transaction-typeType_._base")
datatype TransactionTypeTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="

	The trans-attributeType specifies how the container must
	manage the transaction boundaries when delegating a method
	invocation to an enterprise bean's business method.

	The value must be one of the following:

	    NotSupported
	    Supports
	    Required
	    RequiresNew
	    Mandatory
	    Never

      ")
@ExtendedMetaData(name="trans-attributeType", kind="simple")
class TransAttributeType extends String {
}

@ExtendedMetaData(name="trans-attributeType_._base")
enum TransAttributeTypeBase {
	NotSupported = 0;
	Supports = 1;
	Required = 2;
	RequiresNew = 3;
	Mandatory = 4;
	Never = 5;
}

@ExtendedMetaData(name="trans-attributeType_._base:Object", baseType="trans-attributeType_._base")
datatype TransAttributeTypeBaseObject : org.eclipse.emf.common.util.Enumerator;

@GenModel(documentation="

	This simple type designates a boolean with only two
	permissible values

	- true
	- false

      ")
@ExtendedMetaData(name="true-falseType", kind="simple")
class TrueFalseType extends XsdBooleanType {
}

@ExtendedMetaData(name="true-falseType_._base", baseType="http://www.eclipse.org/emf/2003/XMLType#boolean", pattern="(true|false)")
datatype TrueFalseTypeBase : boolean;

@ExtendedMetaData(name="true-falseType_._base:Object", baseType="true-falseType_._base")
datatype TrueFalseTypeBaseObject : java.lang.Boolean;

@GenModel(documentation="

	The url-patternType contains the url pattern of the mapping.
	It must follow the rules specified in Section 11.2 of the
	Servlet API Specification. This pattern is assumed to be in
	URL-decoded form and must not contain CR(#xD) or LF(#xA).
	If it contains those characters, the container must inform
	the developer with a descriptive error message.
	The container must preserve all characters including whitespaces.

      ")
@ExtendedMetaData(name="url-patternType", kind="simple")
class UrlPatternType {

	@ExtendedMetaData(name=":0", kind="simple")
	attr type.String value;
}

@GenModel(documentation="

	This type adds an \"id\" attribute to xsd:anyURI.

      ")
@ExtendedMetaData(name="xsdAnyURIType", kind="simple")
class XsdAnyURIType {

	@ExtendedMetaData(name=":0", kind="simple")
	attr type.AnyURI value;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	This type adds an \"id\" attribute to xsd:boolean.

      ")
@ExtendedMetaData(name="xsdBooleanType", kind="simple")
class XsdBooleanType {

	@ExtendedMetaData(name=":0", kind="simple")
	unsettable attr type.Boolean value;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	This type adds an \"id\" attribute to xsd:integer.

      ")
@ExtendedMetaData(name="xsdIntegerType", kind="simple")
class XsdIntegerType {

	@ExtendedMetaData(name=":0", kind="simple")
	attr type.Integer value;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	This type adds an \"id\" attribute to xsd:NMTOKEN.

      ")
@ExtendedMetaData(name="xsdNMTOKENType", kind="simple")
class XsdNMTOKENType {

	@ExtendedMetaData(name=":0", kind="simple")
	attr type.NMTOKEN value;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	This type adds an \"id\" attribute to xsd:nonNegativeInteger.

      ")
@ExtendedMetaData(name="xsdNonNegativeIntegerType", kind="simple")
class XsdNonNegativeIntegerType {

	@ExtendedMetaData(name=":0", kind="simple")
	attr type.NonNegativeInteger value;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	This type adds an \"id\" attribute to xsd:positiveInteger.

      ")
@ExtendedMetaData(name="xsdPositiveIntegerType", kind="simple")
class XsdPositiveIntegerType {

	@ExtendedMetaData(name=":0", kind="simple")
	attr type.PositiveInteger value;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	This type adds an \"id\" attribute to xsd:QName.

      ")
@ExtendedMetaData(name="xsdQNameType", kind="simple")
class XsdQNameType {

	@ExtendedMetaData(name=":0", kind="simple")
	attr type.QName value;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

@GenModel(documentation="

	This type adds an \"id\" attribute to xsd:string.

      ")
@ExtendedMetaData(name="xsdStringType", kind="simple")
class XsdStringType {

	@ExtendedMetaData(name=":0", kind="simple")
	attr type.String value;

	@ExtendedMetaData(kind="attribute", name="id")
	id attr type.ID ~id;
}

